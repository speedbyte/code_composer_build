/******************************************************************************/
/*****************  Copyright (c) 2008 by S1nn GmbH & Co. KG  *****************/
/***************************  All Rights Reserved  ****************************/
/******************************************************************************/

/******************************************************************************/
/* File Name:     APP_SD_C1.c
*-----------------------------------------------------------------------------
* Module Name:    APP_SD
*-----------------------------------------------------------------------------
* Description:    Handles the context frames and logic of the SD as specified
                  in Visio-EEFI1_UHV_NAR_Kombi_Instrument_Menueablaeufe_V7E_20090320_LK.pdf.
*-----------------------------------------------------------------------------
* $Date: 2012-02-07 08:49:46 +0100 (Di, 07 Feb 2012) $
* $Rev: 25568 $
* $Author: maennel $
* $URL: http://subversion-01/svn/SW_HW_System/Projects/VW_UHV-NAR/SW/MOD/MOD_APP_SD/trunk/src/APP_SD_C1.c $
*-----------------------------------------------------------------------------
*/
/******************************************************************************/

/*----------------------------------------------------------------------------*/
/* System Includes                                                            */
/*----------------------------------------------------------------------------*/
#include "ERM.h"
#include "ERM_Utils.h"
#include "ERM_DeviceHandler.h"
#include "OSEK_AppTask_H1.h"
#include "BAP_Dispatcher.h"
#include "APP_COMMON_Utils.h"
#include "APP_PHONE_AT.h"
#include "APP_PHONE_AT_PNCC.h"
#include "APP_DEVICE.h"
#include "APP_PHONEBOOK.h"
#include "APP_PHONEBOOK_AT.h"
#include "APP_DIAG.h"
#include "LOGI_BUT_MAN.h"
#include "ATCommonData.h"
#include "ATParser.h"
#include "APP_CAN_Speed.h"
#include "POOL.h"
#include "APP_MDI.h"
#include "APP_MDI_AT.h"
#include "VCR.h"
#include "KPB.h"
#include "CONTEXT_MAN.h"
#include "stdio.h"
#include "Version.h"
#include "CSHDL.h"
#include "EEPROM_LAYOUT_CFG.h"
/*----------------------------------------------------------------------------*/
/* Libraries from external Vendors                                            */
/*----------------------------------------------------------------------------*/
#include <osek.h>           // vector
#include <osekext.h>        // vector
#include "bap_defines.h"    // vw

/*----------------------------------------------------------------------------*/
/* Own Header Files                                                           */
/*----------------------------------------------------------------------------*/
#include "TRACE.h"
#include "APP_SD_C1.id"


#include "APP_SD.h"
#include "APP_SD_CI.h"
#include "APP_SD_CE.h"
#include "APP_SD_ListCtrl.h"
#include "APP_SD_FrameBuilder.h"
#include "APP_SD_Icons.h"
#include "APP_SD_FrameDataBase.h"
#include "APP_SD_Mailbox.h"


/*----------------------------------------------------------------------------*/
/* pragma Directives                                                          */
/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Global Variables Definitions (avoid as much as possible!)                  */
/*----------------------------------------------------------------------------*/

/**
\brief  variable to save the module global variables
*/
AppSdContext            gAppSdContext;
AppSdFrameDataType      gFrameData;

/*----------------------------------------------------------------------------*/
/* Private Manifest Constant Definitions                                      */
/*----------------------------------------------------------------------------*/
#if 0
#define NUM_MAILBOX_SEARCH_KEYWORDS_GERMAN      4
#define NUM_MAILBOX_SEARCH_KEYWORDS_ENGLISH     4
#define NUM_MAILBOX_SEARCH_KEYWORDS_SPANISH     2
#define NUM_MAILBOX_SEARCH_KEYWORDS_FRENCH      2
#define NUM_MAILBOX_SEARCH_KEYWORDS_PORTUGESE   1
#define NUM_MAILBOX_SEARCH_KEYWORDS_CZECH       5
#define NUM_MAILBOX_SEARCH_KEYWORDS_RUSSIAN     1
#define NUM_MAILBOX_SEARCH_KEYWORDS_ITALIAN     1
#define NUM_MAILBOX_SEARCH_KEYWORDS_DUTCH       4


// maximum number of keywords per language is set by Czech language
#define MAX_MBOX_KEYWORDS_PER_LANGUAGE  NUM_MAILBOX_SEARCH_KEYWORDS_CZECH
#endif

// maximum number of keywords per language
#define MAX_MBOX_KEYWORDS_PER_LANGUAGE  5

// mask for the ssp config in extended inquiry result
#define APP_SD_SSP_INQUIRY_RESULT_MASK      (Uint32Type) 0x0080u
#define APP_SD_SSP_INQUIRY_RESULT_ENABLE    APP_SD_SSP_INQUIRY_RESULT_MASK
#define APP_SD_SSP_INQUIRY_RESULT_DISABLE   (Uint32Type) 0x0000u
/*----------------------------------------------------------------------------*/
/* Private Types                                                              */
/*----------------------------------------------------------------------------*/
/**
\brief  description of the type
*/


// HINT: PB Search in CK5050 does not care about accents. So the result when
// searching for e.g. 'Buzón de Voz' will be the same as for 'Buzon de Voz'.
// Thats also the reason why we have only 2 keywords e.g. for French, although
// there are 4 specified in SD Spec.
#if 0
// Sprachmailbox
static const Uint8Type APP_SD_MBOX__Sprachmailbox[0x0D] = {0x53,0x70,0x72,0x61,0x63,0x68,0x6D,0x61,0x69,0x6C,0x62,0x6F,0x78};
// Mailbox
static const Uint8Type APP_SD_MBOX__Mailbox[0x07] = {0x4D,0x61,0x69,0x6C,0x62,0x6F,0x78};
// Sprachnachrichten
static const Uint8Type APP_SD_MBOX__Sprachnachrichten[0x11] = {0x53,0x70,0x72,0x61,0x63,0x68,0x6e,0x61,0x63,0x68,0x72,0x69,0x63,0x68,0x74,0x65,0x6e};
// Anrufbeantworter
static const Uint8Type APP_SD_MBOX__Anrufbeantworter[0x10] = {0x41,0x6e,0x72,0x75,0x66,0x62,0x65,0x61,0x6e,0x74,0x77,0x6f,0x72,0x74,0x65,0x72};
// Voicemail
static const Uint8Type APP_SD_MBOX__Voicemail[] = {0x56,0x6f,0x69,0x63,0x65,0x6d,0x61,0x69,0x6c};
// mailbox
static const Uint8Type APP_SD_MBOX__mailbox[] = {0x6d,0x61,0x69,0x6c,0x62,0x6f,0x78};
// voice messages
static const Uint8Type APP_SD_MBOX__voice_messages[] = {0x76,0x6f,0x69,0x63,0x65,0x20,0x6d,0x65,0x73,0x73,0x61,0x67,0x65,0x73};
// voicemailbox
static const Uint8Type APP_SD_MBOX__voicemailbox[] = {0x76,0x6f,0x69,0x63,0x65,0x6d,0x61,0x69,0x6c,0x62,0x6f,0x78};
// Buzón de Voz  // Bytes are without accents!!!
static const Uint8Type APP_SD_MBOX__Buzon_de_Voz_acc[] = {0x42,0x75,0x7a,0x6f,0x6e,0x20,0x64,0x65,0x20,0x56,0x6f,0x7a};
// Mensajes de Voz
static const Uint8Type APP_SD_MBOX__Mensajes_de_Voz[] = {0x4d,0x65,0x6e,0x73,0x61,0x6a,0x65,0x73,0x20,0x64,0x65,0x20,0x56,0x6f,0x7a};
// messagerie vocale
static const Uint8Type APP_SD_MBOX__messagerie_vocale[] = {0x6d,0x65,0x73,0x73,0x61,0x67,0x65,0x72,0x69,0x65,0x20,0x76,0x6f,0x63,0x61,0x6c,0x65};
// Boîte vocale // Bytes are without accents!!!
static const Uint8Type APP_SD_MBOX__Boite_vocale_acc[] = {0x42,0x6f,0x69,0x74,0x65,0x20,0x76,0x6f,0x63,0x61,0x6c,0x65};
// caixa correio voz
static const Uint8Type APP_SD_MBOX__caixa_correio_voz[] = {0x63,0x61,0x69,0x78,0x61,0x20,0x63,0x6f,0x72,0x72,0x65,0x69,0x6f,0x20,0x76,0x6f,0x7a};
// Hlasová schránka  // when searching CK5050 result will be the same as for Hlasova schranka
//static const Uint8Type APP_SD_MBOX__Hlasova_schranka_acc[] = {0x00};
// Hlasova schranka
static const Uint8Type APP_SD_MBOX__Hlasova_schranka[] = {0x48,0x6c,0x61,0x73,0x6f,0x76,0x61,0x20,0x73,0x63,0x68,0x72,0x61,0x6e,0x6b,0x61};
// Schránka // when searching CK5050 result will be the same as for Schranka
//static const Uint8Type APP_SD_MBOX__Schranka_acc[] = {0x00};
// Schranka
static const Uint8Type APP_SD_MBOX__Schranka[] = {0x53,0x63,68,0x72,0x61,0x6e,0x6b,0x61};
// mailbox in Russian
static const Uint8Type APP_SD_MBOX__Russian[] =
{0xd0,0x93,0xd0,0xbe,0xd0,0xbb,0xd0,0xbe,0xd1,0x81,0xd0,0xbe,0xd0,0xb2,0xd0,0xbe,0xd0,0xb9,0x20,0xd1,0x8f,0xd1,0x89,0xd0,0xb8,0xd0,0xba};
// Casella vocale
static const Uint8Type APP_SD_MBOX__Casella_vocale[] = {0x43,0x61,0x73,0x65,0x6c,0x6c,0x61,0x20,0x76,0x6f,0x63,0x61,0x6c,0x65};
#endif

const APP_SD_ST_LOOKUP_TABLE_MAILBOX_PROMPTS
APP_SD_aStaticMailboxKeywords[APP_SD_enMAX_LANGUAGE][MAX_MBOX_KEYWORDS_PER_LANGUAGE] = {
{
    // if one language uses less than MAX_MBOX_KEYWORDS_PER_LANGUAGE set NULL
    // for difference
    // ENGLISH
  { (APP_SD_au8English_ta_find_mailbox_1)   , sizeof(APP_SD_au8English_ta_find_mailbox_1)},     // eng 1
  { (APP_SD_au8English_ta_find_mailbox_2)   , sizeof(APP_SD_au8English_ta_find_mailbox_2)},     // eng 2
  { (APP_SD_au8English_ta_find_mailbox_3)   , sizeof(APP_SD_au8English_ta_find_mailbox_3)},     // eng 3
  { (APP_SD_au8English_ta_find_mailbox_4)   , sizeof(APP_SD_au8English_ta_find_mailbox_4)},     // eng 4
  { (NULL)                                  , 0x00},                                            // eng 5
},
{
    // GERMAN
  { (APP_SD_au8German_ta_find_mailbox_1)    , sizeof(APP_SD_au8German_ta_find_mailbox_1)},      // ger 1
  { (APP_SD_au8German_ta_find_mailbox_2)    , sizeof(APP_SD_au8German_ta_find_mailbox_2)},      // ger 2
  { (APP_SD_au8German_ta_find_mailbox_3)    , sizeof(APP_SD_au8German_ta_find_mailbox_3)},      // ger 3
  { (APP_SD_au8German_ta_find_mailbox_4)    , sizeof(APP_SD_au8German_ta_find_mailbox_4)},      // ger 4
  { (NULL)                                  , 0x00},                                            // ger 5
},
{
    // CZECH
  { (APP_SD_au8Czech_ta_find_mailbox_1)     , sizeof(APP_SD_au8Czech_ta_find_mailbox_1)},       // czech 1
  { (APP_SD_au8Czech_ta_find_mailbox_2)     , sizeof(APP_SD_au8Czech_ta_find_mailbox_2)},       // czech 2
  { (APP_SD_au8Czech_ta_find_mailbox_3)     , sizeof(APP_SD_au8Czech_ta_find_mailbox_3)},       // czech 3
  { (APP_SD_au8Czech_ta_find_mailbox_4)     , sizeof(APP_SD_au8Czech_ta_find_mailbox_4)},       // czech 4
  { (APP_SD_au8Czech_ta_find_mailbox_5)     , sizeof(APP_SD_au8Czech_ta_find_mailbox_5)},       // czech 5
},
{
    // SPANISH
  { (APP_SD_au8Spanish_ta_find_mailbox_1)   , sizeof(APP_SD_au8Spanish_ta_find_mailbox_1)},     // span 1
  { (APP_SD_au8Spanish_ta_find_mailbox_2)   , sizeof(APP_SD_au8Spanish_ta_find_mailbox_2)},     // span 2
  { (NULL)                                  , 0x00},                                            // span 3
  { (NULL)                                  , 0x00},                                            // span 4
  { (NULL)                                  , 0x00},                                            // span 5
},
{
    // ITALIAN
  { (APP_SD_au8Italian_ta_find_mailbox_1)   , sizeof(APP_SD_au8Italian_ta_find_mailbox_1)},     // ital 1
  { (NULL)                                  , 0x00},                                            // ital 2
  { (NULL)                                  , 0x00},                                            // ital 3
  { (NULL)                                  , 0x00},                                            // ital 4
  { (NULL)                                  , 0x00},                                            // ital 5
},
{
    // FRENCH
  { (APP_SD_au8French_ta_find_mailbox_1)    , sizeof(APP_SD_au8French_ta_find_mailbox_1)},      // french 1
  { (APP_SD_au8French_ta_find_mailbox_2)    , sizeof(APP_SD_au8French_ta_find_mailbox_2)},      // french 2
  { (NULL)                                  , 0x00},                                            // french 3
  { (NULL)                                  , 0x00},                                            // french 4
  { (NULL)                                  , 0x00},                                            // french 5
},
{
    // PORTUGESE
  { (APP_SD_au8Portugese_ta_find_mailbox_1) , sizeof(APP_SD_au8Portugese_ta_find_mailbox_1)},   // port 1
  { (NULL)                                  , 0x00},                                            // port 2
  { (NULL)                                  , 0x00},                                            // port 3
  { (NULL)                                  , 0x00},                                            // port 4
  { (NULL)                                  , 0x00},                                            // port 5
},
{
    // US ENGLISH
  { (APP_SD_au8USEnglish_ta_find_mailbox_1) , sizeof(APP_SD_au8USEnglish_ta_find_mailbox_1)},   // eng 1
  { (APP_SD_au8USEnglish_ta_find_mailbox_2) , sizeof(APP_SD_au8USEnglish_ta_find_mailbox_2)},   // eng 2
  { (APP_SD_au8USEnglish_ta_find_mailbox_3) , sizeof(APP_SD_au8USEnglish_ta_find_mailbox_3)},   // eng 3
  { (APP_SD_au8USEnglish_ta_find_mailbox_4) , sizeof(APP_SD_au8USEnglish_ta_find_mailbox_4)},   // eng 4
  { (NULL)                                  , 0x00},                                            // eng 5
},
{
    // Russian
  { (APP_SD_au8Russian_ta_find_mailbox_1)   , sizeof(APP_SD_au8Russian_ta_find_mailbox_1)},     // russ 1
  { (NULL)                                  , 0x00},                                            // russ 2
  { (NULL)                                  , 0x00},                                            // russ 3
  { (NULL)                                  , 0x00},                                            // russ 4
  { (NULL)                                  , 0x00},                                            // russ 5
},
{
    // Canadian FRENCH
  { (APP_SD_au8CanadianFrench_ta_find_mailbox_1)    , sizeof(APP_SD_au8CanadianFrench_ta_find_mailbox_1)},  // french 1
  { (APP_SD_au8CanadianFrench_ta_find_mailbox_2)    , sizeof(APP_SD_au8CanadianFrench_ta_find_mailbox_2)},  // french 2
  { (NULL)                                          , 0x00},                                                // french 3
  { (NULL)                                          , 0x00},                                                // french 4
  { (NULL)                                          , 0x00},                                                // french 5
},
{
    // Dutch - same as english
  { (APP_SD_au8Dutch_ta_find_mailbox_1)     , sizeof(APP_SD_au8Dutch_ta_find_mailbox_1)},       // dutch 1
  { (APP_SD_au8Dutch_ta_find_mailbox_2)     , sizeof(APP_SD_au8Dutch_ta_find_mailbox_2)},       // dutch 2
  { (APP_SD_au8Dutch_ta_find_mailbox_3)     , sizeof(APP_SD_au8Dutch_ta_find_mailbox_3)},       // dutch 3
  { (APP_SD_au8Dutch_ta_find_mailbox_4)     , sizeof(APP_SD_au8Dutch_ta_find_mailbox_4)},       // dutch 4
  { (NULL)                                  , 0x00},                                            // dutch 5
},
{
    // SWEDISH
  { (APP_SD_au8Swedish_ta_find_mailbox_1)   , sizeof(APP_SD_au8Swedish_ta_find_mailbox_1)},     // swedish 1
  { (APP_SD_au8Swedish_ta_find_mailbox_2)   , sizeof(APP_SD_au8Swedish_ta_find_mailbox_2)},     // swedish 2
  { (APP_SD_au8Swedish_ta_find_mailbox_3)   , sizeof(APP_SD_au8Swedish_ta_find_mailbox_3)},     // swedish 3
  { (APP_SD_au8Swedish_ta_find_mailbox_4)   , sizeof(APP_SD_au8Swedish_ta_find_mailbox_4)},     // swedish 4
  { (NULL)                                  , 0x00},                                            // swedish 5
},
{
    // TURKISH
  { (APP_SD_au8Turkish_ta_find_mailbox_1)   , sizeof(APP_SD_au8Turkish_ta_find_mailbox_1)},     // turkish 1
  { (APP_SD_au8Turkish_ta_find_mailbox_2)   , sizeof(APP_SD_au8Turkish_ta_find_mailbox_2)},     // turkish 2
  { (APP_SD_au8Turkish_ta_find_mailbox_3)   , sizeof(APP_SD_au8Turkish_ta_find_mailbox_3)},     // turkish 3
  { (APP_SD_au8Turkish_ta_find_mailbox_4)   , sizeof(APP_SD_au8Turkish_ta_find_mailbox_4)},     // turkish 4
  { (NULL)                                  , 0x00},                                            // turkish 5
},
{
    // NORWEGIAN
  { (APP_SD_au8Norwegian_ta_find_mailbox_1) , sizeof(APP_SD_au8Norwegian_ta_find_mailbox_1)},   // norwegian 1
  { (APP_SD_au8Norwegian_ta_find_mailbox_2) , sizeof(APP_SD_au8Norwegian_ta_find_mailbox_2)},   // norwegian 2
  { (APP_SD_au8Norwegian_ta_find_mailbox_3) , sizeof(APP_SD_au8Norwegian_ta_find_mailbox_3)},   // norwegian 3
  { (APP_SD_au8Norwegian_ta_find_mailbox_4) , sizeof(APP_SD_au8Norwegian_ta_find_mailbox_4)},   // norwegian 4
  { (NULL)                                  , 0x00},                                            // norwegian 5
},
{
    // POLISH
  { (APP_SD_au8Polish_ta_find_mailbox_1)    , sizeof(APP_SD_au8Polish_ta_find_mailbox_1)},      // polish 1
  { (APP_SD_au8Polish_ta_find_mailbox_2)    , sizeof(APP_SD_au8Polish_ta_find_mailbox_2)},      // polish 2
  { (APP_SD_au8Polish_ta_find_mailbox_3)    , sizeof(APP_SD_au8Polish_ta_find_mailbox_3)},      // polish 3
  { (NULL)                                  , 0x00},                                            // polish 4
  { (NULL)                                  , 0x00},                                            // polish 5
},
{
    // US SPANISH
  { (APP_SD_au8USSpanish_ta_find_mailbox_1) , sizeof(APP_SD_au8USSpanish_ta_find_mailbox_1)},   // us span 1
  { (APP_SD_au8USSpanish_ta_find_mailbox_2) , sizeof(APP_SD_au8USSpanish_ta_find_mailbox_2)},   // us span 2
  { (NULL)                                  , 0x00},                                            // us span 3
  { (NULL)                                  , 0x00},                                            // us span 4
  { (NULL)                                  , 0x00}                                             // us span 5
}
};

static Uint8Type _APP_SD_phoneActivatedOnce = BT_FALSE;
static Uint8Type _APP_SD_ListRollover = FALSE;
static Uint8Type _APP_SD_u8VcrActive = BT_FALSE;
/*----------------------------------------------------------------------------*/
/* Prototypes of file local Methods                                           */
/*----------------------------------------------------------------------------*/
/**
\brief  description of the method
*/

typedef  SuccessFailType (*_APP_SD_sfHandleInitFrame_t)(AppSdCtxCtrlType *);
typedef  void (*_APP_SD_vListDataRequest_t)(Uint16Type, Uint16Type);
typedef  BooleanType (*_APP_SD_sfHandleButton_t)(AppSdCtxCtrlType *, const AppSdBtnEventType *);

static void _APP_SD_vSetStaticText(APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId, KpbCellNameType *pData);
static SuccessFailType _APP_SD_sfHandleErmStateEvent(const AppSdErmStateEventType *pErm);
static SuccessFailType _APP_SD_sfHandleErmEvent(const AppSdErmEventType *pErm);
static SuccessFailType _APP_SD_sfHandleDeviceEvent(const AppSdDeviceEventType *pDevice);
static SuccessFailType _APP_SD_sfHandleErmNotificationInquiryEnd(void);
static SuccessFailType _APP_SD_sfHandleErmNotificationServiceSupportChanged(void);
static SuccessFailType _APP_SD_sfHandleErmNotificationPairingFailed(void);
static SuccessFailType _APP_SD_sfHandleErmNotificationPairingSuccess(AT_DeviceId deviceId);
static SuccessFailType _APP_SD_sfHandleVcrEvent(const AppSdVcrEventType *pVcr);
static SuccessFailType _APP_SD_sfHandlePhoneEvent(const AppSdPhoneEventType *pPhone);
static SuccessFailType _APP_SD_sfHandlePhoneBookEvent(const AppSdPhoneBookEventType *pPhoneBook);
static SuccessFailType _APP_SD_sfHandleSmsEvent(const AppSdSmsEventType *pPhone);
static SuccessFailType _APP_SD_sfHandleButtonEvent(AppSdBtnEventType *pButton);
static SuccessFailType _APP_SD_sfHandleTimeoutEvent(const AppSdTimeoutEventType *pTimeout);
static SuccessFailType _APP_SD_sfHandleCanLangEvent(const AppSdCanLangEventType *pCan);
static SuccessFailType _APP_SD_sfHandleCanSpeedEvent(const AppSdCanSpeedEventType *pCan);
static SuccessFailType _APP_SD_sfHandleKpbEvent(const AppSdKpbEventType *pKpb);
static SuccessFailType _APP_SD_sfHandleCshdlEvent(const AppSdCshdlEventType *pCshdl);
static SuccessFailType _APP_SD_sfCtxHistoryAppend(AppSdCtxCtrlType *pCtxCtrl);
static Sint16Type      _APP_SD_s16GetHistoryIndex(APP_SD_enContextId ctxId);
static AppSdCtxCtrlType *_APP_SD_pGetHistoryContext(APP_SD_enContextId ctxId);
static void _APP_SD_vCtxHistoryReplaceIndex(AppSdCtxCtrlType *pCtxCtrl, Uint16Type pos);
static void _APP_SD_vHandlePendingFunction(void);
static void _APP_SD_vCtxHistoryReset(AppSdCtxCtrlType *pCtxCtrl);
static void _APP_SD_vCtxHistoryStepBack(void);
static void _APP_SD_vRefreshFrame(AppSdCtxCtrlType *pCtxCtrl);
static void _APP_SD_vReleasePendingContext(Uint32Type line);
static void _APP_SD_vInitIdleScreen(Uint8Type focusedElement);
static void _APP_SD_vCtxHistoryReplaceCurrent(AppSdCtxCtrlType *pCtxCtrl);
static void _APP_SD_vResetPendingProfile(void);
static void _APP_SD_vHandlePhoneStateChanged(void);
static void _APP_SD_vHandlePlayerStateChanged(void);
static void _APP_SD_vHandleHeadsetStateChanged(void);
static SuccessFailType APP_SD_sfChangeLanguage(APP_CAN_enLang newCanLang, BooleanType bSdInternalOnly);
static BooleanType _APP_SD_bIsCANLanguageAvailable(APP_CAN_enLang newCanLang);
static SuccessFailType _APP_SD_SetEEpromSavedLanguage(void);
static APP_SD_ENUM_LANGUAGES _APP_SD_eGetDiagFallbackLangAsSdLang(Uint8Type eepromDiagLang);
static Uint16Type _APP_SD_u16WriteCallerId(AT_CallerId *pDestName, const AT_CallerId *pSrcName, const Uint16Type srcLen);
static void _APP_SD_vHandleCallStateChanged(void);
static void _APP_SD_vHandleHandsFreeModeChanged(void);
static void _APP_SD_vActivateFrame(BooleanType activate, Uint32Type line);
//static BooleanType _APP_SD_bIsKl15On();
static void _APP_SD_vPrintCtxStates();
//static BooleanType _APP_SD_bPausePlayerTemporarilyNeeded();

static void _APP_SD_sfCtxHistoryScreenHandling_VisibleOff(void);
static void _APP_SD_sfCtxHistoryScreenHandling_VisibleON(void);


static BooleanType _APP_SD_bPhoneContextActive();
static void _APP_SD_vReleasePhoneContext();
static void _APP_SD_vReleasePhoneContextWithStepBack();

static void _APP_SD_vHandlePlayerConnected(AT_DeviceId deviceId);
static void _APP_SD_vHandlePlayerDisconnected(AT_DeviceId deviceId);

BooleanType _APP_SD_bRemoteControlAvailable(void);
BooleanType _APP_SD_bIsA2dpAlreadyForUserProfileStarted(void);
BooleanType _APP_SD_bCurrentFrameStaysActiveWhenNotInPhoneContext(void);

/* InitFrame */
static void _APP_SD_vInitFrame(AppSdCtxCtrlType *pCtxCtrl, APP_SD_enHistoryAction action);
static void _APP_SD_vInitFrameS001(Uint16Type connAttempt);
static void _APP_SD_vInitFrameS002(Uint8Type focusedElement);
//static void _APP_SD_vInitFrameS007(AT_DeviceId deviceId);
static void _APP_SD_vInitFrameS008(void);
static void _APP_SD_vInitFrameS010(void);
static void _APP_SD_vInitFrameS_18(void);
static void _APP_SD_vInitFrameSC20(ATCallConfTypeEnum confInProgress, ATCallIndexEnum plccIdx);         // RT #3554
static void _APP_SD_vInitFrameS101(void);
static void _APP_SD_vInitFrameS102(void);
static void _APP_SD_vInitFrameS102_last(void);            //12.07.2009
static void _APP_SD_vInitFrameS103(void);
static void _APP_SD_vInitFrameS104(Uint16Type pbSize);
static void _APP_SD_vInitFrameS105(Uint16Type pbIndex);
//static void _APP_SD_vInitFrameS111(Uint16Type pbIndex, Uint16Type pnIndex);
static void _APP_SD_vInitFrameS114(Uint16Type pbIndex);
static void _APP_SD_vInitFrameS115(Uint16Type pbIndex);
static void _APP_SD_vInitFrameS116(Uint16Type pbIndex);
static void _APP_SD_vInitFrameS117(Uint16Type pbIndex);
static void _APP_SD_vInitFrameS201(void);
static void _APP_SD_vInitFrameS211(APP_PHONEBOOK_enSelectedPbType pbType, Uint16Type pbSize);
static void _APP_SD_vInitFrameS212(APP_PHONEBOOK_enSelectedPbType pbType, Uint16Type pbIndex);
static void _APP_SD_vInitFrameS213(Uint16Type smsIndex);
static void _APP_SD_vInitFrameS301(void);
static void _APP_SD_vInitFrameS305(void);
static void _APP_SD_vInitFrameS306(void);
static void _APP_SD_vInitFrameS402(void);
static void _APP_SD_vInitFrameS404(Uint16Type numSms);
static void _APP_SD_vInitFrameS405(Uint16Type smsIndex);
static void _APP_SD_vInitFrameS406(Uint16Type smsIndex);
static void _APP_SD_vInitFrameS407(void);
static void _APP_SD_vInitFrameS408(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType);
static void _APP_SD_vInitFrameS408_SSP(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType);
static void _APP_SD_vInitFrameS408_USERLIST(void);
static void _APP_SD_vInitFrameS408_ABR(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType);
static void _APP_SD_vInitFrameS408_DEL(void);
static void _APP_SD_vInitFrameS408_PLAYER(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType);
static void _APP_SD_vInitFrameS408_PRECALL(void);
static void _APP_SD_vInitFrameS409(Uint16Type smsIndex);
static void _APP_SD_vInitFrameS410(void);
static void _APP_SD_vInitFrameS413(Uint16Type smsIndex);
static void _APP_SD_vInitFrameS425(void);
static void _APP_SD_vInitFrameS428(void);
static void _APP_SD_vInitFrameS501(void);
static void _APP_SD_vInitFrameS502(Uint8Type focusedElement);
static void _APP_SD_vInitFrameS511(void);
static void _APP_SD_vInitFrameS512(Uint8Type numDevs, AT_DeviceId deviceId);
static void _APP_SD_vInitFrameS513(AT_DeviceId deviceId);
static void _APP_SD_vInitFrameS514(AT_DeviceId deviceId, BooleanType bIsActive, AT_BTDeviceName btName, Uint16Type btName_len);
static void _APP_SD_vInitFrameS515(Uint8Type numDevs, APP_DEVICE_DeviceType deviceType);
static void _APP_SD_vInitFrameS517(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType, BooleanType connect );
static void _APP_SD_vInitFrameS517_PASSIVE();
static void _APP_SD_vInitFrameS518();
static void _APP_SD_vInitFrameS51D(Uint8Type deviceId, APP_DEVICE_DeviceType deviceType );
static void _APP_SD_vInitFrameS51D_ACCEPT(Uint8Type deviceId, ATPairingDeviceType remoteDeviceType);
static void _APP_SD_vInitFrameS520(void);
static void _APP_SD_vInitFrameS521(void);
static void _APP_SD_vInitFrameS522(APP_SD_enMdiMuteReason muteReason, AT_DeviceId devId, APP_DEVICE_DeviceType devType, BooleanType bConnect);
static void _APP_SD_vInitFrameS52C(Uint8Type inqId, ATPairingDeviceType pairingDeviceType, APP_DEVICE_DeviceType appDeviceType );
static void _APP_SD_vInitFrameS52D(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType );
//static void _APP_SD_vInitFrameS532(void);
static void _APP_SD_vInitFrameS533(void);
static void _APP_SD_vInitFrameS534(AT_DeviceId deviceId);
//static void _APP_SD_vInitFrameS535(AT_DeviceId deviceId);
static void _APP_SD_vInitFrameS536(AT_DeviceId deviceId);
static void _APP_SD_vInitFrameS539(void);
static void _APP_SD_vInitFrameS541(Uint8Type numDevs);
static void _APP_SD_vInitFrameS541_2(Uint8Type numDevs);
static void _APP_SD_vInitFrameS542(AT_DeviceId deviceId, BooleanType bIsActive);
static void _APP_SD_vInitFrameS543(AT_DeviceId deviceId);
static void _APP_SD_vInitFrameS553(void);
static void _APP_SD_vInitFrameS554(void);
static void _APP_SD_vInitFrameS555(AT_DeviceId deviceId);
static void _APP_SD_vInitFrameS556(void);
static void _APP_SD_vInitFrameS562(void);
static void _APP_SD_vInitFrameS563(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType);
static void _APP_SD_vInitFrameS565(APP_DEVICE_DeviceType deviceType);
static void _APP_SD_vInitFrameS566(void);
static void _APP_SD_vInitFrameS567(Uint8Type numDevs);
static void _APP_SD_vInitFrameS5B2(Uint8Type numDevs);
static void _APP_SD_vInitFrameS568(void);
static void _APP_SD_vInitFrameS571(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType);
static void _APP_SD_vInitFrameS572(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType, BooleanType isInquiryId);
static void _APP_SD_vInitFrameS573(AT_DeviceId deviceId);
static void _APP_SD_vInitFrameS574(AT_DeviceId deviceId);
static void _APP_SD_vInitFrameS575(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType);
static void _APP_SD_vInitFrameS576(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType);
//static void _APP_SD_vInitFrameS577(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType);
static void _APP_SD_vInitFrameS578(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType, AT_BTDeviceName btName, Uint16Type btName_len);
static void _APP_SD_vInitFrameS579(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType);
//static void _APP_SD_vInitFrameS580(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType);
static void _APP_SD_vInitFrameS581(void);
static void _APP_SD_vInitFrameS582(void);
static void _APP_SD_vInitFrameS597(AT_DeviceId deviceId);
static void _APP_SD_vInitFrameS599(void);
static void _APP_SD_vInitFrameS601(void);
static void _APP_SD_vInitFrameS602(void);
static void _APP_SD_vInitFrameS641(void);
static void _APP_SD_vInitFrameS642(Uint16Type numRingtones);
static void _APP_SD_vInitFrameS661(void);
static void _APP_SD_vInitFrameS663(void);
static void _APP_SD_vInitFrameS663_PB(void);
static void _APP_SD_vInitFrameS664(void);
static void _APP_SD_vInitFrameS669(void);
static void _APP_SD_vInitFrameS801_CallList(APP_PHONEBOOK_enSelectedPbType pbType, Uint16Type pbIndex);
static void _APP_SD_vInitFrameS801_PB(Uint16Type pbIndex, Uint16Type pnIndex);
static void _APP_SD_vInitFrameS801_PN(const Uint8Type *pPhoneNumber, Uint8Type phoneNumberLen, BooleanType dial);
static void _APP_SD_vInitFrameS802(APP_SD_S802_ErrorType error);
static void _APP_SD_vInitFrameS803(ATCallIndexEnum plccIndex);
static void _APP_SD_vInitFrameS804(void);
static void _APP_SD_vInitFrameS806(void);
static void _APP_SD_vInitFrameS807(void);
static void _APP_SD_vInitFrameS811(ATCallIndexEnum plccIndex);
static void _APP_SD_vInitFrameS812(ATCallIndexEnum activePlccIdx, ATCallIndexEnum heldPlccIdx);
// FrameS813 wird von 812 abgedeckt
static void _APP_SD_vInitFrameS814(void);
static void _APP_SD_vInitFrameS815(void);
static void _APP_SD_vInitFrameS901(ATCallIndexEnum plccIndex);
static void _APP_SD_vInitFrameS902(ATCallIndexEnum activePlccIdx, ATCallIndexEnum waitingPlccIdx);
static void _APP_SD_vInitFrameS903(void);
static void _APP_SD_vInitFrameS904(void);
static void _APP_SD_vInitFrameS913(void);
static void _APP_SD_vInitFrameS914(AT_DeviceId deviceId);
static void _APP_SD_vInitFrameS916(void);
static void _APP_SD_vInitFrameS917(void);
static void _APP_SD_vInitFrameS923(void);
static void _APP_SD_vInitFrameS924(void);
static void _APP_SD_vInitFrameS925(void);
static void _APP_SD_vInitFrameS927(void);
static void _APP_SD_vInitFrameS928(void);
static void _APP_SD_vInitFrameS929(ATPhoneNumberType number, Uint16Type number_len);
static void _APP_SD_vInitFrameS930(void);
static void _APP_SD_vInitFrameS933(void);
static void _APP_SD_vInitFrameS934(AT_DeviceId deviceId);
static void _APP_SD_vInitFrameS935(void);
static void _APP_SD_vInitFrameS941(ATCallIndexEnum plccIndex);
static void _APP_SD_vInitFrameS942(ATCallIndexEnum plccIndex);
static void _APP_SD_vInitFrameS945_PN(const Uint8Type *pPhoneNumber, Uint8Type phoneNumberLen, BooleanType dial);
static void _APP_SD_vInitFrameSC01(const AppSdResultContactAmbType *pContactAmb);
static void _APP_SD_vInitFrameSC03(Uint8Type focusedElement);
static void _APP_SD_vInitFrameSC04(void);
static void _APP_SD_vInitFrameSC07(void);
static void _APP_SD_vInitFrameSC12(AT_DeviceId deviceId);
static void _APP_SD_vInitFrameSC12_2(AT_DeviceId deviceId, Uint8Type counter);
static void _APP_SD_vInitFrameSC13(void);
static void _APP_SD_vInitFrameSC14(Uint16Type smsIndex);
static void _APP_SD_vInitFrameSC16(void);
//static void _APP_SD_vInitFrameSC17(AT_DeviceId deviceId);
static void _APP_SD_vInitFrameSC22(void);
static void _APP_SD_vInitFrameSC23(void);
//static void _APP_SD_vInitFrameSC24(ATCallIndexEnum activePlccIdx, ATCallIndexEnum outgoingPlccIdx);
static void _APP_SD_vInitFrameSA01(void);
static void _APP_SD_vInitFrameSA02(void);
static void _APP_SD_vInitFrameSA03(void);
static void _APP_SD_vInitFrameSB34(void);

/* HandleInitFrame */
static SuccessFailType _APP_SD_sfHandleInitFrame(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS001(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS_18(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameSC20(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS101(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS102(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS105(AppSdCtxCtrlType *pCtxCtrl);
//static SuccessFailType _APP_SD_sfHandleInitFrameS111(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS115(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS117(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS211(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS212(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS213(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS305(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS306(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS405(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS406(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS407(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS408(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS513(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS514(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS517(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS51D(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS520(AppSdCtxCtrlType *pCtxCtrl);
//static SuccessFailType _APP_SD_sfHandleInitFrameS522(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS52C(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS534(AppSdCtxCtrlType *pCtxCtrl);
//static SuccessFailType _APP_SD_sfHandleInitFrameS535(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS536(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS542(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS543(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS554(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS555(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS556(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS563(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS571(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS573(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS574(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS575(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS576(AppSdCtxCtrlType *pCtxCtrl);
//static SuccessFailType _APP_SD_sfHandleInitFrameS577(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS578(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS579(AppSdCtxCtrlType *pCtxCtrl);
//static SuccessFailType _APP_SD_sfHandleInitFrameS580(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS581(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS597(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS601(AppSdCtxCtrlType *pCtxCtrl);
//static SuccessFailType _APP_SD_sfHandleInitFrameS602(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS642(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS669(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS801(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS802(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS803(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS804(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS811(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS812(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS901(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS902(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS903(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS914(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS929(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS933(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS934(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS941(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS942(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameS945(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameSC12(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameSC12_2(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameSC13(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameSC16(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandleInitFrameSB34(AppSdCtxCtrlType *pCtxCtrl);

/* HandleButton */
static BooleanType _APP_SD_bHandleButtonS001(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS002(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
//static BooleanType _APP_SD_bHandleButtonS007(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS008(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS_18(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonSC20(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS101(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS102(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS103(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS104(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS105(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
//static BooleanType _APP_SD_bHandleButtonS111(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS114(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS115(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS116(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS117(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS201(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS211(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS212(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS213(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS301(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS305(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS306(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS402(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS404(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS405(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS406(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS407(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS409(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS410(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS413(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS425(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS428(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS501(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS502(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS511(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS512(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS513(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS514(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS515(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS518(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS51D(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS51D_ACCEPT(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS520(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
//static BooleanType _APP_SD_bHandleButtonS521(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS52C(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
//static BooleanType _APP_SD_bHandleButtonS532(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS533(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
//static BooleanType _APP_SD_bHandleButtonS535(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS536(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS541(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS541_2(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS542(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS543(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS553(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS554(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS555(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS556(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS562(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS563(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS565(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS566(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS567(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS5B2(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS568(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS571(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS572(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS573(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS574(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS575(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS576(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
//static BooleanType _APP_SD_bHandleButtonS577(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS578(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS579(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
//static BooleanType _APP_SD_bHandleButtonS580(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS581(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS582(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS599(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS601(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS602(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS641(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS642(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS661(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS663(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS664(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS669(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS801(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS802(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS803(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS804(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS806(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS807(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS811(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS812(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS814(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS815(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS901(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS902(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS903(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS904(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS913(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS914(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS917(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS923(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS925(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS927(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS928(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS930(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS933(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS935(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS941(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS942(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonS945(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonSC01(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonSC03(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonSC04(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonSC07(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonSC12(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonSC13(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonSC16(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
//static BooleanType _APP_SD_bHandleButtonSC17(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonSC22(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonSC23(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonSC24(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);
static BooleanType _APP_SD_bHandleButtonSB34(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton);

/* HandlePendingButton */
static SuccessFailType _APP_SD_sfHandlePendingButtonS104(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS306(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS408_PRECALL(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS413(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS512(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS513(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS51D(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS51D_ACCEPT(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS520(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS52C(AppSdCtxCtrlType *pCtxCtrl);
//static SuccessFailType _APP_SD_sfHandlePendingButtonS535(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS536(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS542(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS555(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS556(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS563(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS572(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS575(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS576(AppSdCtxCtrlType *pCtxCtrl);
//static SuccessFailType _APP_SD_sfHandlePendingButtonS577(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS579(AppSdCtxCtrlType *pCtxCtrl);
//static SuccessFailType _APP_SD_sfHandlePendingButtonS580(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS581(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS642(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS602(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS661(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS669(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS801(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS803(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS804(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS811(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS812(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS815(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS901(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS902(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS933(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS941(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS942(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonS945(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonSC13(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonSC16(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonSC20(AppSdCtxCtrlType *pCtxCtrl);
static SuccessFailType _APP_SD_sfHandlePendingButtonSC24(AppSdCtxCtrlType *pCtxCtrl);

/* ListDataRequest */
static void _APP_SD_vListDataRequest_S001(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S002(Uint16Type firstIdx, Uint16Type number);
//static void _APP_SD_vListDataRequest_S007(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S008(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_SC20(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S101(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S102(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S104(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S105(Uint16Type firstIdx, Uint16Type number);
//static void _APP_SD_vListDataRequest_S111(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S115(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S117(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S201(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S211(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S212(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S213(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S404(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S405(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S406(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S407(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S409(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S410(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S413(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S502(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S512(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S513(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S515(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S520(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S52C(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S541(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S542(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S553(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S555(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S562(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S563(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S567(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S5B2(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S571(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S572(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S576(Uint16Type firstIdx, Uint16Type number);
//static void _APP_SD_vListDataRequest_S577(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S579(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S581(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S601(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S602(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S641(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S642(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S661(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S669(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S801(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S802(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S803(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S811(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S812(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S815(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S901(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S902(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S903(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S904(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_S933(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_SC01(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_SC03(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_SC12(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_SC13(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_SC16(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_SC24(Uint16Type firstIdx, Uint16Type number);
static void _APP_SD_vListDataRequest_SB34(Uint16Type firstIdx, Uint16Type number);

static BooleanType _APP_SD_bSSPSuccessFail(Uint32Type resultBitfield, Uint32Type statusBitfield); /*RT13181: 4 digit pin shown instead of SSP*/
static APP_COMMON_enResponseCode _APP_SD_bSSPInitiatePairingAfterInquiry(AT_DeviceId deviceId, void (*cb)(APP_COMMON_enResponseCode));

static const _APP_SD_sfHandleInitFrame_t _APP_SD_sfHandleInitFrameTable[] =
{
/* APP_SD_CONTEXT_INVALID */        NULL,
/* APP_SD_CONTEXT_S001,   */        _APP_SD_sfHandleInitFrameS001,
/* APP_SD_CONTEXT_S002,   */        NULL,
///* APP_SD_CONTEXT_S007,   */        NULL,
/* APP_SD_CONTEXT_S008,   */        NULL,
/* APP_SD_CONTEXT_S009,   */        NULL,
/* APP_SD_CONTEXT_S010,   */        NULL,
/* APP_SD_CONTEXT_S012,   */        NULL,
/* APP_SD_CONTEXT_S018,   */        _APP_SD_sfHandleInitFrameS_18,
/* APP_SD_CONTEXT_S101,   */        _APP_SD_sfHandleInitFrameS101,
/* APP_SD_CONTEXT_S102,   */        _APP_SD_sfHandleInitFrameS102,
/* APP_SD_CONTEXT_S103,   */        NULL,
/* APP_SD_CONTEXT_S104,   */        NULL,
/* APP_SD_CONTEXT_S105,   */        _APP_SD_sfHandleInitFrameS105,
///* APP_SD_CONTEXT_S111,   */        _APP_SD_sfHandleInitFrameS111,
/* APP_SD_CONTEXT_S114,   */        NULL,
/* APP_SD_CONTEXT_S115,   */        _APP_SD_sfHandleInitFrameS115,
/* APP_SD_CONTEXT_S116,   */        NULL,
/* APP_SD_CONTEXT_S117,   */        _APP_SD_sfHandleInitFrameS117,
/* APP_SD_CONTEXT_S201,   */        NULL,
/* APP_SD_CONTEXT_S202,   */        NULL,
/* APP_SD_CONTEXT_S203,   */        NULL,
/* APP_SD_CONTEXT_S211,   */        _APP_SD_sfHandleInitFrameS211,
/* APP_SD_CONTEXT_S212,   */        _APP_SD_sfHandleInitFrameS212,
/* APP_SD_CONTEXT_S213,   */        _APP_SD_sfHandleInitFrameS213,
/* APP_SD_CONTEXT_S301,   */        NULL,
/* APP_SD_CONTEXT_S305,   */        _APP_SD_sfHandleInitFrameS305,
/* APP_SD_CONTEXT_S306,   */        _APP_SD_sfHandleInitFrameS306,
/* APP_SD_CONTEXT_S402,   */        NULL,
/* APP_SD_CONTEXT_S404,   */        NULL,
/* APP_SD_CONTEXT_S405,   */        _APP_SD_sfHandleInitFrameS405,
/* APP_SD_CONTEXT_S406,   */        _APP_SD_sfHandleInitFrameS406,
/* APP_SD_CONTEXT_S407,   */        _APP_SD_sfHandleInitFrameS407,
/* APP_SD_CONTEXT_S408,   */        _APP_SD_sfHandleInitFrameS408,
/* APP_SD_CONTEXT_S408_USERLIST*/        NULL,
/* APP_SD_CONTEXT_S408_ABR*/        NULL,
/* APP_SD_CONTEXT_S408_DEL*/        NULL,
/* APP_SD_CONTEXT_S408_PLAYER*/     NULL,
/* APP_SD_CONTEXT_S408_PRECALL*/    NULL,
/* APP_SD_CONTEXT_S409,   */        NULL,
/* APP_SD_CONTEXT_S410,   */        NULL,
/* APP_SD_CONTEXT_S413,   */        NULL,
/* APP_SD_CONTEXT_S425,   */        NULL,
/* APP_SD_CONTEXT_S428,   */        NULL,
/* APP_SD_CONTEXT_S501,   */        NULL,
/* APP_SD_CONTEXT_S502,   */        NULL,
/* APP_SD_CONTEXT_S511,   */        NULL,
/* APP_SD_CONTEXT_S512,   */        NULL,
/* APP_SD_CONTEXT_S513,   */        _APP_SD_sfHandleInitFrameS513,
/* APP_SD_CONTEXT_S514,   */        _APP_SD_sfHandleInitFrameS514,
/* APP_SD_CONTEXT_S515,   */        NULL,
/* APP_SD_CONTEXT_S517,   */        _APP_SD_sfHandleInitFrameS517,
/* APP_SD_CONTEXT_S517_PASSIVE, */  NULL,
/* APP_SD_CONTEXT_S518,   */        NULL,
/* APP_SD_CONTEXT_S51D,   */        _APP_SD_sfHandleInitFrameS51D,
/* APP_SD_CONTEXT_S51D_ACCEPT,   */ _APP_SD_sfHandleInitFrameS51D,
/* APP_SD_CONTEXT_S520,   */        _APP_SD_sfHandleInitFrameS520,
/* APP_SD_CONTEXT_S521,   */        NULL,
/* APP_SD_CONTEXT_S522,   */        NULL, //_APP_SD_sfHandleInitFrameS522,
/* APP_SD_CONTEXT_S52C,   */        _APP_SD_sfHandleInitFrameS52C,
/* APP_SD_CONTEXT_S52D,   */        NULL,
///* APP_SD_CONTEXT_S532,   */        NULL,
/* APP_SD_CONTEXT_S533,   */        NULL,
/* APP_SD_CONTEXT_S533_2  */        NULL,
/* APP_SD_CONTEXT_S534,   */        _APP_SD_sfHandleInitFrameS534,
/* APP_SD_CONTEXT_S534_2, */        NULL,
///* APP_SD_CONTEXT_S535,   */        _APP_SD_sfHandleInitFrameS535,
/* APP_SD_CONTEXT_S536,   */        _APP_SD_sfHandleInitFrameS536,
/* APP_SD_CONTEXT_S539,   */        NULL,
/* APP_SD_CONTEXT_S541,   */        NULL,
/* APP_SD_CONTEXT_S541_2  */        NULL,
/* APP_SD_CONTEXT_S542,   */        _APP_SD_sfHandleInitFrameS542,
/* APP_SD_CONTEXT_S543,   */        _APP_SD_sfHandleInitFrameS543,
/* APP_SD_CONTEXT_S553,   */        NULL,
/* APP_SD_CONTEXT_S554,   */        _APP_SD_sfHandleInitFrameS554,
/* APP_SD_CONTEXT_S555,   */        _APP_SD_sfHandleInitFrameS555,
/* APP_SD_CONTEXT_S556,   */        _APP_SD_sfHandleInitFrameS556,
/* APP_SD_CONTEXT_S562,   */        NULL,
/* APP_SD_CONTEXT_S563,   */        _APP_SD_sfHandleInitFrameS563,
/* APP_SD_CONTEXT_S565,   */        NULL,
/* APP_SD_CONTEXT_S566,   */        NULL,
/* APP_SD_CONTEXT_S567,   */        NULL,
/* APP_SD_CONTEXT_S568,   */        NULL,
/* APP_SD_CONTEXT_S571,   */        _APP_SD_sfHandleInitFrameS571,
/* APP_SD_CONTEXT_S5B2,   */        NULL,
/* APP_SD_CONTEXT_S572,   */        NULL,
/* APP_SD_CONTEXT_S573,   */        _APP_SD_sfHandleInitFrameS573,
/* APP_SD_CONTEXT_S574,   */        _APP_SD_sfHandleInitFrameS574,
/* APP_SD_CONTEXT_S575,   */        _APP_SD_sfHandleInitFrameS575,
/* APP_SD_CONTEXT_S576,   */        _APP_SD_sfHandleInitFrameS576,
/* APP_SD_CONTEXT_S577,   */        NULL,
/* APP_SD_CONTEXT_S578,   */        _APP_SD_sfHandleInitFrameS578,
/* APP_SD_CONTEXT_S579,   */        _APP_SD_sfHandleInitFrameS579,
///* APP_SD_CONTEXT_S580,   */        _APP_SD_sfHandleInitFrameS580,
/* APP_SD_CONTEXT_S581,   */        _APP_SD_sfHandleInitFrameS581,
/* APP_SD_CONTEXT_S582,   */        NULL,
/* APP_SD_CONTEXT_S597,   */        _APP_SD_sfHandleInitFrameS597,
/* APP_SD_CONTEXT_S599,   */        NULL,
/* APP_SD_CONTEXT_S601,   */        _APP_SD_sfHandleInitFrameS601,
/* APP_SD_CONTEXT_S602,   */        NULL,
/* APP_SD_CONTEXT_S641,   */        NULL,
/* APP_SD_CONTEXT_S642,   */        _APP_SD_sfHandleInitFrameS642,
/* APP_SD_CONTEXT_S661,   */        NULL,
/* APP_SD_CONTEXT_S663,   */        NULL,
/* APP_SD_CONTEXT_S663_PB,*/        NULL,
/* APP_SD_CONTEXT_S664,   */        NULL,
/* APP_SD_CONTEXT_S669,   */        _APP_SD_sfHandleInitFrameS669,
/* APP_SD_CONTEXT_S702,   */        NULL,
/* APP_SD_CONTEXT_S703,   */        NULL,
/* APP_SD_CONTEXT_S704,   */        NULL,
/* APP_SD_CONTEXT_S705,   */        NULL,
/* APP_SD_CONTEXT_S706,   */        NULL,
/* APP_SD_CONTEXT_S707,   */        NULL,
/* APP_SD_CONTEXT_S709,   */        NULL,
/* APP_SD_CONTEXT_S712,   */        NULL,
/* APP_SD_CONTEXT_S713,   */        NULL,
/* APP_SD_CONTEXT_S714,   */        NULL,
/* APP_SD_CONTEXT_S715,   */        NULL,
/* APP_SD_CONTEXT_S719,   */        NULL,
/* APP_SD_CONTEXT_S801,   */        _APP_SD_sfHandleInitFrameS801,
/* APP_SD_CONTEXT_S802,   */        _APP_SD_sfHandleInitFrameS802,
/* APP_SD_CONTEXT_S803,   */        _APP_SD_sfHandleInitFrameS803,
/* APP_SD_CONTEXT_S804,   */        _APP_SD_sfHandleInitFrameS804,
/* APP_SD_CONTEXT_S807,   */        NULL,
/* APP_SD_CONTEXT_S806,   */        NULL,
/* APP_SD_CONTEXT_S811,   */        _APP_SD_sfHandleInitFrameS811,
/* APP_SD_CONTEXT_S812,   */        _APP_SD_sfHandleInitFrameS812,
/* APP_SD_CONTEXT_S813,   */        NULL,
/* APP_SD_CONTEXT_S814,   */        NULL,
/* APP_SD_CONTEXT_S815,   */        NULL,
/* APP_SD_CONTEXT_S901,   */        _APP_SD_sfHandleInitFrameS901,
/* APP_SD_CONTEXT_S902,   */        _APP_SD_sfHandleInitFrameS902,
/* APP_SD_CONTEXT_S903,   */        _APP_SD_sfHandleInitFrameS903,
/* APP_SD_CONTEXT_S904,   */        NULL,
/* APP_SD_CONTEXT_S913,   */        NULL,
/* APP_SD_CONTEXT_S914,   */        _APP_SD_sfHandleInitFrameS914,
/* APP_SD_CONTEXT_S916,   */        NULL,
/* APP_SD_CONTEXT_S917,   */        NULL,
/* APP_SD_CONTEXT_S923,   */        NULL,
/* APP_SD_CONTEXT_S924,   */        NULL,
/* APP_SD_CONTEXT_S925,   */        NULL,
/* APP_SD_CONTEXT_S927,   */        NULL,
/* APP_SD_CONTEXT_S928,   */        NULL,
/* APP_SD_CONTEXT_S929,   */        _APP_SD_sfHandleInitFrameS929,
/* APP_SD_CONTEXT_S930,   */        NULL,
/* APP_SD_CONTEXT_S933,   */        _APP_SD_sfHandleInitFrameS933,
/* APP_SD_CONTEXT_S934,   */        _APP_SD_sfHandleInitFrameS934,
/* APP_SD_CONTEXT_S935,   */        NULL,
/* APP_SD_CONTEXT_S941,   */        _APP_SD_sfHandleInitFrameS941,
/* APP_SD_CONTEXT_S942,   */        _APP_SD_sfHandleInitFrameS942,
/* APP_SD_CONTEXT_S945,   */        _APP_SD_sfHandleInitFrameS945,
/* APP_SD_CONTEXT_SC01,   */        NULL,
/* APP_SD_CONTEXT_SC03,   */        NULL,
/* APP_SD_CONTEXT_SC04,   */        NULL,
/* APP_SD_CONTEXT_SC07,   */        NULL,
/* APP_SD_CONTEXT_SC12,   */        _APP_SD_sfHandleInitFrameSC12,
/* APP_SD_CONTEXT_SC12_2, */        _APP_SD_sfHandleInitFrameSC12_2,
/* APP_SD_CONTEXT_SC13,   */        _APP_SD_sfHandleInitFrameSC13,
/* APP_SD_CONTEXT_SC14,   */        NULL,
/* APP_SD_CONTEXT_SC16,   */        _APP_SD_sfHandleInitFrameSC16,
///* APP_SD_CONTEXT_SC17,   */        NULL,
/* APP_SD_CONTEXT_SC20,   */        _APP_SD_sfHandleInitFrameSC20,
/* APP_SD_CONTEXT_SC22,   */        NULL,
/* APP_SD_CONTEXT_SC23,   */        NULL,
/* APP_SD_CONTEXT_SC24,   */        NULL,
/* APP_SD_CONTEXT_SP18,   */        _APP_SD_sfHandleInitFrameS_18,
/* APP_SD_CONTEXT_SA01,   */        NULL,
/* APP_SD_CONTEXT_SA02,   */        NULL,
/* APP_SD_CONTEXT_SA03,   */        NULL,
/* APP_SD_CONTEXT_SB34,   */        _APP_SD_sfHandleInitFrameSB34
};


/* if this assertion fails, the jumptable matches not the number of context ids */
CCASSERT(APP_SD_CONTEXT_LAST == NUM_ELEMENTS_OF_ARRAY(_APP_SD_sfHandleInitFrameTable), _APP_SD_sfHandleInitFrameTable);


static const _APP_SD_vListDataRequest_t _APP_SD_vListDataRequestTable[] =
{
/* APP_SD_CONTEXT_INVALID */        NULL,
/* APP_SD_CONTEXT_S001,   */        _APP_SD_vListDataRequest_S001,
/* APP_SD_CONTEXT_S002,   */        _APP_SD_vListDataRequest_S002,
///* APP_SD_CONTEXT_S007,   */        _APP_SD_vListDataRequest_S007,
/* APP_SD_CONTEXT_S008,   */        _APP_SD_vListDataRequest_S008,
/* APP_SD_CONTEXT_S009,   */        NULL,
/* APP_SD_CONTEXT_S010,   */        NULL,
/* APP_SD_CONTEXT_S012,   */        NULL,
/* APP_SD_CONTEXT_S018,   */        NULL,
/* APP_SD_CONTEXT_S101,   */        _APP_SD_vListDataRequest_S101,
/* APP_SD_CONTEXT_S102,   */        _APP_SD_vListDataRequest_S102,
/* APP_SD_CONTEXT_S103,   */        NULL,
/* APP_SD_CONTEXT_S104,   */        _APP_SD_vListDataRequest_S104,
/* APP_SD_CONTEXT_S105,   */        _APP_SD_vListDataRequest_S105,
///* APP_SD_CONTEXT_S111,   */        _APP_SD_vListDataRequest_S111,
/* APP_SD_CONTEXT_S114,   */        NULL,
/* APP_SD_CONTEXT_S115,   */        _APP_SD_vListDataRequest_S115,
/* APP_SD_CONTEXT_S116,   */        NULL,
/* APP_SD_CONTEXT_S117,   */        _APP_SD_vListDataRequest_S117,
/* APP_SD_CONTEXT_S201,   */        _APP_SD_vListDataRequest_S201,
/* APP_SD_CONTEXT_S202,   */        NULL,
/* APP_SD_CONTEXT_S203,   */        NULL,
/* APP_SD_CONTEXT_S211,   */        _APP_SD_vListDataRequest_S211,
/* APP_SD_CONTEXT_S212,   */        _APP_SD_vListDataRequest_S212,
/* APP_SD_CONTEXT_S213,   */        _APP_SD_vListDataRequest_S213,
/* APP_SD_CONTEXT_S301,   */        NULL,
/* APP_SD_CONTEXT_S305,   */        NULL,
/* APP_SD_CONTEXT_S306,   */        NULL,
/* APP_SD_CONTEXT_S402,   */        NULL,
/* APP_SD_CONTEXT_S404,   */        _APP_SD_vListDataRequest_S404,
/* APP_SD_CONTEXT_S405,   */        _APP_SD_vListDataRequest_S405,
/* APP_SD_CONTEXT_S406,   */        _APP_SD_vListDataRequest_S406,
/* APP_SD_CONTEXT_S407,   */        _APP_SD_vListDataRequest_S407,
/* APP_SD_CONTEXT_S408,   */        NULL,
/* APP_SD_CONTEXT_S408_USERLIST*/        NULL,
/* APP_SD_CONTEXT_S408_ABR*/        NULL,
/* APP_SD_CONTEXT_S408_DEL*/        NULL,
/* APP_SD_CONTEXT_S408_PLAYER*/     NULL,
/* APP_SD_CONTEXT_S408_PRECALL*/    NULL,
/* APP_SD_CONTEXT_S409,   */        _APP_SD_vListDataRequest_S409,
/* APP_SD_CONTEXT_S410,   */        _APP_SD_vListDataRequest_S410,
/* APP_SD_CONTEXT_S413,   */        _APP_SD_vListDataRequest_S413,
/* APP_SD_CONTEXT_S425,   */        NULL,
/* APP_SD_CONTEXT_S428,   */        NULL,
/* APP_SD_CONTEXT_S501,   */        NULL,
/* APP_SD_CONTEXT_S502,   */        _APP_SD_vListDataRequest_S502,
/* APP_SD_CONTEXT_S511,   */        NULL,
/* APP_SD_CONTEXT_S512,   */        _APP_SD_vListDataRequest_S512,
/* APP_SD_CONTEXT_S513,   */        _APP_SD_vListDataRequest_S513,
/* APP_SD_CONTEXT_S514,   */        NULL,
/* APP_SD_CONTEXT_S515,   */        _APP_SD_vListDataRequest_S515,
/* APP_SD_CONTEXT_S517,   */        NULL,
/* APP_SD_CONTEXT_S517_PASSIVE, */  NULL,
/* APP_SD_CONTEXT_S518,   */        NULL,
/* APP_SD_CONTEXT_S51D,   */        NULL,
/* APP_SD_CONTEXT_S51D_ACCEPT,   */ NULL,
/* APP_SD_CONTEXT_S520,   */        _APP_SD_vListDataRequest_S520,
/* APP_SD_CONTEXT_S521,   */        NULL,
/* APP_SD_CONTEXT_S522,   */        NULL,
/* APP_SD_CONTEXT_S52C,   */        _APP_SD_vListDataRequest_S52C,
/* APP_SD_CONTEXT_S52D,   */        NULL,
///* APP_SD_CONTEXT_S532,   */        NULL,
/* APP_SD_CONTEXT_S533,   */        NULL,
/* APP_SD_CONTEXT_S533_2  */        NULL,
/* APP_SD_CONTEXT_S534,   */        NULL,
/* APP_SD_CONTEXT_S534_2, */        NULL,
///* APP_SD_CONTEXT_S535,   */        NULL,
/* APP_SD_CONTEXT_S536,   */        NULL,
/* APP_SD_CONTEXT_S539,   */        NULL,
/* APP_SD_CONTEXT_S541,   */        _APP_SD_vListDataRequest_S541,
/* APP_SD_CONTEXT_S541_2  */        _APP_SD_vListDataRequest_S541,
/* APP_SD_CONTEXT_S542,   */        _APP_SD_vListDataRequest_S542,
/* APP_SD_CONTEXT_S543,   */        NULL,
/* APP_SD_CONTEXT_S553,   */        _APP_SD_vListDataRequest_S553,
/* APP_SD_CONTEXT_S554,   */        NULL,
/* APP_SD_CONTEXT_S555,   */        _APP_SD_vListDataRequest_S555,
/* APP_SD_CONTEXT_S556,   */        NULL,
/* APP_SD_CONTEXT_S562,   */        _APP_SD_vListDataRequest_S562,
/* APP_SD_CONTEXT_S563,   */        _APP_SD_vListDataRequest_S563,
/* APP_SD_CONTEXT_S565,   */        NULL,
/* APP_SD_CONTEXT_S566,   */        NULL,
/* APP_SD_CONTEXT_S567,   */        _APP_SD_vListDataRequest_S567,
/* APP_SD_CONTEXT_S568,   */        NULL,
/* APP_SD_CONTEXT_S571,   */        _APP_SD_vListDataRequest_S571,
/* APP_SD_CONTEXT_S5B2,   */        _APP_SD_vListDataRequest_S5B2,
/* APP_SD_CONTEXT_S572,   */        _APP_SD_vListDataRequest_S572,
/* APP_SD_CONTEXT_S573,   */        NULL,
/* APP_SD_CONTEXT_S574,   */        NULL,
/* APP_SD_CONTEXT_S575,   */        NULL,
/* APP_SD_CONTEXT_S576,   */        _APP_SD_vListDataRequest_S576,
/* APP_SD_CONTEXT_S577,   */        NULL,
/* APP_SD_CONTEXT_S578,   */        NULL,
/* APP_SD_CONTEXT_S579,   */        _APP_SD_vListDataRequest_S579,
///* APP_SD_CONTEXT_S580,   */        NULL,
/* APP_SD_CONTEXT_S581,   */        _APP_SD_vListDataRequest_S581,
/* APP_SD_CONTEXT_S582,   */        NULL,
/* APP_SD_CONTEXT_S597,   */        NULL,
/* APP_SD_CONTEXT_S599,   */        NULL,
/* APP_SD_CONTEXT_S601,   */        _APP_SD_vListDataRequest_S601,
/* APP_SD_CONTEXT_S602,   */        _APP_SD_vListDataRequest_S602,
/* APP_SD_CONTEXT_S641,   */        _APP_SD_vListDataRequest_S641,
/* APP_SD_CONTEXT_S642,   */        _APP_SD_vListDataRequest_S642,
/* APP_SD_CONTEXT_S661,   */        _APP_SD_vListDataRequest_S661,
/* APP_SD_CONTEXT_S663,   */        NULL,
/* APP_SD_CONTEXT_S663_PB */        NULL,
/* APP_SD_CONTEXT_S664,   */        NULL,
/* APP_SD_CONTEXT_S669,   */        _APP_SD_vListDataRequest_S669,
/* APP_SD_CONTEXT_S702,   */        NULL,
/* APP_SD_CONTEXT_S703,   */        NULL,
/* APP_SD_CONTEXT_S704,   */        NULL,
/* APP_SD_CONTEXT_S705,   */        NULL,
/* APP_SD_CONTEXT_S706,   */        NULL,
/* APP_SD_CONTEXT_S707,   */        NULL,
/* APP_SD_CONTEXT_S709,   */        NULL,
/* APP_SD_CONTEXT_S712,   */        NULL,
/* APP_SD_CONTEXT_S713,   */        NULL,
/* APP_SD_CONTEXT_S714,   */        NULL,
/* APP_SD_CONTEXT_S715,   */        NULL,
/* APP_SD_CONTEXT_S719,   */        NULL,
/* APP_SD_CONTEXT_S801,   */        _APP_SD_vListDataRequest_S801,
/* APP_SD_CONTEXT_S802,   */        _APP_SD_vListDataRequest_S802,
/* APP_SD_CONTEXT_S803,   */        _APP_SD_vListDataRequest_S803,
/* APP_SD_CONTEXT_S804,   */        NULL,
/* APP_SD_CONTEXT_S807,   */        NULL,
/* APP_SD_CONTEXT_S806,   */        NULL,
/* APP_SD_CONTEXT_S811,   */        _APP_SD_vListDataRequest_S811,
/* APP_SD_CONTEXT_S812,   */        _APP_SD_vListDataRequest_S812,
/* APP_SD_CONTEXT_S813,   */        NULL,
/* APP_SD_CONTEXT_S814,   */        NULL,
/* APP_SD_CONTEXT_S815,   */        _APP_SD_vListDataRequest_S815,
/* APP_SD_CONTEXT_S901,   */        _APP_SD_vListDataRequest_S901,
/* APP_SD_CONTEXT_S902,   */        _APP_SD_vListDataRequest_S902,
/* APP_SD_CONTEXT_S903,   */        _APP_SD_vListDataRequest_S903,
/* APP_SD_CONTEXT_S904,   */        _APP_SD_vListDataRequest_S904,
/* APP_SD_CONTEXT_S913,   */        NULL,
/* APP_SD_CONTEXT_S914,   */        NULL,
/* APP_SD_CONTEXT_S916,   */        NULL,
/* APP_SD_CONTEXT_S917,   */        NULL,
/* APP_SD_CONTEXT_S923,   */        NULL,
/* APP_SD_CONTEXT_S924,   */        NULL,
/* APP_SD_CONTEXT_S925,   */        NULL,
/* APP_SD_CONTEXT_S927,   */        NULL,
/* APP_SD_CONTEXT_S928,   */        NULL,
/* APP_SD_CONTEXT_S929,   */        NULL,
/* APP_SD_CONTEXT_S930,   */        NULL,
/* APP_SD_CONTEXT_S933,   */        _APP_SD_vListDataRequest_S933,
/* APP_SD_CONTEXT_S934,   */        NULL,
/* APP_SD_CONTEXT_S935,   */        NULL,
/* APP_SD_CONTEXT_S941,   */        NULL,
/* APP_SD_CONTEXT_S942,   */        NULL,
/* APP_SD_CONTEXT_S945,   */        NULL,
/* APP_SD_CONTEXT_SC01,   */        _APP_SD_vListDataRequest_SC01,
/* APP_SD_CONTEXT_SC03,   */        _APP_SD_vListDataRequest_SC03,
/* APP_SD_CONTEXT_SC04,   */        NULL,
/* APP_SD_CONTEXT_SC07,   */        NULL,
/* APP_SD_CONTEXT_SC12,   */        _APP_SD_vListDataRequest_SC12,
/* APP_SD_CONTEXT_SC12_2  */        _APP_SD_vListDataRequest_SC12,
/* APP_SD_CONTEXT_SC13,   */        _APP_SD_vListDataRequest_SC13,
/* APP_SD_CONTEXT_SC14,   */        NULL,
/* APP_SD_CONTEXT_SC16,   */        _APP_SD_vListDataRequest_SC16,
///* APP_SD_CONTEXT_SC17,   */        NULL,
/* APP_SD_CONTEXT_SC20,   */        _APP_SD_vListDataRequest_SC20,
/* APP_SD_CONTEXT_SC22,   */        NULL,
/* APP_SD_CONTEXT_SC23,   */        NULL,
/* APP_SD_CONTEXT_SC24,   */        _APP_SD_vListDataRequest_SC24,
/* APP_SD_CONTEXT_SP18,   */        NULL,
/* APP_SD_CONTEXT_SA01,   */        NULL,
/* APP_SD_CONTEXT_SA02,   */        NULL,
/* APP_SD_CONTEXT_SA03,   */        NULL,
/* APP_SD_CONTEXT_SB34,   */        _APP_SD_vListDataRequest_SB34
};

/* if this assertion fails, the jumptable matches not the number of context ids */
CCASSERT(APP_SD_CONTEXT_LAST == NUM_ELEMENTS_OF_ARRAY(_APP_SD_vListDataRequestTable), _APP_SD_vListDataRequestTable);


static const _APP_SD_sfHandleButton_t _APP_SD_sfHandleButtonTable[] =
{
/* APP_SD_CONTEXT_INVALID */        NULL,
/* APP_SD_CONTEXT_S001,   */        _APP_SD_bHandleButtonS001,
/* APP_SD_CONTEXT_S002,   */        _APP_SD_bHandleButtonS002,
///* APP_SD_CONTEXT_S007,   */        _APP_SD_bHandleButtonS007,
/* APP_SD_CONTEXT_S008,   */        _APP_SD_bHandleButtonS008,
/* APP_SD_CONTEXT_S009,   */        NULL,
/* APP_SD_CONTEXT_S010,   */        NULL,
/* APP_SD_CONTEXT_S012,   */        NULL,
/* APP_SD_CONTEXT_S018,   */        _APP_SD_bHandleButtonS_18,
/* APP_SD_CONTEXT_S101,   */        _APP_SD_bHandleButtonS101,
/* APP_SD_CONTEXT_S102,   */        _APP_SD_bHandleButtonS102,
/* APP_SD_CONTEXT_S103,   */        _APP_SD_bHandleButtonS103,
/* APP_SD_CONTEXT_S104,   */        _APP_SD_bHandleButtonS104,
/* APP_SD_CONTEXT_S105,   */        _APP_SD_bHandleButtonS105,
///* APP_SD_CONTEXT_S111,   */        _APP_SD_bHandleButtonS111,
/* APP_SD_CONTEXT_S114,   */        _APP_SD_bHandleButtonS114,
/* APP_SD_CONTEXT_S115,   */        _APP_SD_bHandleButtonS115,
/* APP_SD_CONTEXT_S116,   */        _APP_SD_bHandleButtonS116,
/* APP_SD_CONTEXT_S117,   */        _APP_SD_bHandleButtonS117,
/* APP_SD_CONTEXT_S201,   */        _APP_SD_bHandleButtonS201,
/* APP_SD_CONTEXT_S202,   */        NULL,
/* APP_SD_CONTEXT_S203,   */        NULL,
/* APP_SD_CONTEXT_S211,   */        _APP_SD_bHandleButtonS211,
/* APP_SD_CONTEXT_S212,   */        _APP_SD_bHandleButtonS212,
/* APP_SD_CONTEXT_S213,   */        _APP_SD_bHandleButtonS213,
/* APP_SD_CONTEXT_S301,   */        _APP_SD_bHandleButtonS301,
/* APP_SD_CONTEXT_S305,   */        _APP_SD_bHandleButtonS305,
/* APP_SD_CONTEXT_S306,   */        _APP_SD_bHandleButtonS306,
/* APP_SD_CONTEXT_S402,   */        _APP_SD_bHandleButtonS402,
/* APP_SD_CONTEXT_S404,   */        _APP_SD_bHandleButtonS404,
/* APP_SD_CONTEXT_S405,   */        _APP_SD_bHandleButtonS405,
/* APP_SD_CONTEXT_S406,   */        _APP_SD_bHandleButtonS406,
/* APP_SD_CONTEXT_S407,   */        _APP_SD_bHandleButtonS407,
/* APP_SD_CONTEXT_S408,   */        NULL,
/* APP_SD_CONTEXT_S408_USERLIST*/        NULL,
/* APP_SD_CONTEXT_S408_ABR*/        NULL,
/* APP_SD_CONTEXT_S408_DEL*/        NULL,
/* APP_SD_CONTEXT_S408_PLAYER*/     NULL,
/* APP_SD_CONTEXT_S408_PRECALL*/    NULL,
/* APP_SD_CONTEXT_S409,   */        _APP_SD_bHandleButtonS409,
/* APP_SD_CONTEXT_S410,   */        _APP_SD_bHandleButtonS410,
/* APP_SD_CONTEXT_S413,   */        _APP_SD_bHandleButtonS413,
/* APP_SD_CONTEXT_S425,   */        _APP_SD_bHandleButtonS425,
/* APP_SD_CONTEXT_S428,   */        _APP_SD_bHandleButtonS428,
/* APP_SD_CONTEXT_S501,   */        _APP_SD_bHandleButtonS501,
/* APP_SD_CONTEXT_S502,   */        _APP_SD_bHandleButtonS502,
/* APP_SD_CONTEXT_S511,   */        _APP_SD_bHandleButtonS511,
/* APP_SD_CONTEXT_S512,   */        _APP_SD_bHandleButtonS512,
/* APP_SD_CONTEXT_S513,   */        _APP_SD_bHandleButtonS513,
/* APP_SD_CONTEXT_S514,   */        _APP_SD_bHandleButtonS514,
/* APP_SD_CONTEXT_S515,   */        _APP_SD_bHandleButtonS515,
/* APP_SD_CONTEXT_S517,   */        NULL,
/* APP_SD_CONTEXT_S517_PASSIVE, */  NULL,
/* APP_SD_CONTEXT_S518,   */        _APP_SD_bHandleButtonS518,
/* APP_SD_CONTEXT_S51D,   */        _APP_SD_bHandleButtonS51D,
/* APP_SD_CONTEXT_S51D_ACCEPT,   */ _APP_SD_bHandleButtonS51D_ACCEPT,
/* APP_SD_CONTEXT_S520,   */        _APP_SD_bHandleButtonS520,
/* APP_SD_CONTEXT_S521,   */        NULL,
/* APP_SD_CONTEXT_S522,   */        NULL,
/* APP_SD_CONTEXT_S52C,   */        _APP_SD_bHandleButtonS52C,
/* APP_SD_CONTEXT_S52D,   */        NULL,
///* APP_SD_CONTEXT_S532,   */        _APP_SD_bHandleButtonS532,
/* APP_SD_CONTEXT_S533,   */        _APP_SD_bHandleButtonS533,
/* APP_SD_CONTEXT_S533_2, */        _APP_SD_bHandleButtonS533,
/* APP_SD_CONTEXT_S534,   */        NULL,
/* APP_SD_CONTEXT_S534_2, */        NULL,
///* APP_SD_CONTEXT_S535,   */        _APP_SD_bHandleButtonS535,
/* APP_SD_CONTEXT_S536,   */        _APP_SD_bHandleButtonS536,
/* APP_SD_CONTEXT_S539,   */        NULL,
/* APP_SD_CONTEXT_S541,   */        _APP_SD_bHandleButtonS541,
/* APP_SD_CONTEXT_S541_2  */        _APP_SD_bHandleButtonS541_2,
/* APP_SD_CONTEXT_S542,   */        _APP_SD_bHandleButtonS542,
/* APP_SD_CONTEXT_S543,   */        _APP_SD_bHandleButtonS543,
/* APP_SD_CONTEXT_S553,   */        _APP_SD_bHandleButtonS553,
/* APP_SD_CONTEXT_S554,   */        _APP_SD_bHandleButtonS554,
/* APP_SD_CONTEXT_S555,   */        _APP_SD_bHandleButtonS555,
/* APP_SD_CONTEXT_S556,   */        _APP_SD_bHandleButtonS556,
/* APP_SD_CONTEXT_S562,   */        _APP_SD_bHandleButtonS562,
/* APP_SD_CONTEXT_S563,   */        _APP_SD_bHandleButtonS563,
/* APP_SD_CONTEXT_S565,   */        _APP_SD_bHandleButtonS565,
/* APP_SD_CONTEXT_S566,   */        _APP_SD_bHandleButtonS566,
/* APP_SD_CONTEXT_S567,   */        _APP_SD_bHandleButtonS567,
/* APP_SD_CONTEXT_S568,   */        _APP_SD_bHandleButtonS568,
/* APP_SD_CONTEXT_S571,   */        _APP_SD_bHandleButtonS571,
/* APP_SD_CONTEXT_S5B2,   */        _APP_SD_bHandleButtonS5B2,
/* APP_SD_CONTEXT_S572,   */        _APP_SD_bHandleButtonS572,
/* APP_SD_CONTEXT_S573,   */        _APP_SD_bHandleButtonS573,
/* APP_SD_CONTEXT_S574,   */        _APP_SD_bHandleButtonS574,
/* APP_SD_CONTEXT_S575,   */        _APP_SD_bHandleButtonS575,
/* APP_SD_CONTEXT_S576,   */        _APP_SD_bHandleButtonS576,
/* APP_SD_CONTEXT_S577,   */        NULL,
/* APP_SD_CONTEXT_S578,   */        _APP_SD_bHandleButtonS578,
/* APP_SD_CONTEXT_S579,   */        _APP_SD_bHandleButtonS579,
///* APP_SD_CONTEXT_S580,   */        _APP_SD_bHandleButtonS580,
/* APP_SD_CONTEXT_S581,   */        _APP_SD_bHandleButtonS581,
/* APP_SD_CONTEXT_S582,   */        _APP_SD_bHandleButtonS582,
/* APP_SD_CONTEXT_S597,   */        NULL,
/* APP_SD_CONTEXT_S599,   */        _APP_SD_bHandleButtonS599,
/* APP_SD_CONTEXT_S601,   */        _APP_SD_bHandleButtonS601,
/* APP_SD_CONTEXT_S602,   */        _APP_SD_bHandleButtonS602,
/* APP_SD_CONTEXT_S641,   */        _APP_SD_bHandleButtonS641,
/* APP_SD_CONTEXT_S642,   */        _APP_SD_bHandleButtonS642,
/* APP_SD_CONTEXT_S661,   */        _APP_SD_bHandleButtonS661,
/* APP_SD_CONTEXT_S663,   */        _APP_SD_bHandleButtonS663,
/* APP_SD_CONTEXT_S663_PB */        NULL,
/* APP_SD_CONTEXT_S664,   */        _APP_SD_bHandleButtonS664,
/* APP_SD_CONTEXT_S669,   */        _APP_SD_bHandleButtonS669,
/* APP_SD_CONTEXT_S702,   */        NULL,
/* APP_SD_CONTEXT_S703,   */        NULL,
/* APP_SD_CONTEXT_S704,   */        NULL,
/* APP_SD_CONTEXT_S705,   */        NULL,
/* APP_SD_CONTEXT_S706,   */        NULL,
/* APP_SD_CONTEXT_S707,   */        NULL,
/* APP_SD_CONTEXT_S709,   */        NULL,
/* APP_SD_CONTEXT_S712,   */        NULL,
/* APP_SD_CONTEXT_S713,   */        NULL,
/* APP_SD_CONTEXT_S714,   */        NULL,
/* APP_SD_CONTEXT_S715,   */        NULL,
/* APP_SD_CONTEXT_S719,   */        NULL,
/* APP_SD_CONTEXT_S801,   */        _APP_SD_bHandleButtonS801,
/* APP_SD_CONTEXT_S802,   */        _APP_SD_bHandleButtonS802,
/* APP_SD_CONTEXT_S803,   */        _APP_SD_bHandleButtonS803,
/* APP_SD_CONTEXT_S804,   */        _APP_SD_bHandleButtonS804,
/* APP_SD_CONTEXT_S807,   */        _APP_SD_bHandleButtonS807,
/* APP_SD_CONTEXT_S806,   */        _APP_SD_bHandleButtonS806,
/* APP_SD_CONTEXT_S811,   */        _APP_SD_bHandleButtonS811,
/* APP_SD_CONTEXT_S812,   */        _APP_SD_bHandleButtonS812,
/* APP_SD_CONTEXT_S813,   */        NULL,
/* APP_SD_CONTEXT_S814,   */        _APP_SD_bHandleButtonS814,
/* APP_SD_CONTEXT_S815,   */        _APP_SD_bHandleButtonS815,
/* APP_SD_CONTEXT_S901,   */        _APP_SD_bHandleButtonS901,
/* APP_SD_CONTEXT_S902,   */        _APP_SD_bHandleButtonS902,
/* APP_SD_CONTEXT_S903,   */        _APP_SD_bHandleButtonS903,
/* APP_SD_CONTEXT_S904,   */        _APP_SD_bHandleButtonS904,
/* APP_SD_CONTEXT_S913,   */        _APP_SD_bHandleButtonS913,
/* APP_SD_CONTEXT_S914,   */        _APP_SD_bHandleButtonS914,
/* APP_SD_CONTEXT_S916,   */        NULL,
/* APP_SD_CONTEXT_S917,   */        _APP_SD_bHandleButtonS917,
/* APP_SD_CONTEXT_S923,   */        _APP_SD_bHandleButtonS923,
/* APP_SD_CONTEXT_S924,   */        NULL,
/* APP_SD_CONTEXT_S925,   */        _APP_SD_bHandleButtonS925,
/* APP_SD_CONTEXT_S927,   */        _APP_SD_bHandleButtonS927,
/* APP_SD_CONTEXT_S928,   */        _APP_SD_bHandleButtonS928,
/* APP_SD_CONTEXT_S929,   */        NULL,
/* APP_SD_CONTEXT_S930,   */        _APP_SD_bHandleButtonS930,
/* APP_SD_CONTEXT_S933,   */        _APP_SD_bHandleButtonS933,
/* APP_SD_CONTEXT_S934,   */        NULL,
/* APP_SD_CONTEXT_S935,   */        _APP_SD_bHandleButtonS935,
/* APP_SD_CONTEXT_S941,   */        _APP_SD_bHandleButtonS941,
/* APP_SD_CONTEXT_S942,   */        _APP_SD_bHandleButtonS942,
/* APP_SD_CONTEXT_S945,   */        _APP_SD_bHandleButtonS945,
/* APP_SD_CONTEXT_SC01,   */        _APP_SD_bHandleButtonSC01,
/* APP_SD_CONTEXT_SC03,   */        _APP_SD_bHandleButtonSC03,
/* APP_SD_CONTEXT_SC04,   */        _APP_SD_bHandleButtonSC04,
/* APP_SD_CONTEXT_SC07,   */        _APP_SD_bHandleButtonSC07,
/* APP_SD_CONTEXT_SC12,   */        _APP_SD_bHandleButtonSC12,
/* APP_SD_CONTEXT_SC12_2  */        _APP_SD_bHandleButtonSC12,
/* APP_SD_CONTEXT_SC13,   */        _APP_SD_bHandleButtonSC13,
/* APP_SD_CONTEXT_SC14,   */        NULL,
/* APP_SD_CONTEXT_SC16,   */        _APP_SD_bHandleButtonSC16,
///* APP_SD_CONTEXT_SC17,   */        _APP_SD_bHandleButtonSC17,
/* APP_SD_CONTEXT_SC20,   */        _APP_SD_bHandleButtonSC20,
/* APP_SD_CONTEXT_SC22,   */        _APP_SD_bHandleButtonSC22,
/* APP_SD_CONTEXT_SC23,   */        _APP_SD_bHandleButtonSC23,
/* APP_SD_CONTEXT_SC24,   */        _APP_SD_bHandleButtonSC24,
/* APP_SD_CONTEXT_SP18,   */        _APP_SD_bHandleButtonS_18,
/* APP_SD_CONTEXT_SA01,   */        NULL,
/* APP_SD_CONTEXT_SA02,   */        NULL,
/* APP_SD_CONTEXT_SA03,   */        NULL,
/* APP_SD_CONTEXT_SB34,   */        _APP_SD_bHandleButtonSB34
};


/* if this assertion fails, the jumptable matches not the number of context ids */
CCASSERT(APP_SD_CONTEXT_LAST == NUM_ELEMENTS_OF_ARRAY(_APP_SD_sfHandleButtonTable), _APP_SD_sfHandleButtonTable);

/*----------------------------------------------------------------------------*/
/* File local Code Macros                                                     */
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* File local Variables                                                       */
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* File local const Definitions                                               */
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Private Address Calculations                                               */
/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Function    : APP_SD_bHapticalInterfaceAvailable()                         */
/**
    \brief      indicate if haptical interface is available or not

    \brief      Description:\n
                check function needed by VCR

    \return     BooleanType BT_TRUE if haptical is available
                            BT_FALSE otherwise

   */
/*----------------------------------------------------------------------------*/
BooleanType APP_SD_bHapticalInterfaceAvailable(void)
{
    return KPB_bIsAsgAvailable();
}


/*----------------------------------------------------------------------------*/
/* Function    : APP_SD_sfInit                                                   */
/**
    \brief      Callback function for initialization of MOD SD

    \return     SuccessFailType
          Status of function run
          SUCCESS, FAIL
*/
/*----------------------------------------------------------------------------*/
SuccessFailType APP_SD_sfInitApp()
{
    Uint8Type lastMode = 0x00;
    CommonResponseCodeType retVal_E2P = COMMON_RSP_OK;
    (void)memset(&gAppSdContext, 0, sizeof(gAppSdContext));
    gAppSdContext.pCurCtxCtrl = &gAppSdContext.ctxHistory[0];
    gAppSdContext.bHeadSetActivated = BT_FALSE;

    // #2314
    if(_APP_SD_SetEEpromSavedLanguage() != SUCCESS)
    {
        DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "DiagLangChanged: SetEEpromSavedLang failed" );
    }
    // #4812
    retVal_E2P = EEPROM_enGetSingleByteFromRamMirror((Uint8Type *)&lastMode, EEPROM_LAYOUT_ENUM_KPB_Display_Status);
    if(retVal_E2P == COMMON_RSP_ERROR_BUSY)
    {
        DEBUG_TEXT(KPB_SWI_ERR, MOD_APP_SD, "APP_SD_sfInitApp: EEProm(LAST_MODE): failed");
    }
    if (lastMode & 0x80)
    {/* ASG is visible */
        DEBUG_TEXT(KPB_SWI_TRC, MOD_APP_SD, "APP_SD_sfInitApp: ASG is visible");
        gAppSdContext.ctxInView = APP_SD_UHV_IN_ASG_VIEW;
    }
    else
    {/* ASG is NOT visible */
        gAppSdContext.ctxInView = APP_SD_UHV_NOT_IN_ASG_VIEW;
        DEBUG_TEXT(KPB_SWI_TRC, MOD_APP_SD, "APP_SD_sfInitApp: ASG is NOT visible");
    }
    gAppSdContext.prompts      = APP_SD_a2stStaticTexts[gAppSdContext.curLang];
    gAppSdContext.prompts_len  = APP_SD_a2stStaticTextLens[gAppSdContext.curLang];

    (void)_APP_SD_vResetPendingProfile();

    return SUCCESS;
}


/*----------------------------------------------------------------------------*/
/* Function :   APP_SD_vDiagLanguagesChanged                                  */
/**
  \brief        Diagnostic languages have been changed
  \brief        Description:\n
                Is called when APP_DIAG completly read out EEPROM settings during
                startup and when ever language changed during diagnostic session

  \return       void

 */
/*----------------------------------------------------------------------------*/
void APP_SD_vDiagLanguagesChanged()
{
    if(_APP_SD_SetEEpromSavedLanguage() != SUCCESS)
    {

        DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "DiagLangChanged: SetEEpromSavedLang failed");
    }
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_SetEEpromSavedLanguage                                */
/**
  \brief        Is called to set the language saved in EEPROM as current SD language

  \return       SuccessFailType
                SUCCESS or FAIL

 */
/*----------------------------------------------------------------------------*/
static SuccessFailType _APP_SD_SetEEpromSavedLanguage()
{
    // read saved sd language
    Uint8Type _APP_CAN_u8KombiLanguage = 0xFF;
    CommonResponseCodeType retVal_E2P = COMMON_RSP_OK;
    SuccessFailType sF = SUCCESS;

    EEDeviceControlBlockType    *pEEApp = (EEDeviceControlBlockType *)getEEAppTaskControl();
    retVal_E2P = EEPROM_enGetSingleByteFromRamMirror(&_APP_CAN_u8KombiLanguage, EEPROM_LAYOUT_ENUM_LastSaveLanguageSelection);
    if (retVal_E2P == COMMON_RSP_OK)
    {

        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "SetEEpromSLang: ChangeLang (%d)",
                      _APP_CAN_u8KombiLanguage );

        // change the language as an SD internal indication
        sF = APP_SD_sfChangeLanguage((APP_CAN_enLang)_APP_CAN_u8KombiLanguage, BT_TRUE);


        if(sF != SUCCESS)
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD,  "SetEEpromSLang: sfChangeLanguage failed (%d)",
                          sF);
        }
    }
    else
    {

        DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD,  "SetEEpromSavedLanguage: E2P Read failed");
    }

    return sF;
}


/*----------------------------------------------------------------------------*/
/* Function    : APP_SD_vResetPendingProfile                                  */
/**
    \brief      Resets current pending profile

    \return     void
*/
/*----------------------------------------------------------------------------*/
static void _APP_SD_vResetPendingProfile()
{
    /* init struct for pending device id */
    gAppSdContext.pendingProfile.bPending       = BT_FALSE;
    gAppSdContext.pendingProfile.profileType    = APP_DEVICE_enTYPE_UNKNOWN;
    gAppSdContext.pendingProfile.deviceId       = AT_INVALID_DEVICE_ID;
}


/*----------------------------------------------------------------------------*/
/* Function    : APP_SD_sfChangeLanguage                                      */
/**
    \brief      Change language to the specified language id

    \param      newCanLang
                New language id to set

    \return     SuccessFailType
          Status of function run
          SUCCESS, FAIL
*/
/*----------------------------------------------------------------------------*/
static SuccessFailType APP_SD_sfChangeLanguage(APP_CAN_enLang newCanLang, BooleanType bSdInternalOnly)
{
    //APP_SD_ENUM_LANGUAGES sdLang = APP_SD_enLANG_English;
    APP_SD_ENUM_LANGUAGES sdLang = APP_SD_enMAX_LANGUAGE;
    Uint8Type fallbackLang = APP_DIAG_FALLBACK_LANG_NONE;

    // first check if requested language is available via Anpasskanal
    // if not check if there is an alternative language for requested one
    // if not set the fallback language , see also table below

    //0       keine Sprachvariante                                        Rückfallsprache
    //1       Deutsch                 Deutsch                             Rückfallsprache
    //2       Englisch                UK-Englisch     US-Englisch         Rückfallsprache
    //3       Französisch             EU-Französisch  CDN-Französisch     Rückfallsprache
    //4       Italienisch             Italienisch                         Rückfallsprache
    //5       Spanisch                EU-Spanisch     US-Spanisch         Rückfallsprache
    //6       Portugiesisch           Portugiesisch                       Rückfallsprache
    //8       Tschechisch             Tschechisch                         Rückfallsprache
    //9       Chinesisch                                                  Rückfallsprache
    //10      US-Englisch             US-Englisch     UK-Englisch         Rückfallsprache
    //11      Niederländisch          Niederländisch                      Rückfallsprache
    //12      Japanisch                                                   Rückfallsprache
    //13      Russisch                Russisch                            Rückfallsprache
    //14      Koreanisch                                                  Rückfallsprache
    //15      Franko_Kanadisch        CDN-Französisch EU-Französisch      Rückfallsprache
    //16      Schwedisch              Schwedisch                          Rückfallsprache
    //17      Polnisch                Polnisch                            Rückfallsprache
    //18      Türkisch                Türkisch                            Rückfallsprache
    //19      US-Spanisch             US-Spanisch     EU-Spanisch         Rückfallsprache
    //20      Norwegisch              Norwegisch                          Rückfallsprache

    // ************************************************************************
    // As told by Hüsnü we should not check the language mask set by diagnosis,
    // so removed all the code associated to this checks !!!!!!!!!!!!
    // So do not check whether Langauge is available as coded in DIAG or not !!!!
    // ************************************************************************
    switch(newCanLang)
    {
        // 1. Try to use the current language signalled via APP_CAN
        case APP_CAN_Deutsch:
            if(BT_TRUE == _APP_SD_bIsCANLanguageAvailable(newCanLang))
            {
                sdLang = APP_SD_enLANG_German;
            }
            /* no alternative */
            break;
        case APP_CAN_Englisch:
            if(BT_TRUE == _APP_SD_bIsCANLanguageAvailable(newCanLang))
            {
                sdLang = APP_SD_enLANG_English;
            }
            else if(BT_TRUE == _APP_SD_bIsCANLanguageAvailable(APP_CAN_US_Englisch))
            {   /* alternative */
                sdLang = APP_SD_enLANG_USEnglish;
            }
            break;
        case APP_CAN_US_Englisch:
            if(BT_TRUE == _APP_SD_bIsCANLanguageAvailable(newCanLang))
            {
                sdLang = APP_SD_enLANG_USEnglish;
            }
            else if(BT_TRUE == _APP_SD_bIsCANLanguageAvailable(APP_CAN_Englisch))
            {   /* alternative */
                sdLang = APP_SD_enLANG_English;
            }
            break;
        case APP_CAN_Franzoesisch:
            if(BT_TRUE == _APP_SD_bIsCANLanguageAvailable(newCanLang))
            {
                sdLang = APP_SD_enLANG_French;
            }
            else if(BT_TRUE == _APP_SD_bIsCANLanguageAvailable(APP_CAN_Franko_Kanadisch))
            {   /* alternative */
                sdLang = APP_SD_enLANG_CanadianFrench;
            }
            break;
        case APP_CAN_Franko_Kanadisch:
            if(BT_TRUE == _APP_SD_bIsCANLanguageAvailable(newCanLang))
            {
                sdLang = APP_SD_enLANG_CanadianFrench;
            }
            else if(BT_TRUE == _APP_SD_bIsCANLanguageAvailable(APP_CAN_Franzoesisch))
            {   /* alternative */
                sdLang = APP_SD_enLANG_French;
            }
            break;
        case APP_CAN_Italienisch:
            if(BT_TRUE == _APP_SD_bIsCANLanguageAvailable(newCanLang))
            {
                sdLang = APP_SD_enLANG_Italian;
            }
            /* no alternative */
            break;
        case APP_CAN_Spanisch:
            if(BT_TRUE == _APP_SD_bIsCANLanguageAvailable(newCanLang))
            {
                sdLang = APP_SD_enLANG_Spanish;
            }
            else if(BT_TRUE == _APP_SD_bIsCANLanguageAvailable(APP_CAN_US_Spanisch))
            {   /* alternative */
                sdLang = APP_SD_enLANG_USSpanish;
            }
            break;
        case APP_CAN_US_Spanisch:
            if(BT_TRUE == _APP_SD_bIsCANLanguageAvailable(newCanLang))
            {
                sdLang = APP_SD_enLANG_USSpanish;
            }
            else if(BT_TRUE == _APP_SD_bIsCANLanguageAvailable(APP_CAN_Spanisch))
            {   /* alternative */
                sdLang = APP_SD_enLANG_Spanish;
            }
            break;
        case APP_CAN_Portugiesisch:
            if(BT_TRUE == _APP_SD_bIsCANLanguageAvailable(newCanLang))
            {
                sdLang = APP_SD_enLANG_Portugese;
            }
            /* no alternative */
            break;
        case APP_CAN_Russisch:
            if(BT_TRUE == _APP_SD_bIsCANLanguageAvailable(newCanLang))
            {
                sdLang = APP_SD_enLANG_Russian;
            }
            /* no alternative */
            break;
        case APP_CAN_Tschechisch:
            if(BT_TRUE == _APP_SD_bIsCANLanguageAvailable(newCanLang))
            {
                sdLang = APP_SD_enLANG_Czech;
            }
            /* no alternative */
            break;
        case APP_CAN_Niederlaendisch:
            if(BT_TRUE == _APP_SD_bIsCANLanguageAvailable(newCanLang))
            {
                sdLang = APP_SD_enLANG_Dutch;
            }
            /* no alternative */
            break;
        case APP_CAN_Schwedisch:
            if(BT_TRUE == _APP_SD_bIsCANLanguageAvailable(newCanLang))
            {
                sdLang = APP_SD_enLANG_Swedish;
            }
            /* no alternative */
            break;
        case APP_CAN_Polnisch:
            if(BT_TRUE == _APP_SD_bIsCANLanguageAvailable(newCanLang))
            {
                sdLang = APP_SD_enLANG_Polish;
            }
            /* no alternative */
            break;
        case APP_CAN_Tuerkisch:
            if(BT_TRUE == _APP_SD_bIsCANLanguageAvailable(newCanLang))
            {
                sdLang = APP_SD_enLANG_Turkish;
            }
            /* no alternative */
            break;
        case APP_CAN_Norwegisch:
            if(BT_TRUE == _APP_SD_bIsCANLanguageAvailable(newCanLang))
            {
                sdLang = APP_SD_enLANG_Norwegian;
            }
            /* no alternative */
            break;
        default:
            DEBUG_VALUE1( APP_SD_SWI_WNG, MOD_APP_SD,  "ChangeLang: unsupp. CAN lang. %d",
                          newCanLang);
            sdLang = APP_SD_enMAX_LANGUAGE;
            break;
    }

    // 2. check if the given CAN language was not valid or not available
    // if so, see if we have a fallback language saved via diagnosis in eeprom
    if(APP_SD_enMAX_LANGUAGE == sdLang)
    {
        // requested language and alternative are not available
        // we need to use the fallback language
        fallbackLang        = APP_DIAG_FALLBACK_LANG_NONE;

        EEPROM_LAYOUT_vGetFallbackLanguage(&fallbackLang);

        // get fallback language and use this one
        DEBUG_VALUE1( APP_SD_SWI_WNG, MOD_APP_SD, "ChangeLang: GetFb succ. %d",
                       fallbackLang);

        // now get SD language for Fallback in EEPROM and set this
        // we need not to check if fallback language is available in
        // Anpasskanal!!!! It must be available in any case
        // fct. will return APP_SD_enMAX_LANGUAGE if fallBackLang contains
        // an invalid value e.g. cause of a not initialized eeprom
        // this value will be check below ( see next if-case )
        sdLang = _APP_SD_eGetDiagFallbackLangAsSdLang(fallbackLang);
    }

    /* now check for the last time if we got a valid and supported language or not */
    if(APP_SD_enMAX_LANGUAGE > sdLang)
    {   /* Puuh, we got a valid language, use it */
        gAppSdContext.curLang = sdLang;
        gAppSdContext.prompts      = APP_SD_a2stStaticTexts[sdLang];
        gAppSdContext.prompts_len  = APP_SD_a2stStaticTextLens[sdLang];

        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "ChangeLang: set sdLang %d",
                      sdLang);
    }
    else
    {   /* AARRGGHHH!!!!!!!! */
        /* this should never happen, cause there seems to be a problem setting
         * the correct languages and fallback language in eeprom. */
        /* to avoid a system crash we set the language to English */

        // 3.
        // lets check if there was ever set a valid language via CAN, so we will
        // use this further. If current language is not valid, cause we are in
        // init phase, set english as default to avoid a system crash !!!!!

        if(sdLang == APP_SD_enMAX_LANGUAGE)
        {
            gAppSdContext.prompts      = APP_SD_a2stStaticTexts[APP_SD_enLANG_English];
            gAppSdContext.prompts_len  = APP_SD_a2stStaticTextLens[APP_SD_enLANG_English];
            gAppSdContext.curLang = APP_SD_enLANG_English;

            DEBUG_VALUE2( APP_SD_SWI_ERR, MOD_APP_SD, "ChangeLang: inv.CANLang %d + inv.fb %d,set. eng avoid crash",
                          newCanLang, fallbackLang);
        }
        else
        {
            DEBUG_VALUE4( APP_SD_SWI_ERR, MOD_APP_SD, "ChangeLang: inv.CANLang %d + inv.fb %d, keep lang %d",
                          newCanLang, fallbackLang, gAppSdContext.curLang, 0);

        }
    }

    DEBUG_VALUE1( APP_SD_SWI_DBG, MOD_APP_SD, "SYS_PERF: SD Startup Event: %d ms (SD is ready)", osGetSystemCounter());

    return SUCCESS;
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_eGetDiagFallbackLangAsSdLang                          */
/**
  \brief        Maps the diognostic language id to the SD language id

  \param        eepromDiagLang
                Diagnostic language id

  \return       APP_SD_ENUM_LANGUAGES

 */
/*----------------------------------------------------------------------------*/
static APP_SD_ENUM_LANGUAGES _APP_SD_eGetDiagFallbackLangAsSdLang(Uint8Type eepromDiagLang)
{
    APP_SD_ENUM_LANGUAGES sdLang = APP_SD_enMAX_LANGUAGE;

    switch(eepromDiagLang)
    {
        case APP_DIAG_FALLBACK_LANG_GERMAN:
            sdLang = APP_SD_enLANG_German;
            break;
        case APP_DIAG_FALLBACK_LANG_ENGLISH:
            sdLang = APP_SD_enLANG_English;
            break;
        case APP_DIAG_FALLBACK_LANG_US_ENGLISH:
            sdLang = APP_SD_enLANG_USEnglish;
            break;
        case APP_DIAG_FALLBACK_LANG_FRENCH:
            sdLang = APP_SD_enLANG_French;
            break;
        case APP_DIAG_FALLBACK_LANG_FRENCH_CANADIAN:
            sdLang = APP_SD_enLANG_CanadianFrench;
            break;
        case APP_DIAG_FALLBACK_LANG_ITALIAN:
            sdLang = APP_SD_enLANG_Italian;
            break;
        case APP_DIAG_FALLBACK_LANG_SPANISH:
            sdLang = APP_SD_enLANG_Spanish;
            break;
        case APP_DIAG_FALLBACK_LANG_PORTUGUESE:
            sdLang = APP_SD_enLANG_Portugese;
            break;
        case APP_DIAG_FALLBACK_LANG_RUSSIAN:
            sdLang = APP_SD_enLANG_Russian;
            break;
        case APP_DIAG_FALLBACK_LANG_CZECH:
            sdLang = APP_SD_enLANG_Czech;
            break;
        case APP_DIAG_FALLBACK_LANG_DUTCH:
            sdLang = APP_SD_enLANG_Dutch;
            break;
        case APP_DIAG_FALLBACK_LANG_US_SPANISH:
            sdLang = APP_SD_enLANG_USSpanish;
            break;
        case APP_DIAG_FALLBACK_LANG_SWEDISH:
            sdLang = APP_SD_enLANG_Swedish;
            break;
        case APP_DIAG_FALLBACK_LANG_POLISH:
            sdLang = APP_SD_enLANG_Polish;
            break;
        case APP_DIAG_FALLBACK_LANG_NORWEGIAN:
            sdLang = APP_SD_enLANG_Norwegian;
            break;
        case APP_DIAG_FALLBACK_LANG_TURKISH:
            sdLang = APP_SD_enLANG_Turkish;
            break;
        default:
            sdLang = APP_SD_enMAX_LANGUAGE;
            break;
    }
    return sdLang;
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_bIsCANLanguageAvailable                               */
/**
  \brief        Checks if the specified language is allowed by diagnostic

  \param        newCanLang
                APP_CAN_enLang

  \return       BooleanType
                BT_TRUE if it is supported
                BT_FALSE otherwise

 */
/*----------------------------------------------------------------------------*/
static BooleanType _APP_SD_bIsCANLanguageAvailable(APP_CAN_enLang newCanLang)
{
    // get bitmask of supported languages from eeproma
    BooleanType bLangSupported = BT_FALSE;

    Uint16Type suppLangMask = 0;
    CommonResponseCodeType sF = EEPROM_enGetMaskingLanguage(&suppLangMask);

    if( COMMON_RSP_OK == sF )
    {
        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "IsCanLangAvail: LangMask: 0x%X", suppLangMask);

        switch(newCanLang)
        {
            case APP_CAN_Deutsch:
                if(suppLangMask & APP_DIAG_LANG_SUPP_GERMAN)
                {
                    bLangSupported = BT_TRUE;
                }
                break;
            case APP_CAN_Englisch:
                if(suppLangMask & APP_DIAG_LANG_SUPP_ENGLISH)
                {
                    bLangSupported = BT_TRUE;
                }
                break;
            case APP_CAN_US_Englisch:
                if(suppLangMask & APP_DIAG_LANG_SUPP_US_ENGLISH)
                {
                    bLangSupported = BT_TRUE;
                }
                break;
            case APP_CAN_Franzoesisch:
                if(suppLangMask & APP_DIAG_LANG_SUPP_FRENCH)
                {
                    bLangSupported = BT_TRUE;
                }
                break;
            case APP_CAN_Franko_Kanadisch:
                if(suppLangMask & APP_DIAG_LANG_SUPP_FRENCH_CANADIAN)
                {
                    bLangSupported = BT_TRUE;
                }
                break;
            case APP_CAN_Italienisch:
                if(suppLangMask & APP_DIAG_LANG_SUPP_ITALIAN)
                {
                    bLangSupported = BT_TRUE;
                }
                break;
            case APP_CAN_Spanisch:
                if(suppLangMask & APP_DIAG_LANG_SUPP_SPANISH)
                {
                    bLangSupported = BT_TRUE;
                }
                break;
            case APP_CAN_Portugiesisch:
                if(suppLangMask & APP_DIAG_LANG_SUPP_PORTUGUESE)
                {
                    bLangSupported = BT_TRUE;
                }
                break;
            case APP_CAN_Russisch:
                if(suppLangMask & APP_DIAG_LANG_SUPP_RUSSIAN)
                {
                    bLangSupported = BT_TRUE;
                }
                break;
            case APP_CAN_Tschechisch:
                if(suppLangMask & APP_DIAG_LANG_SUPP_CZECH)
                {
                    bLangSupported = BT_TRUE;
                }
                break;
            case APP_CAN_Niederlaendisch:
                if(suppLangMask & APP_DIAG_LANG_SUPP_DUTCH)
                {
                    bLangSupported = BT_TRUE;
                }
                break;
            case APP_CAN_Schwedisch:
                if(suppLangMask & APP_DIAG_LANG_SUPP_SWEDISH)
                {
                    bLangSupported = BT_TRUE;
                }
                break;
            case APP_CAN_Polnisch:
                if(suppLangMask & APP_DIAG_LANG_SUPP_POLISH)
                {
                    bLangSupported = BT_TRUE;
                }
                break;
            case APP_CAN_Tuerkisch:
                if(suppLangMask & APP_DIAG_LANG_SUPP_TURKISH)
                {
                    bLangSupported = BT_TRUE;
                }
                break;
            case APP_CAN_Norwegisch:
                if(suppLangMask & APP_DIAG_LANG_SUPP_NORWEGIAN)
                {
                    bLangSupported = BT_TRUE;
                }
                break;
            case APP_CAN_US_Spanisch:
                if(suppLangMask & APP_DIAG_LANG_SUPP_US_SPANISH)
                {
                    bLangSupported = BT_TRUE;
                }
                break;
            default:
                DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "ChangeLang: unsup lang (%d)",
                              newCanLang);
                bLangSupported = BT_FALSE;
                break;
        }
    }
    else
    {
        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "ChangeLang: GetMaskLang failed (%d)",
                      sF);
    }
    DEBUG_VALUE2( APP_SD_SWI_TRC, MOD_APP_SD, "bIsCANLangAvail check for %d: supp: %d",
                  newCanLang, bLangSupported);

    return bLangSupported;
}


/*----------------------------------------------------------------------------*/
/* Function    : _APP_SD_vPrintCtxStates                                        */
/**
    \brief      Function to print internal states for debugging purpose,
                if something blocks or hangs

    \return     void
*/
/*----------------------------------------------------------------------------*/
void _APP_SD_vPrintCtxStates()
{

    DEBUG_VALUE4( APP_SD_SWI_WNG, MOD_APP_SD, "CtxStates %d %d %d",
                  gAppSdContext.pCurCtxCtrl->common.ctxId,
                  gAppSdContext.pCurCtxCtrl->common.pendingType,
                  gAppSdContext.pCurCtxCtrl->common.state,
                  0);
}

/*----------------------------------------------------------------------------*/
/* Function    : _APP_SD_vEventManager                                        */
/**
    \brief      The event manager is responsible for incoming events

    \brief      Description:\n
                The event manager is called for notifications and state changes
                received from other application. It serializes and priorizes the
                incoming events.

    \param      pEvent
                Pointer to the incoming event.

    \return     void
*/
/*----------------------------------------------------------------------------*/
void _APP_SD_vEventManager(const AppSdEventCtxType *pEvent)
{
    SuccessFailType retVal = SUCCESS;
    AppSdEventQueueType *pNewEvent = gAppSdContext.pEventQueue;

    if(KPB_bIsAsgAvailable() != BT_TRUE)
    {

        DEBUG_VALUE1( APP_SD_SWI_WNG, MOD_APP_SD, "vEM: no SD-ASG avail, ignoring event [%d]",
                      pEvent->common.type);
        return;
    }


    DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "vEM: new event $APP_SD_enEventId$ = [%d]",
                  pEvent->common.type);

    if(pEvent->common.type == APP_SD_EVENT_BUTTON)
    {
        /* special handling for button events */
        if(gAppSdContext.btnEvent.common.type == APP_SD_EVENT_BUTTON)
        {

            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "vEM: btn event pend");
            _APP_SD_vPrintCtxStates();
            return;
        }

        (void)memcpy(&(gAppSdContext.btnEvent),&(pEvent->btn),sizeof(pEvent->btn));
    }
    else if( pEvent->common.type == APP_SD_EVENT_PHONE &&
             pEvent->phone.notId == APP_PHONE_CALL_STATE_CHANGED)
    {
        /* special handling for callStateChanged only phone events, so we will not
           miss a callState changed event anymore */
        if(gAppSdContext.callStateEvent.common.type == APP_SD_EVENT_PHONE)
        {

            DEBUG_TEXT( APP_SD_SWI_WNG, MOD_APP_SD, "vEM: callStateChanged event pend");
            return;
        }

        (void)memcpy(&(gAppSdContext.callStateEvent),&(pEvent->phone),sizeof(pEvent->phone));
    }
    else
    {
        /* other events than button */

        while(pNewEvent != NULL)
        {

            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "vEM: queued event [%d]",
                                pNewEvent->event.common.type);

            pNewEvent = pNewEvent->next;
        }

        switch(pEvent->common.type)
        {
            case APP_SD_EVENT_PHONE:
            case APP_SD_EVENT_SMS:
            case APP_SD_EVENT_PHONEBOOK:
            case APP_SD_EVENT_VCR:
            case APP_SD_EVENT_DEVICE:
            case APP_SD_EVENT_TIMEOUT:
            case APP_SD_EVENT_ERM_STATE:
            case APP_SD_EVENT_ERM:
            case APP_SD_EVENT_CAN_LANG:
            case APP_SD_EVENT_CAN_SPEED:
            case APP_SD_EVENT_KPB:
            case APP_SD_EVENT_CSHDL:
                /* these events are always ok */
                break;
            default:

                DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vEM: unsupported event %d",
                              pEvent->common.type);
                return;
        }


        retVal = POOL_sfAllocate( POOL_enAppSdEventQueueType,
                                  (void**)&pNewEvent);

        if(retVal != SUCCESS)
        {
            /* no more elements available, check the priority of the oldest (first) element */
            pNewEvent = gAppSdContext.pEventQueue;

//            if(APP_SD_EVENT_PHONE == pEvent->common.type)		// bugfix if an active call during startup and connection
//            {
//                /* special handling for phone indication */
//                _APP_SD_vHandleCallStateChanged();

//                return;
//            }

            if(pNewEvent->event.common.type > pEvent->common.type)
            {
                /* do nothing since the priority of the current event is higher then the new event */

                DEBUG_VALUE2( APP_SD_SWI_WNG, MOD_APP_SD, "vEM: new event [%d] ignored, prio lower oldest queued [%d]",
                              pEvent->common.type,
                              pNewEvent->event.common.type);
                return;
            }
            else
            {

                DEBUG_VALUE2( APP_SD_SWI_WNG, MOD_APP_SD, "vEM: new event [%d] overwrites oldest queued [%d]",
                              pEvent->common.type,
                              pNewEvent->event.common.type);
            }

            /* else overwrite the old event and remove it from the front */
            gAppSdContext.pEventQueue = gAppSdContext.pEventQueue->next;
        }

        if(pNewEvent == NULL)
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vEM: critical error (Line: %d)",
                          __LINE__);
            return;
        }


        (void)memcpy(&(pNewEvent->event), pEvent, sizeof(AppSdEventCtxType));

        pNewEvent->next = NULL;

        if(gAppSdContext.pEventQueue == NULL)
        {
            gAppSdContext.pEventQueue = pNewEvent;
        }
        else
        {
            /* find the end */
            AppSdEventQueueType *pTmpEvent = gAppSdContext.pEventQueue;
            while(pTmpEvent->next != NULL)
            {
                pTmpEvent = pTmpEvent->next;
            }

            pTmpEvent->next = pNewEvent;
        }
    }

    if(gAppSdContext.pCurCtxCtrl->common.pendingType == APP_SD_PENDING_NONE)
    {
        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                            MSEC(0),
                                            0);
    }
}

/*----------------------------------------------------------------------------*/
/* Function :                                      */
/**
  \brief        This function enables the acces to event queue

  \brief        Description:\n
                Returns the next event out of the event queue.

  \param        pEvent
                Pointer to structure to put the queued event in.

  \return       SuccessFailType
                SUCCESS if event was successfully dequeued
                FAIL    if no event was available

 */
/*----------------------------------------------------------------------------*/
SuccessFailType _APP_SD_sfGetNextEvent(AppSdEventCtxType *pEvent)
{
    AppSdEventQueueType *pTmpEvent = NULL;

    /* special handling for buttons */
    if(gAppSdContext.btnEvent.common.type == APP_SD_EVENT_BUTTON)
    {
        (void)memcpy( &(pEvent->btn),
                      &(gAppSdContext.btnEvent),
                      sizeof(gAppSdContext.btnEvent));

        gAppSdContext.btnEvent.common.type = APP_SD_EVENT_INVALID;

        return SUCCESS;
    }

    /* special handling for callState changed phone event */
    if(gAppSdContext.callStateEvent.common.type == APP_SD_EVENT_PHONE)
    {
        (void)memcpy( &(pEvent->phone),
                      &(gAppSdContext.callStateEvent),
                      sizeof(gAppSdContext.callStateEvent));

        gAppSdContext.callStateEvent.common.type = APP_SD_EVENT_INVALID;

        return SUCCESS;
    }

    if(gAppSdContext.pEventQueue == NULL)
    {
        return FAIL;
    }

    (void)memcpy( pEvent, &(gAppSdContext.pEventQueue->event), sizeof(AppSdEventCtxType));

    pTmpEvent = gAppSdContext.pEventQueue;

    gAppSdContext.pEventQueue = gAppSdContext.pEventQueue->next;

    (void)POOL_sfFree(pTmpEvent);

    return SUCCESS;
}



/*----------------------------------------------------------------------------*/
/* Function    : _APP_SD_vReleasePendingContext                               */
/**
    \brief      Resets the current pending type and in the case that an event is
                available, it triggers the processing of this event.

    \return     void
*/
/*----------------------------------------------------------------------------*/
void _APP_SD_vReleasePendingContext(Uint32Type line)
{
    gAppSdContext.pCurCtxCtrl->common.pendingType = APP_SD_PENDING_NONE;

    /* check if there is an event waiting for processing */
    // SUSANNE: 28.12.2009 #4219
    // we also have to check if we have saved a button or callStateChanged event
    // through EventManager. If so, set alarm, too.

    DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "_APP_SD_vReleasePendingContext: called from line %d",line);
    DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "_APP_SD_vReleasePendingContext: current ctxId: %d",gAppSdContext.pCurCtxCtrl->common.ctxId);
    if( (gAppSdContext.pEventQueue                  != NULL)                ||
        (gAppSdContext.btnEvent.common.type         == APP_SD_EVENT_BUTTON) ||
        (gAppSdContext.callStateEvent.common.type   == APP_SD_EVENT_PHONE)  )
    {

        /* there is an event waiting, so set pending to process the event */
        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                            MSEC(0),
                                            0);
    }
}

/*----------------------------------------------------------------------------*/
/* Function    : APP_SD_vHandleEvents                                         */
/**
    \brief      Task Function to handle events for Application Task

    \param      event
                EventMaskType
                Bitmask containing all unhandled events

    \return     void
*/
/*----------------------------------------------------------------------------*/
void APP_SD_vHandleEvents(EventMaskType event)
{
    // wait for interesting events

    if( event & evAppTaskSdFctPending )
    {
        (void)ClearEvent( evAppTaskSdFctPending );

        if(KPB_bIsAsgAvailable() != BT_TRUE)
        {

            DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "vEventManager: no SD-ASG avail, ign. evAppTaskSdFctPending");
            return;
        }
        else
        {
            _APP_SD_vHandlePendingFunction();
        }
    }
}


/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_vHandlePendingFunction                                */
/**
    \brief      Entry point for processing of an active pending event

    \brief      Description:\n
                Depending on the pending type the corresponding handle function
                is called.

    \return     void

 */
/*----------------------------------------------------------------------------*/
void _APP_SD_vHandlePendingFunction()
{
    AppSdCtxCtrlType *pCtxCtrl = gAppSdContext.pCurCtxCtrl;

    /* special handling for timeout event, since the notification of timeout is
     * triggered by an alarmcallback (different task context) */
    if(gAppSdContext.ctxTimedOut != APP_SD_CONTEXT_INVALID)
    {
        AppSdEventCtxType event;
        event.common.type   = APP_SD_EVENT_TIMEOUT;
        event.timeout.ctxId = gAppSdContext.ctxTimedOut;
        _APP_SD_vEventManager(&event);
        gAppSdContext.ctxTimedOut = APP_SD_CONTEXT_INVALID;
    }

    switch(pCtxCtrl->common.pendingType)
    {
        case APP_SD_PENDING_NONE:
        {
            AppSdEventCtxType newEvent;
            if( _APP_SD_sfGetNextEvent( &newEvent ) == SUCCESS )
            {
                switch(newEvent.common.type)
                {
                    case APP_SD_EVENT_INVALID:
                        /* no pending event available, nothing to do */
                        break;
                    case APP_SD_EVENT_ERM_STATE:
                        (void)_APP_SD_sfHandleErmStateEvent(&newEvent.ermState);
                        break;
                    case APP_SD_EVENT_ERM:
                        (void)_APP_SD_sfHandleErmEvent(&newEvent.erm);
                        break;
                    case APP_SD_EVENT_VCR:
                        (void)_APP_SD_sfHandleVcrEvent(&newEvent.vcr);
                        break;
                    case APP_SD_EVENT_PHONE:
                        (void)_APP_SD_sfHandlePhoneEvent(&newEvent.phone);
                        break;
                    case APP_SD_EVENT_PHONEBOOK:
                        (void)_APP_SD_sfHandlePhoneBookEvent(&newEvent.phonebook);
                        break;
                    case APP_SD_EVENT_SMS:
                        (void)_APP_SD_sfHandleSmsEvent(&newEvent.sms);
                        break;
                    case APP_SD_EVENT_BUTTON:
                        (void)_APP_SD_sfHandleButtonEvent(&newEvent.btn);
                        break;
                    case APP_SD_EVENT_TIMEOUT:
                        (void)_APP_SD_sfHandleTimeoutEvent(&newEvent.timeout);
                        break;
                    case APP_SD_EVENT_DEVICE:
                        (void)_APP_SD_sfHandleDeviceEvent(&newEvent.device);
                        break;
                    case APP_SD_EVENT_CAN_LANG:
                        (void)_APP_SD_sfHandleCanLangEvent(&newEvent.canLang);
                        break;
                    case APP_SD_EVENT_CAN_SPEED:
                        (void)_APP_SD_sfHandleCanSpeedEvent(&newEvent.canSpeed);
                        break;
                    case APP_SD_EVENT_KPB:
                        (void)_APP_SD_sfHandleKpbEvent(&newEvent.kpb);
                        break;
                    case APP_SD_EVENT_CSHDL:
                        (void)_APP_SD_sfHandleCshdlEvent(&newEvent.cshdl);
                        break;
                    default:
                        /* nothing to do here */

                        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPendFunc: unknown event type: %d",
                                      newEvent.common.type);
                        break;
                }
            }

            if( (pCtxCtrl->common.pendingType == APP_SD_PENDING_NONE) &&
                (gAppSdContext.pEventQueue != NULL ) )
            {
                /* there is an event waiting, so set pending to process the event */
                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                    MSEC(0),
                                                    0);
            }
            break;
        }
        case APP_SD_PENDING_INIT:
        {
            /*RT13591*/
            switch(pCtxCtrl->common.ctxId)
            {
                case APP_SD_CONTEXT_S102:
                    if(BT_FALSE == _KPB_bGetVisbilitySetOnOff())
                    {
                        /* Don't transmit anything through KPB, visibility is set to off already */
                        /* Release context */
                        DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "13591: After visibility is off: Retry to send the data.");
                        (void) _APP_SD_vReleasePendingContext(__LINE__);
                    }
                    else
                    {
                        /* Visibility is not set to off, proceed to normal handling */
                        (void)_APP_SD_sfHandleInitFrame(pCtxCtrl);
                    }
                    break;
                default:
                    (void)_APP_SD_sfHandleInitFrame(pCtxCtrl);
                    break;
            }
            break;
        }
        case APP_SD_PENDING_BUTTON:
        {
            SuccessFailType rspCode = SUCCESS;

            switch(pCtxCtrl->common.ctxId)
            {
                case APP_SD_CONTEXT_S104:
                    rspCode = _APP_SD_sfHandlePendingButtonS104(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S306:
                    rspCode = _APP_SD_sfHandlePendingButtonS306(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S413:
                    rspCode = _APP_SD_sfHandlePendingButtonS413(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S513:
                    rspCode = _APP_SD_sfHandlePendingButtonS513(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S512:
                    rspCode = _APP_SD_sfHandlePendingButtonS512(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S51D:
                    rspCode = _APP_SD_sfHandlePendingButtonS51D(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S51D_ACCEPT:
                    rspCode = _APP_SD_sfHandlePendingButtonS51D_ACCEPT(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S520:
                    rspCode = _APP_SD_sfHandlePendingButtonS520(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S52C:
                    rspCode = _APP_SD_sfHandlePendingButtonS52C(pCtxCtrl);
                    break;
//                case APP_SD_CONTEXT_S535:
//                    rspCode = _APP_SD_sfHandlePendingButtonS535(pCtxCtrl);
//                    break;
                case APP_SD_CONTEXT_S536:
                    rspCode = _APP_SD_sfHandlePendingButtonS536(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S542:
                    rspCode = _APP_SD_sfHandlePendingButtonS542(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S555:
                    rspCode = _APP_SD_sfHandlePendingButtonS555(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S556:
                    rspCode = _APP_SD_sfHandlePendingButtonS556(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S563:
                    rspCode = _APP_SD_sfHandlePendingButtonS563(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S572:
                    rspCode = _APP_SD_sfHandlePendingButtonS572(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S575:
                    rspCode = _APP_SD_sfHandlePendingButtonS575(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S576:
                    rspCode = _APP_SD_sfHandlePendingButtonS576(pCtxCtrl);
                    break;
                //case APP_SD_CONTEXT_S577:
                //    rspCode = _APP_SD_sfHandlePendingButtonS577(pCtxCtrl);
                //    break;
                case APP_SD_CONTEXT_S579:
                    rspCode = _APP_SD_sfHandlePendingButtonS579(pCtxCtrl);
                    break;
//                case APP_SD_CONTEXT_S580:
//                    rspCode = _APP_SD_sfHandlePendingButtonS580(pCtxCtrl);
//                    break;
                case APP_SD_CONTEXT_S581:
                    rspCode = _APP_SD_sfHandlePendingButtonS581(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S602:
                    rspCode = _APP_SD_sfHandlePendingButtonS602(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S642:
                    rspCode = _APP_SD_sfHandlePendingButtonS642(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S661:
                    rspCode = _APP_SD_sfHandlePendingButtonS661(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S669:
                    rspCode = _APP_SD_sfHandlePendingButtonS669(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S801:
                    rspCode = _APP_SD_sfHandlePendingButtonS801(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S803:
                    rspCode = _APP_SD_sfHandlePendingButtonS803(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S804:
                    rspCode = _APP_SD_sfHandlePendingButtonS804(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S811:
                    rspCode = _APP_SD_sfHandlePendingButtonS811(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S812:
                    rspCode = _APP_SD_sfHandlePendingButtonS812(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S815:
                    rspCode = _APP_SD_sfHandlePendingButtonS815(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S901:
                    rspCode = _APP_SD_sfHandlePendingButtonS901(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S902:
                    rspCode = _APP_SD_sfHandlePendingButtonS902(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S933:
                    rspCode = _APP_SD_sfHandlePendingButtonS933(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S941:
                    rspCode = _APP_SD_sfHandlePendingButtonS941(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S942:
                    rspCode = _APP_SD_sfHandlePendingButtonS942(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S945:
                    rspCode = _APP_SD_sfHandlePendingButtonS945(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_SC13:
                    rspCode = _APP_SD_sfHandlePendingButtonSC13(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_SC16:
                    rspCode = _APP_SD_sfHandlePendingButtonSC16(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_SC20:
                    rspCode = _APP_SD_sfHandlePendingButtonSC20(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_SC24:
                    rspCode = _APP_SD_sfHandlePendingButtonSC24(pCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S408_PRECALL:
                    rspCode = _APP_SD_sfHandlePendingButtonS408_PRECALL(pCtxCtrl);
                    break;
                default:
                    rspCode = FAIL;
                    DEBUG_VALUE2( APP_SD_SWI_ERR, MOD_APP_SD, "HandlePendingFunction: unsup ctxId %d pendType %d",
                                  pCtxCtrl->common.ctxId,
                                  pCtxCtrl->common.pendingType);
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
            }
            if(rspCode == FAIL)
            {
                (void)_APP_SD_vInitIdleScreen(0);
            }
            break;
        }
        default:

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HandlePendingFunction: invalid pendType: %d",
                          pCtxCtrl->common.pendingType);
           (void) _APP_SD_vReleasePendingContext(__LINE__);
            break;
    }

}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_sfHandleCanLangEvent                                      */
/**
  \brief        Handles incoming can events
  \brief        Description:\n
                Only language events are currently processed

  \param        pCan
                Incoming can event

  \return       SuccessFailType
                SUCCESS or FAIL

 */
/*----------------------------------------------------------------------------*/
SuccessFailType _APP_SD_sfHandleCanLangEvent(const AppSdCanLangEventType *pCan)
{

    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "HandleCanLangEvent: newLang %d",
                  pCan->newCanLang);

    // change the language as an external indication, not SD internal
    (void)APP_SD_sfChangeLanguage(pCan->newCanLang, BT_FALSE);
    _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
    return SUCCESS;
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_sfHandleCanEvent                                      */
/**
  \brief        Handles incoming can events
  \brief        Description:\n
                Only language events are currently processed

  \param        pCan
                Incoming can event

  \return       SuccessFailType
                SUCCESS or FAIL

 */
/*----------------------------------------------------------------------------*/
SuccessFailType _APP_SD_sfHandleCanSpeedEvent(const AppSdCanSpeedEventType *pCan)
{

    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "HdlCanSpeedEvent: speed %d",
                  pCan->notId);

    // check whether we are in a BT device search and speed is now greater than
    // allowed, if so, we need to cancel the search process and show S407
    if(overSpeed == pCan->notId)
    {
        switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
        {
            case APP_SD_CONTEXT_S520:
            case APP_SD_CONTEXT_S581:
            case APP_SD_CONTEXT_SC13:
            case APP_SD_CONTEXT_S522:
            //case APP_SD_CONTEXT_S52C:
            //case APP_SD_CONTEXT_S51D_ACCEPT:
            //case APP_SD_CONTEXT_S51D:
            //case APP_SD_CONTEXT_S515:
                _APP_SD_vInitFrameS407();
                break;
            default:

                DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "Ign. overspeed not. ctx %d", gAppSdContext.pCurCtxCtrl->common.ctxId);
                break;
        }
    }
    else if(underSpeed == pCan->notId)
    {
        switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
        {
            case APP_SD_CONTEXT_S407:
                _APP_SD_vCtxHistoryStepBack();
                break;
            default:

                DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "Ign. underspeed not. ctx %d", gAppSdContext.pCurCtxCtrl->common.ctxId);
                break;
         }
    }
    else
    {

        DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "Ign. speed not.");
    }

    return SUCCESS;
}


/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_sfHandleKpbEvent                                      */
/**
  \brief        Handles incoming kpb events
  \brief        Description:\n
                Only visible events are currently processed

  \param        pKpb
                Incoming Kpb event

  \return       SuccessFailType
                SUCCESS or FAIL

 */
/*----------------------------------------------------------------------------*/
SuccessFailType _APP_SD_sfHandleKpbEvent(const AppSdKpbEventType *pKpb)
{

    DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "HaKpbEvent: $KPB_enNotificationId$ = %d", pKpb->notId);

    switch(pKpb->notId)
    {
        case KPB_NOTIFY_VISIBLE_ON:
            if(BT_TRUE == _APP_SD_bIsKl15On())
                _APP_SD_vActivateFrame(BT_TRUE, __LINE__);
            (void)_APP_SD_sfCtxHistoryScreenHandling_VisibleON();
            break;
        case KPB_NOTIFY_VISIBLE_ON_BY_ASG:
            (void)_APP_SD_vSetCtxHistoryState(APP_SD_UHV_IN_ASG_VIEW, __LINE__);
            break;
        case KPB_NOTIFY_VISIBLE_OFF:
            _APP_SD_vActivateFrame(BT_FALSE, __LINE__);
            (void)_APP_SD_sfCtxHistoryScreenHandling_VisibleOff();
            break;
        case KPB_NOTIFY_ASG_INIT_DONE_ACTIVE:
        case KPB_NOTIFY_ASG_INIT_DONE:
        {
            BooleanType cradleRestrictionOn = BT_FALSE;
            APP_CSHDL_enCradleRestriction_States cradleState = APP_CSHDL_CRADLE_RESTRICTION_UNKNOWN;

            if(pKpb->notId == KPB_NOTIFY_ASG_INIT_DONE)
            {
                _APP_SD_vActivateFrame(BT_FALSE, __LINE__);
            }
            else
            {
                _APP_SD_vActivateFrame(BT_TRUE, __LINE__);
            }

            // #2314
            // get CAN language
            _APP_SD_SetEEpromSavedLanguage();

            switch(cradleState = APP_CSHDL_eGetCradleRestrictionState())
            {
                case APP_CSHDL_CRADLE_RESTRICTION_OFF:
                    cradleRestrictionOn = BT_FALSE;

                    DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HaKpbEvent: GetCRS -> OFF");
                    break;
                case APP_CSHDL_CRADLE_RESTRICTION_ON:
                    cradleRestrictionOn = BT_TRUE;

                    DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HaKpbEvent: GetCRS -> ON");
                    break;
                case APP_CSHDL_CRADLE_RESTRICTION_UNKNOWN:
                    cradleRestrictionOn = KPB_bGetLastCradleRestriction();

                    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "HaKpbEvent: CRS unknown -> LM %d",
                                  cradleRestrictionOn);
                    break;
                default:

                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaKpbEvent: inv CRS %d",
                                  cradleState);
                    break;
            }

            if(cradleRestrictionOn)
            {
                _APP_SD_vInitFrameS010();
            }
            else
            {
                //RT #5425
                if( gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_INVALID &&
                    ERM_bIsStartupDone() == BT_TRUE )
                {
                    _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                }
                else
                {
                    _APP_SD_vInitFrameS001(0);
                }

                //if(BT_TRUE == ERM_bPhoneAvailable())     // if phone still connected activate idle screen
                //{
                //    KPB_vSetAsgPresentationOff();
                //    _APP_SD_vInitIdleScreen(0);
                //}
                //else
                //{
                //    _APP_SD_vInitFrameS001(0);
                //}
            }

            if(pKpb->notId == KPB_NOTIFY_ASG_INIT_DONE)
            {
                (void)_APP_SD_vSetCtxHistoryState(APP_SD_UHV_NOT_IN_ASG_VIEW, __LINE__);    //RT #2829
            }
            else
            {
                (void)_APP_SD_vSetCtxHistoryState(APP_SD_UHV_IN_ASG_VIEW, __LINE__);
            }
            break;
        }
        case KPB_NOTIFY_BUSOFF_END:
        {
            _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
        }
        default:
            /* do nothing */
            break;
    }
    return SUCCESS;
}


/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_sfHandleCshdlEvent                                      */
/**
  \brief        Handles incoming app cshdl events
  \brief        Description:\n
                Only visible events are currently processed

  \param        pCshdl
                Incoming cshdl event

  \return       SuccessFailType
                SUCCESS or FAIL

 */
/*----------------------------------------------------------------------------*/
SuccessFailType _APP_SD_sfHandleCshdlEvent(const AppSdCshdlEventType *pCshdl)
{

    DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "HandleCshdlEvent: $APP_CSHDL_NotificationType$ = %d", pCshdl->notId);

    switch(pCshdl->notId)
    {
        case APP_CSHDL_NOTIFY_KL_15_OFF:
            if( BT_TRUE != APP_PHONE_AT_PNCC_bAllCallStatesIdle())
            {
                // show the correct call frame
                _APP_SD_vHandleCallStateChanged();
            }
            break;
        case APP_CSHDL_NOTIFY_UHV_ACTIVE_KL_15_ON:
            if( BT_TRUE != APP_PHONE_AT_PNCC_bAllCallStatesIdle())
            {
                // show the correct call frame
                _APP_SD_vHandleCallStateChanged();
            }
            else
            {
                switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
                {
                    /* Handling of KL15 OFF call frames */
                    case APP_SD_CONTEXT_S941:
                    case APP_SD_CONTEXT_S942:
                    case APP_SD_CONTEXT_S945:
                        /* we have a KL 15 OFF call frame but not call active in KL15 on state */
                        _APP_SD_vInitIdleScreen(0);
                        break;
                    default:
                        /* do nothing */
                        break;
                }
            }
            break;
        case APP_CSHDL_NOTIFY_CRADLE_RESTRICTION_ON:
            _APP_SD_vActivateFrame(BT_TRUE, __LINE__);
            _APP_SD_vInitFrameS010();
            break;
        case APP_CSHDL_NOTIFY_CRADLE_RESTRICTION_OFF:
            _APP_SD_vActivateFrame(BT_TRUE, __LINE__);
            _APP_SD_vInitFrameS001(0);
            break;
        case APP_CSHDL_NOTIFY_UHV_ACTIVE_KL_15_OFF:
            /*Intruemnt Cluster is OFF */
            break;
        default:
            /* do nothing */
            break;
    }
    return SUCCESS;
}


/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_sfHandleDeviceEvent                                   */
/**
  \brief        Handles incoming APP_Device events

  \param        pDevice
                Incoming APP_Device event

  \return       SuccessFailType
                SUCCESS or FAIL

 */
/*----------------------------------------------------------------------------*/
SuccessFailType _APP_SD_sfHandleDeviceEvent(const AppSdDeviceEventType *pDevice)
{

    DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "HandleDeviceEvent: event $APP_DEVICE_enNotificationId$ = %d", pDevice->notId);

    switch(pDevice->notId)
    {
        case APP_DEVICE_NOTIFY_ALL_USER_PROFILE_DELETED:
        case APP_DEVICE_NOTIFY_FACTORY_SETTING_RESET:
            _APP_SD_vInitFrameS002(0);
            break;
        case APP_DEVICE_NOTIFY_OUTGOING_CALL_VIA_VCR:
            gAppSdContext.outgoingCallViaVcrInProgress = BT_TRUE;
            break;
        case APP_DEVICE_NOTIFY_MAILBOX_NUMBER_CHANGED:
            switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
            {
                case APP_SD_CONTEXT_S306:
                    _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                    break;
                default:

                    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "vHandleDeviceEvent: ignore notification in ctx %d",
                                  gAppSdContext.pCurCtxCtrl->common.ctxId);
                    break;
            }
            break;
        default:

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vHandleDeviceEvent: unsup dev not: %d",
                          pDevice->notId);
            return FAIL;
     }

    return SUCCESS;
}



/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_sfHandleErmStateEvent                                 */
/**
  \brief        Handles incoming ERM state events

  \brief        Description:\n
                Is called for each ERM state change

  \param        pErm
                Pointer to an incoming ERM state event

  \return       SuccessFailType
                SUCCESS or FAIL

 */
/*----------------------------------------------------------------------------*/
SuccessFailType _APP_SD_sfHandleErmStateEvent(const AppSdErmStateEventType *pErm)
{
    SuccessFailType result = SUCCESS;


    DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "HaErmStEv: $ERMStateType$ = %d", pErm->state);

    switch(pErm->state)
    {
        case ERM_STATE_IDLE:
        case ERM_STATE_START_UP:
        case ERM_STATE_WAIT_ADDRESS:
        case ERM_STATE_SSP_CONFIG:
        case ERM_STATE_CK5050_ACTIVE:
        case ERM_STATE_CK5050_BT_ACTIVE:
        default:

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaErmStEv: unsup erm state: %d",
                          pErm->state);
            result = FAIL;
            break;
     }

    return result;
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_sfHandleErmEvent                                      */
/**
  \brief        Handles incoming ERM notification events

  \param        pErm
                Incoming ERM notification event

  \return       SuccessFailType
                SUCCESS or FAIL

 */
/*----------------------------------------------------------------------------*/
SuccessFailType _APP_SD_sfHandleErmEvent(const AppSdErmEventType *pErm)
{


    DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "HandleErmEvent: event $ERMNotificationIdType$ = %d", pErm->notId.common.id);

    switch(pErm->notId.common.id)
    {
        case ERM_NOTIFY_STARTUP_DONE:
        {
            BooleanType bReinitDone = BT_TRUE;
            /* after ERM startup reinit the following frames, to interact with the CK5050 */
            switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
            {
                case APP_SD_CONTEXT_S001:
                    _APP_SD_vInitFrameS001(0);
                    break;
                case APP_SD_CONTEXT_S520:
                    _APP_SD_vInitFrameS520();
                    break;
                case APP_SD_CONTEXT_SC12_2:
                    _APP_SD_vInitFrameSC12_2(gAppSdContext.sc12DeviceId,gAppSdContext.sc12Counter);
                    break;
                case APP_SD_CONTEXT_SC13:
                    _APP_SD_vInitFrameSC13();
                    break;
                case APP_SD_CONTEXT_S517:
                    _APP_SD_vInitFrameS517(gAppSdContext.pCurCtxCtrl->s517.deviceId,
                                           gAppSdContext.pCurCtxCtrl->s517.deviceType,
                                           BT_TRUE);
                    break;
                // if APP_SD_CONTEXT_S541_2,  // BT Liste der gekoppelten Geräte nach S002, hier wird direkt verbunden nach Auswahl
                // refreshframe because there might be no text entries for profiles
                //case APP_SD_CONTEXT_S541_2:
                case APP_SD_CONTEXT_S408_USERLIST:
                {
                    // ticket #14039
                    //_APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                    _APP_SD_vInitFrameS541(ERM_u16GetNumberOfUserProfiles());
                    break;
                }
                default:
                    bReinitDone = BT_FALSE;
                    break;
            }

            if( bReinitDone )
            {
                DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "HaErmEvent: reinit ctxId %d after ERM Startup",
                              gAppSdContext.pCurCtxCtrl->common.ctxId);
            }
            break;
        }
        case ERM_NOTIFY_BT_VISIBILITY_ON:
            if (APP_SD_CONTEXT_S924 != gAppSdContext.pCurCtxCtrl->common.ctxId)
            {
                _APP_SD_vInitFrameS554();
            }
            break;
        case ERM_NOTIFY_BT_VISIBILITY_OFF:
            if( APP_SD_CONTEXT_SP18 == gAppSdContext.pCurCtxCtrl->common.ctxId ||
                APP_SD_CONTEXT_S018 == gAppSdContext.pCurCtxCtrl->common.ctxId )
            {
                _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
            }
            break;
        case ERM_NOTIFY_INQUIRY_END:
        {
            (void)_APP_SD_sfHandleErmNotificationInquiryEnd();
            break;
        }
        case ERM_NOTIFY_DELETED_DEVICE:
        {
            if (gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_S408_DEL)
            {
                switch(gAppSdContext.deleteActionPressedinScreen)
                {
                    case APP_SD_CONTEXT_S513:
                        _APP_SD_vInitFrameS514( gAppSdContext.s408DelDeviceId,
                                                BT_FALSE,
                                                gAppSdContext.s408DelDeviceName,
                                                gAppSdContext.s408DelDeviceNameLength);
                        break;
                    case APP_SD_CONTEXT_S555:
                        _APP_SD_vInitFrameS514( gAppSdContext.s408DelDeviceId,
                                                BT_TRUE,
                                                gAppSdContext.s408DelDeviceName,
                                                gAppSdContext.s408DelDeviceNameLength);
                        break;
                    case APP_SD_CONTEXT_S576:
                        _APP_SD_vInitFrameS578( gAppSdContext.s408DelDeviceId,
                                                gAppSdContext.s408DelDeviceType,
                                                gAppSdContext.s408DelDeviceName,
                                                gAppSdContext.s408DelDeviceNameLength);
                        break;
                    case APP_SD_CONTEXT_S579:
                        _APP_SD_vInitFrameS578( gAppSdContext.s408DelDeviceId,
                                                gAppSdContext.s408DelDeviceType,
                                                gAppSdContext.s408DelDeviceName,
                                                gAppSdContext.s408DelDeviceNameLength);
                        break;
                    default:
                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "ERM_NOTIFY_DELETED_DEVICE: deleteActionPressedinScreen: %d",gAppSdContext.deleteActionPressedinScreen);
                        break;
                }
                gAppSdContext.deleteActionPressedinScreen = APP_SD_CONTEXT_INVALID;
            }
            else
            {
                DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "ERM_NOTIFY_DELETED_DEVICE: event but screen already switched back:");
            }
            break;
        }
//RS: disabled because this event is now handled by APP_DEVICE and notified per callback
        //case ERM_NOTIFY_CONNECT_FAILED:
        case ERM_NOTIFY_PSBD:
        {
            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "ERM_NOTIFY_PSBD: psbd.status: %d",
                                      pErm->notId.psbd.status);
            if(AT_CONN_FAILED == pErm->notId.psbd.status)
            {
                switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
                {
                    case APP_SD_CONTEXT_S001:
                        //gAppSdContext.pCurCtxCtrl->s001.subState = APP_SD_S001_CONNECT_NOT_SENT;
                        //gAppSdContext.pCurCtxCtrl->s001.connectAttempt++;
                        //_APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "Conn. failed. Trig. S001 att. %d",
                                      gAppSdContext.pCurCtxCtrl->s001.connectAttempt+1);
                        _APP_SD_vInitFrameS001(gAppSdContext.pCurCtxCtrl->s001.connectAttempt+1);
                        break;
                    case APP_SD_CONTEXT_S517:
                        _APP_SD_vInitFrameS518();
                        break;
                    case APP_SD_CONTEXT_S408_ABR:
                    case APP_SD_CONTEXT_S408_PLAYER:
                        _APP_SD_vInitIdleScreen(0);
                        break;
                }
            }
            else if(AT_CONN_NOT_FOUND == pErm->notId.psbd.status)
            {
                if (gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_S001)
                {
                    if(gAppSdContext.pCurCtxCtrl->s001.abort == BT_TRUE)
                    {
                      _APP_SD_vInitFrameS001(gAppSdContext.pCurCtxCtrl->s001.connectAttempt);
                    }
                    else
                    {
                      _APP_SD_vInitFrameS001(gAppSdContext.pCurCtxCtrl->s001.connectAttempt+1);
                    }
                }
                else if(gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_S408_PLAYER || BT_TRUE == gAppSdContext.disconnectPlayerWillFollow ||
                        gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_S408_ABR)
                {
                    _APP_SD_vInitIdleScreen(0);
                }

            }
            else if( AT_CONN_DISCON_SUCC == pErm->notId.psbd.status)
            {
                if (gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_S001)
                {
                    if(gAppSdContext.pCurCtxCtrl->s001.abort == BT_TRUE)
                    {
                      _APP_SD_vInitFrameS001(gAppSdContext.pCurCtxCtrl->s001.connectAttempt);
                    }
                    else
                    {
                      _APP_SD_vInitFrameS001(gAppSdContext.pCurCtxCtrl->s001.connectAttempt+1);
                    }
                }
            }
            else
            {
                DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HaErmEvent: psbd Status ignored");
            }
            break;
        }
        case ERM_NOTIFY_PPRS:
        {

            if(AT_PAIRING_SUCCEEDED != pErm->notId.pprs.result)
            {
                _APP_SD_sfHandleErmNotificationPairingFailed();
            }
            else
            {
                _APP_SD_sfHandleErmNotificationPairingSuccess(pErm->notId.pprs.device_id);
            }
            break;
        }
        //case ERM_NOTIFY_PHONE_ACTIVE_STATE_CHANGED:
        case ERM_NOTIFY_PBSN_PHONE:
        {
            if(gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_S408_ABR)
            {
                if(ERM_u8GetActivePhone() != AT_INVALID_DEVICE_ID)
                {
                    (void) APP_DEVICE_rcDisconnectDevice(ERM_u8GetActivePhone()); //gAppSdContext.pCurCtxCtrl->s408.deviceId);
                }
                else
                {
                    _APP_SD_vInitIdleScreen(0);
                }
            }
            else
            {
                DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "ERM_NOTIFY_PBSN_PHONE: call PhoneStateChanged");
                _APP_SD_vHandlePhoneStateChanged();
            }
            break;
        }
        //case ERM_NOTIFY_PLAYER_ACTIVE_STATE_CHANGED:

        case ERM_NOTIFY_PBSN_AVRCP:
        {/* show idle screen after avrcp connected ( changed: 14.02.2011 nikolov,RT:9959)*/
            if ((AT_SERVRES_START_SUCCEED == pErm->notId.pbsn_avrcp.result)
                    &&(BT_TRUE == _APP_SD_bIsA2dpAlreadyForUserProfileStarted()))
            {
                /* a2dp was connected for a device */
                APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_ERROR_BUSY;
                gAppSdContext.disconnectRequestedByUser  = 0;
                DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "AT_SERVRES_START_SUCCEED");
                DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "and Set gAppSdContext.disconnectRequestedByUser to 0");

                if (gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_S408_PLAYER || BT_TRUE == gAppSdContext.disconnectPlayerWillFollow)
                {
                    DEBUG_VALUE2( APP_SD_SWI_TRC, MOD_APP_SD, "Acitve Phone devId:%d,  Active Player devId:%d",
                    ERM_u8GetActivePhone(), ERM_u8GetActivePlayer());

                    rspCode = APP_DEVICE_rcDeactivateMdiDevice(NULL);

                    if( rspCode == APP_COMMON_RSP_ERROR_BUSY)
                    {

                        DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "ERM_NOTIFY_PBSN_AVRCP: deactivate player busy  --->queue event in Appdevice");
                        APP_DEVICE_vSetDeactivatePlayerPendingFlag(ERM_u8GetActivePlayer());
                    }
                }
                else
                {
                    if (gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_SC12 || gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_SC12_2)
                    {
                        const ERMUserProfileType * profile = ERM_pGetActiveUserProfile();
                        if( NULL != profile )
                        {
                            if (gAppSdContext.sc12DeviceId == ERM_u8GetActivePlayer())
                            {
                                _APP_SD_vInitFrameS574(pErm->notId.pbsn_a2dp.device_id);
                            }
                            else
                            {
                                DEBUG_VALUE2( APP_SD_SWI_TRC, MOD_APP_SD, "ERM_NOTIFY_PBSN_A2DP: connected playerId %d != expected playerID %d",ERM_u8GetActivePlayer(),profile->playerIndex);
                                break;
                            }
                        }
                        else
                        {
                            _APP_SD_vInitFrameS574(pErm->notId.pbsn_a2dp.device_id);
                        }
                    }
                    _APP_SD_vHandlePlayerConnected(pErm->notId.pbsn_a2dp.device_id);
                }
            }
            break;
        }
        case ERM_NOTIFY_PBSN_A2DP:
        {
            switch(pErm->notId.pbsn_a2dp.result)
            {
            case AT_SERVRES_START_SUCCEED:
                /* a2dp was connected for a device */
                {
                    APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_ERROR_BUSY;
                    gAppSdContext.disconnectRequestedByUser  = 0;
                    DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "AT_SERVRES_START_SUCCEED");
                    DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "and Set gAppSdContext.disconnectRequestedByUser to 0");

                    if (gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_S408_PLAYER || BT_TRUE == gAppSdContext.disconnectPlayerWillFollow)
                    {
                        DEBUG_VALUE2( APP_SD_SWI_TRC, MOD_APP_SD, "Acitve Phone devId:%d,  Active Player devId:%d",
                        ERM_u8GetActivePhone(), ERM_u8GetActivePlayer());

                        rspCode = APP_DEVICE_rcDeactivateMdiDevice(NULL);

                        if( rspCode == APP_COMMON_RSP_ERROR_BUSY)
                        {

                            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "ERM_NOTIFY_PBSN_A2DP: deactivate player busy  --->queue event in Appdevice");
                            APP_DEVICE_vSetDeactivatePlayerPendingFlag(ERM_u8GetActivePlayer());
                        }
                    }
                    else
                    {
                        if (gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_SC12 || gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_SC12_2)
                        {
                            const ERMUserProfileType * profile = ERM_pGetActiveUserProfile();
                            if( NULL != profile )
                            {
                                if (gAppSdContext.sc12DeviceId == ERM_u8GetActivePlayer())
                                {
                                    _APP_SD_vInitFrameS574(pErm->notId.pbsn_a2dp.device_id);
                                }
                                else
                                {
                                    DEBUG_VALUE2( APP_SD_SWI_TRC, MOD_APP_SD, "ERM_NOTIFY_PBSN_A2DP: connected playerId %d != expected playerID %d",ERM_u8GetActivePlayer(),profile->playerIndex);
                                    break;
                                    //todo:  what is to do in this situation -> disconnect the wrong MP device and connect the right one
                                }
                            }
                            else
                            {
                                _APP_SD_vInitFrameS574(pErm->notId.pbsn_a2dp.device_id);
                            }
                        }
                        _APP_SD_vHandlePlayerConnected(pErm->notId.pbsn_a2dp.device_id);
                    }
                    break;
                }
            case AT_SERVRES_STOP_SUCCEED:
                /* a2dp was disconnected for a device */
                {
                    if (gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_S408_PLAYER || BT_TRUE == gAppSdContext.disconnectPlayerWillFollow)
                    {
                        _APP_SD_vInitIdleScreen(0);
                    }
                    else
                    {
                        _APP_SD_vHandlePlayerDisconnected(pErm->notId.pbsn_a2dp.device_id);
                    }
                    break;
                }
            default:
                break;
            }
            break;
        }
        //case ERM_NOTIFY_HEADSET_ACTIVE_STATE_CHANGED:
        //{
        //    _APP_SD_vHandleHeadsetStateChanged();
        //    break;
        //}
        case ERM_NOTIFY_SERVICE_SUPPORT_CHANGED:
            _APP_SD_sfHandleErmNotificationServiceSupportChanged();
            break;
        case ERM_NOTIFY_MAILBOX_NUMBER_CHANGED:
        {
            if(APP_SD_CONTEXT_S306 == gAppSdContext.pCurCtxCtrl->common.ctxId)
            {
                _APP_SD_vInitFrameS306();
            }
            break;
        }
        case ERM_NOTIFY_WARN_DIAL_ERROR:
        {
            if(APP_SD_CONTEXT_S408_PRECALL != gAppSdContext.pCurCtxCtrl->common.ctxId)
                _APP_SD_vInitFrameS802(APP_SD_enS802_DIAL_ERROR);
            break;
        }
        case ERM_NOTIFY_WARN_HANGUP_ERROR:
        case ERM_NOTIFY_WARN_PICKUP_ERROR:
        case ERM_NOTIFY_WARN_2ND_CALL_ERROR:
        case ERM_NOTIFY_WARN_DTMF_ERROR:
        {
            _APP_SD_vInitFrameS917();
            break;
        }
        case ERM_NOTIFY_PPRQ:
        {
            const ERMPairReqType *pPairRequest = ERM_pGetPairRequest();
            if (AT_INVALID_DEVICE_ID == ERM_u8GetActivePlayer() || AT_INVALID_DEVICE_ID == ERM_u8GetActivePhone())
            {
                if(pPairRequest->device_type == AT_DELETED_DEVICE )
                {
                    if(pPairRequest->remote_id == ERM_pGetSspRequest()->remote_id)
                    {
                        /* PPRQ and PSPR device id are the same, so we expect a SSP request */
                        if (APP_SD_CONTEXT_S517 == gAppSdContext.pCurCtxCtrl->common.ctxId)
                        {
                            _APP_SD_vInitFrameS52C(ERM_pGetSspRequest()->remote_id, ERM_pGetSspRequest()->device_type, gAppSdContext.pCurCtxCtrl->s517.deviceType);
                        }
                        else
                        {
                            _APP_SD_vInitFrameS52C(ERM_pGetSspRequest()->remote_id, ERM_pGetSspRequest()->device_type, APP_DEVICE_enTYPE_UNKNOWN);
                        }
                    }
                    else
                    {
                        _APP_SD_vInitFrameS51D_ACCEPT(ERM_pGetPairRequest()->remote_id, ERM_pGetPairRequest()->device_type);
                    }
                }
                else
                {
                    _APP_SD_vInitFrameS933();
                }
            }
            else
            {
                ERM_rcRejectPairing(pPairRequest->remote_id,pPairRequest->device_type,NULL);
                _APP_SD_vInitFrameSC23();
            }
            break;
        }
        case ERM_NOTIFY_PSPR:
        {
            /* incoming ssp request only handled in wait or inquiry screen, all
             * other ssp request came in combination with previos pprq and need
             * no special handling. */
            if ( APP_SD_CONTEXT_S408 == gAppSdContext.pCurCtxCtrl->common.ctxId)
            {
                _APP_SD_vInitFrameS52C(gAppSdContext.pCurCtxCtrl->s408.deviceId, AT_INQUIRY_DEVICE, gAppSdContext.pCurCtxCtrl->s408.deviceType);
            }
            break;
        }
        case ERM_NOTIFY_PBSF:
        {
            if ( APP_SD_CONTEXT_S408 == gAppSdContext.pCurCtxCtrl->common.ctxId)
            {
                /* switch s408 context state to next state */
                gAppSdContext.pCurCtxCtrl->s408.subState = APP_SD_S408_RECEIVED_SSP_SUPPORT;
                gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
                gAppSdContext.pCurCtxCtrl->common.pendingType = APP_SD_PENDING_INIT;
                /* save results from ERM in frame context */
                gAppSdContext.pCurCtxCtrl->s408.sspSupported = pErm->notId.pbsf.result;

                DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "ERM_NOTIFY_PBSF: received notification with result = %d ",pErm->notId.pbsf.result);
                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(0), 0);

            }
            else
            {
                DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "ERM_NOTIFY_PBSF: received notification with unknown frame $APP_SD_enContextId$ = %d active",gAppSdContext.pCurCtxCtrl->common.ctxId);
            }
            break;
        }
        //case ERM_NOTIFY_WARN_AVRCP_ERROR:
        //case ERM_NOTIFY_PAIRING_MAX_DEVICES_REACHED:
        //    /* TODO*/
        default:

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vHandleErmEvent: unsup erm not: %d",
                          pErm->notId.common.id);
            return FAIL;
     }

     return SUCCESS;
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_sfHandleErmNotificationServiceSupportChanged          */
/**
  \brief        Handles ERM notification about service support changed

  \return       SuccessFailType
                SUCCESS or FAIL

 */
/*----------------------------------------------------------------------------*/
SuccessFailType _APP_SD_sfHandleErmNotificationServiceSupportChanged()
{
    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        case APP_SD_CONTEXT_S52C:
        case APP_SD_CONTEXT_S52D:
            /* ignore this support changed in this screens */
            break;
        case APP_SD_CONTEXT_S408:
        {
            // here we are waiting for a device to get connected. as we only have one physical phone-player device per time
            // we will not pause the player temporarily
            AT_DeviceId deviceId = ERM_GetLastPairedDeviceId();

            DEBUG_VALUE2( APP_SD_SWI_TRC, MOD_APP_SD, "NotifServSuppChngd S408,devId:%d,type:%d",
                          deviceId, gAppSdContext.pCurCtxCtrl->s408.deviceType);
            if(deviceId <= AT_MAX_DEVICE_ID)
            {
                switch(gAppSdContext.pCurCtxCtrl->s408.deviceType)
                {
                    case APP_DEVICE_enTYPE_PHONE:
                    {
                        if(gAppSdContext.bDelepairingonlyondevice == BT_TRUE)
                        {
                            gAppSdContext.bDelepairingonlyondevice = BT_FALSE;
                        }
                        else if( ERM_bIsPhone(deviceId) == BT_TRUE )
                        {
                            // SUSANNE 28.12.2009 #4301 When the user is changed we will not pause the player temporarily, in the user handling
                            // variant with only one physical device, cause after connecting the new phone-player-device, the player should not start playing on itself
                            if(BT_TRUE == APP_MDI_bMutePlayer(APP_MDI_MUTE_DEVICE_CONNECT))
                            {   /* player muted */
                                _APP_SD_vInitFrameS522(APP_SD_MDI_MUTE_FOR_CONNECT, deviceId,
                                                       APP_DEVICE_enTYPE_PHONE, BT_TRUE);/*RT-13181-Phone*/
                            }
                            else
                            {   /* immediately connect */
                                _APP_SD_vInitFrameS517( deviceId, APP_DEVICE_enTYPE_PHONE, BT_TRUE);
                            }
                        }
                        else
                        {
                            _APP_SD_vInitFrameS599();
                        }
                        break;
                    }
                    case APP_DEVICE_enTYPE_PLAYER:
                    case APP_DEVICE_enTYPE_HEADSET:
                        //if(_APP_SD_bPausePlayerTemporarilyNeeded())
                        if(BT_TRUE == APP_MDI_bMutePlayer(APP_MDI_MUTE_DEVICE_CONNECT))
                        {
                            _APP_SD_vInitFrameS522(APP_SD_MDI_MUTE_FOR_CONNECT, deviceId,
                                                   gAppSdContext.pCurCtxCtrl->s408.deviceType, BT_TRUE);
                        }
                        else
                        {
                            _APP_SD_vInitFrameS517( deviceId,
                                                   gAppSdContext.pCurCtxCtrl->s408.deviceType,
                                                   BT_TRUE);
                        }
                        break;
               }
            }
            else
            {

                DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "NotifServSuppChngd devId out of range (%d)",
                              deviceId);
            }
            break;
        }
        case APP_SD_CONTEXT_SC12:
        case APP_SD_CONTEXT_SC12_2:
        //case APP_SD_CONTEXT_S517:
        case APP_SD_CONTEXT_S408_PLAYER:
            /* do nothing in this context */

            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "NotifServSuppChngd: ign. in ctx %d",
                          gAppSdContext.pCurCtxCtrl->common.ctxId);
            break;
        case APP_SD_CONTEXT_S517_PASSIVE:
        case APP_SD_CONTEXT_S517:
        {
            AT_DeviceId deviceId = ERM_GetLastPairedDeviceId();
            /* Since the screen S580 does no longer exist, we have to wait for the SDP event to decide if we add a profile
             * for a standalone player or a mixed device (phone + player) */
            if( (BT_TRUE == ERM_bSdpReceived(deviceId)) && (deviceId <= AT_MAX_DEVICE_ID) )
            {
                DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "NotifServSuppChngd: paired device: %d",deviceId);
                if( (ERM_bIsPhone(deviceId) == BT_TRUE) && (ERM_pGetUserProfile_DevId(deviceId) == NULL) )
                {
                    DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "NotifServSuppChngd: new phone device -> create profile (%d)",deviceId);
                    /* there is no user profile available */
                    /* a new paired device is active, set up a user */
                    // go to T5.3
                    if( BT_TRUE == ERM_bMaxNumberOfUserProfilesReached() )
                    {
                        DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "NotifServSuppChngd: max user profiles reached");
                        // user needs to delete one of the existing profiles first
                        /* save deviceId etc. for pending profile */
                        gAppSdContext.pendingProfile.bPending       = BT_TRUE;
                        gAppSdContext.pendingProfile.profileType    = APP_DEVICE_enTYPE_PHONE;
                        gAppSdContext.pendingProfile.deviceId       = deviceId;
                        /* now tell user to delete an existing profile */
                        _APP_SD_vInitFrameS511();
                    }
                    else
                    {
                        _APP_SD_vInitFrameS534(deviceId);
                    }
                }
                else if( BT_FALSE == ERM_bIsPhone(deviceId) && BT_FALSE == ERM_bDeviceAlreadyKnownAsPlayer(deviceId))
                {
                    if ( deviceId == ERM_u8GetActivePlayer())
                    {
                        /* there is no player profile available */
                        /* create new player profile, implicitly delete the oldest player profile if necessary  */
                        APP_DEVICE_vAddMissingPlayerProfileImplicitlyBySD();
                        DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "NotifServSuppChngd: standalone player -> create profile (%d)",ERM_u8GetActivePlayer());
                        /* conenct was triggered by SD */
                        _APP_SD_vInitFrameS574(deviceId);
                    }
                    else
                    {
                        /* player already connected, connection not possible */
                        _APP_SD_vInitFrameS518();
                    }
                }
            }
            break;
        }
        default:
        {   /* seems no context which is interested in this notification is currently in foreground
               This can happen cause its currently overlayed by a popup */

            AppSdCtxCtrlType *pServSuppCtx = NULL;

            /* first check if the service support update was triggered due to an action we made in the past */
            if( (pServSuppCtx = _APP_SD_pGetHistoryContext(APP_SD_CONTEXT_S408)) != NULL )
            {

                DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "NotifServSuppChngd: hist ctx %d -> marker",
                              APP_SD_CONTEXT_S408);

                pServSuppCtx->s408.subState = APP_SD_S408_RECEIVED_SERVICE_SUPPORT_CHANGED;
            }
            else
            {   /* sometimes a devices connects on BT level and then we request the supported services */
                AT_DeviceId deviceId = ERM_GetLastServiceDeviceId();

                if(ERM_bIsPhone(deviceId) == BT_TRUE)
                {
                    AT_DeviceId  activePhone = ERM_u8GetActivePhone();
                    if( (activePhone != AT_INVALID_DEVICE_ID) &&
                        (activePhone != deviceId) )
                    {   /* connect phone not possible due to a phone already connected */
                        _APP_SD_vInitFrameSC23();
                    }
                }
                //else if(ERM_bIsPlayer(deviceId) == BT_TRUE)
                //{
                        // no popup needed here
                //}
                else if (ERM_bIsHeadset(deviceId) == BT_TRUE)
                {
                    AT_DeviceId activeHeadset = ERM_u8GetActiveHeadSet();
                    if( (activeHeadset != AT_INVALID_DEVICE_ID) &&
                        (activeHeadset != deviceId) )
                    {   /* connect headset not possible due to headset already connected */
                        _APP_SD_vInitFrameS935();
                    }
                }
           }
           break;
        }
    }


    return SUCCESS;
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_sfHandleErmNotificationPairingFailed                     */
/**
  \brief        Handles ERM notification of failed pairing

  \return       SuccessFailType
                SUCCESS or FAIL

 */
/*----------------------------------------------------------------------------*/
SuccessFailType _APP_SD_sfHandleErmNotificationPairingFailed()
{
    DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "ErmNotPairFail in ctx = %d", gAppSdContext.pCurCtxCtrl->common.ctxId);
    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        case APP_SD_CONTEXT_S52C:
        {
        //Resolution for RT13425 & RT13568
			DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "S52C: Erm PPRS Failed");
			gAppSdContext.pCurCtxCtrl->s52C.subState = APP_SD_S52C_PPRS_FAILED;
                        _APP_SD_vInitFrameS521();

			break;
	}
        case APP_SD_CONTEXT_S52D:
        {

            /* ensure that frame S52D stays at least 1 second in fucos */
            if (APP_SD_S52D_TIMEOUT_GONE == gAppSdContext.pCurCtxCtrl->s52D.subState)
            {
                    if (BT_FALSE == _APP_SD_bPhoneContextActive())
                    {
                        _APP_SD_vReleasePhoneContext();
                    }
                    else
                    {
                        _APP_SD_vInitFrameS521();
                     }
            }
            else
            {
                gAppSdContext.pCurCtxCtrl->s52D.subState = APP_SD_S52D_PPRS_FAILED;
            }
            break;
        }
        case APP_SD_CONTEXT_S408:
        case APP_SD_CONTEXT_S517_PASSIVE:
        case APP_SD_CONTEXT_S51D_ACCEPT:
            if (BT_FALSE == _APP_SD_bPhoneContextActive())
            {
                _APP_SD_vReleasePhoneContext();
            }
            else
            {
                _APP_SD_vInitFrameS521();
            }
            break;
        case APP_SD_CONTEXT_S001:
            // RS: this event is handled by APP_DEVICE that notifies us about connect failed,
            //     so do nothing here
            //_APP_SD_vInitFrameS001(gAppSdContext.pCurCtxCtrl->s001.connectAttempt+1);
            break;
        //case APP_SD_CONTEXT_S51D:
        //    _APP_SD_vInitFrameS521();
        //    break;
        case APP_SD_CONTEXT_S933:
            if (BT_FALSE == _APP_SD_bPhoneContextActive())
            {
                _APP_SD_vReleasePhoneContext();
            }
            else
            {
                _APP_SD_vCtxHistoryStepBack();
            }
            break;
        default:
        {
            /* seems no context which is interested in this notification is currently in foreground
               This can happen cause its currently overlayed by a popup */
            AppSdCtxCtrlType *pPairFailCtx = NULL;

            /* first check if the service support update was triggered due to an action we made in the past */
            if( (pPairFailCtx = _APP_SD_pGetHistoryContext(APP_SD_CONTEXT_S408)) != NULL )
            {

                DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "HaPairFail: hist ctx %d -> marker",
                              APP_SD_CONTEXT_S408);

                pPairFailCtx->s408.subState = APP_SD_S408_RECEIVED_PAIRING_FAILED;
            }
            else if( (pPairFailCtx = _APP_SD_pGetHistoryContext(APP_SD_CONTEXT_S933)) != NULL )
            {
                DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "HaPairFail: hist ctx %d -> marker",
                              APP_SD_CONTEXT_S933);

                pPairFailCtx->s933.pprsFailed = BT_TRUE;
            }
            else
            {   /* ignore the event */

                DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "HaPairFail: ign in ctx %d",
                              gAppSdContext.pCurCtxCtrl->common.ctxId);
            }
            break;
        }
    }
    return SUCCESS;
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_sfHandleErmNotificationPairingSuccess                     */
/**
  \brief        Handles ERM notification of successful pairing.

  \return       SuccessFailType
                always SUCCESS

 */
/*----------------------------------------------------------------------------*/
SuccessFailType _APP_SD_sfHandleErmNotificationPairingSuccess(AT_DeviceId deviceId)
{
	DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "Erm Pairing Success");

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        case APP_SD_CONTEXT_S52C:
        {

            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "S52C:Erm PPRS Success");
            gAppSdContext.pCurCtxCtrl->s52C.subState = APP_SD_S52C_PPRS_RECEIVED;
            gAppSdContext.pCurCtxCtrl->s52C.deviceId = deviceId;

            break;
        }
        case APP_SD_CONTEXT_S52D:
        {
            if (APP_SD_S52D_TIMEOUT_GONE == gAppSdContext.pCurCtxCtrl->s52D.subState)
            {
                DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "S52D:Erm Timeout");
                if (gAppSdContext.pCurCtxCtrl->s52D.appDeviceType == APP_DEVICE_enTYPE_UNKNOWN)
                {

                    _APP_SD_vInitFrameS517_PASSIVE();
                }
                else
                {
                    if(BT_TRUE == ERM_vCheckforprofileId(deviceId))
                    {
                        _APP_SD_vInitFrameS408(deviceId,gAppSdContext.pCurCtxCtrl->s52D.appDeviceType);
                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "Connecting device ID %d ",deviceId);
                        gAppSdContext.bDelepairingonlyondevice = BT_TRUE;
                    }
                    else
                    {
                        _APP_SD_vInitFrameS517(deviceId,gAppSdContext.pCurCtxCtrl->s52D.appDeviceType, BT_TRUE);
                    }
                }
            }
            else
            {
            	DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "S52D:Erm PPRS Success");
                gAppSdContext.pCurCtxCtrl->s52D.subState = APP_SD_S52D_PPRS_RECEIVED;
                gAppSdContext.pCurCtxCtrl->s52D.deviceId = deviceId;
            }
            break;
        }
        default:
        {
            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "HaPairSucces: ign in ctx %d",
                    gAppSdContext.pCurCtxCtrl->common.ctxId);
            break;
        }
    }
    return SUCCESS;
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_sfHandleErmNotificationInquiryEnd                     */
/**
  \brief        Handles ERM inquiry end notification

  \return       SuccessFailType
                SUCCESS or FAIL

 */
/*----------------------------------------------------------------------------*/
SuccessFailType _APP_SD_sfHandleErmNotificationInquiryEnd()
{
    SuccessFailType result = SUCCESS;
    // check number of found devices depending on device type
    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
    {
        case APP_SD_CONTEXT_S520:
        {   /* searched for phones */
            // depending on this init frame S515 or S501
            Uint8Type numDevs = ERM_u8GetInquiryResult(APP_DEVICE_enTYPE_PHONE);
            APP_MDI_bUnmutePlayer(APP_MDI_MUTE_DEVICE_SEARCH, UNMUTE_IMMEDIATELY);
//              if((gAppSdContext.lastConnectionDevice.playerState == APP_SD_MDI_PLAY)&& \
//                 (APP_MDI_GetPlayStatus() != APP_MDI_ACT_STATE_PLAY))
//              {
//                  APP_MDI_sfSetPlayMode(APP_MDI_RESUME);
//              }
//              gAppSdContext.lastConnectionDevice.playerState = APP_SD_MDI_STOP;

            if( numDevs > 0 )
            {
                _APP_SD_vInitFrameS515(numDevs, APP_DEVICE_enTYPE_PHONE);
            }
            else
            {
                _APP_SD_vInitFrameS501();
            }
            break;
        }
        case APP_SD_CONTEXT_S581:
        {   /* searched for head set */
            // depending on this init frame S582 or S515
            Uint8Type numDevs = ERM_u8GetInquiryResult(APP_DEVICE_enTYPE_HEADSET);
            APP_MDI_bUnmutePlayer(APP_MDI_MUTE_DEVICE_SEARCH, UNMUTE_IMMEDIATELY);
//            if((gAppSdContext.lastConnectionDevice.playerState == APP_SD_MDI_PLAY)&& \
//               (APP_MDI_GetPlayStatus() != APP_MDI_ACT_STATE_PLAY))
//            {
//                APP_MDI_sfSetPlayMode(APP_MDI_RESUME);
//            }
//            gAppSdContext.lastConnectionDevice.playerState = APP_SD_MDI_STOP;
            if( numDevs > 0 )
            {
                _APP_SD_vInitFrameS515(numDevs, APP_DEVICE_enTYPE_HEADSET);
            }
            else
            {
                _APP_SD_vInitFrameS582();
            }
            break;
        }
        case APP_SD_CONTEXT_SC13:
        {   /* searched for player */
            // depending on this init frame SC07 or S515
            Uint8Type numDevs = ERM_u8GetInquiryResult(APP_DEVICE_enTYPE_PLAYER);
            APP_MDI_bUnmutePlayer(APP_MDI_MUTE_DEVICE_SEARCH, UNMUTE_IMMEDIATELY);
//              if((gAppSdContext.lastConnectionDevice.playerState == APP_SD_MDI_PLAY)&& \
//                 (APP_MDI_GetPlayStatus() != APP_MDI_ACT_STATE_PLAY))
//              {
//                  APP_MDI_sfSetPlayMode(APP_MDI_RESUME);
//              }
//              gAppSdContext.lastConnectionDevice.playerState = APP_SD_MDI_STOP;
            if( numDevs > 0 )
            {
                _APP_SD_vInitFrameS515(numDevs, APP_DEVICE_enTYPE_PLAYER);
            }
            else
            {
                _APP_SD_vInitFrameSC07();
            }
            break;
        }
        default:
        {
            //RS: check if we have a inquiry context in our history, e.g. in the case that a popup
            //    is in front
            AppSdCtxCtrlType *pInqCtx = NULL;

            if( (pInqCtx = _APP_SD_pGetHistoryContext(APP_SD_CONTEXT_S520)) != NULL )
            {
                DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "sfHaErmNotInqEnd: hist ctx %d -> marker",
                              APP_SD_CONTEXT_S520);
                switch (gAppSdContext.pCurCtxCtrl->common.ctxId)
                {
                    case APP_SD_CONTEXT_S901:
                    case APP_SD_CONTEXT_S803:
                    {
                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "sfHaErmNotInqEnd: ctx %d, end call -> start inquiry phone search",
                                      gAppSdContext.pCurCtxCtrl->common.ctxId);
                        pInqCtx->s520.subState = APP_SD_S520_START_INQUIRY_NOT_SENT;
                        break;
                    }
                    default:
                    {
                        pInqCtx->s520.inquiryEndRcvd = BT_TRUE;
                        break;
                    }
                }
            }
            else if( (pInqCtx = _APP_SD_pGetHistoryContext(APP_SD_CONTEXT_S581)) != NULL )
            {

                DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "sfHaErmNotInqEnd: hist ctx %d -> marker",
                              APP_SD_CONTEXT_S581);

                switch (gAppSdContext.pCurCtxCtrl->common.ctxId)
                {
                    case APP_SD_CONTEXT_S901:
                    case APP_SD_CONTEXT_S803:
                    {
                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "sfHaErmNotInqEnd: ctx %d, end call -> start inquiry headset search",
                                      gAppSdContext.pCurCtxCtrl->common.ctxId);
                        pInqCtx->s581.subState = APP_SD_S581_START_INQUIRY_NOT_SENT;
                        break;
                    }
                    default:
                    {
                        pInqCtx->s581.inquiryEndRcvd = BT_TRUE;
                        break;
                    }
                }
            }
            else if( (pInqCtx = _APP_SD_pGetHistoryContext(APP_SD_CONTEXT_SC13)) != NULL )
            {

                DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "sfHaErmNotInqEnd: hist ctx %d -> marker",
                              APP_SD_CONTEXT_SC13);

                switch (gAppSdContext.pCurCtxCtrl->common.ctxId)
                {
                    case APP_SD_CONTEXT_S901:
                    case APP_SD_CONTEXT_S803:
                    {
                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "sfHaErmNotInqEnd: ctx %d, end call -> start inquiry player search",
                                      gAppSdContext.pCurCtxCtrl->common.ctxId);
                        pInqCtx->sc13.subState = APP_SD_SC13_START_INQUIRY_NOT_SENT;
                        break;
                    }
                    default:
                    {
                        pInqCtx->sc13.inquiryEndRcvd = BT_TRUE;
                        break;
                    }
                }
            }
            else
            {

                DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "sfHaErmNotInqEnd: no inq ctx act/hist");
                result = FAIL;
            }
            break;
        }
    }
    return result;
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_sfHandleVcrEvent                                      */
/**
  \brief        Handles incoming VCR notification events

  \param        pVcr
                Incoming VCR notification event

  \return       SuccessFailType
                SUCCESS or FAIL

 */
/*----------------------------------------------------------------------------*/
SuccessFailType _APP_SD_sfHandleVcrEvent(const AppSdVcrEventType *pVcr)
{

    DEBUG_STATE2( APP_SD_SWI_TRC, MOD_APP_SD, "HandleVcrEvent: event $VCRNotificationIdEnum$ = %d ctxId $APP_SD_enContextId$ = %d",
                  pVcr->notId, gAppSdContext.pCurCtxCtrl->common.ctxId);

    switch(pVcr->notId)
    {
        case VCR_NOTIFY_SIVR_ACTIVATE:
        {
            switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
            {
                case APP_SD_CONTEXT_S115:
                    /* RT#6406 name tag deleted prompt sounds to early, VR is correct show screen earlier */
                    if (BT_TRUE == gAppSdContext.pCurCtxCtrl->s115.deletePressed)
                    {
                       gAppSdContext.pCurCtxCtrl->s115.deletePressed = BT_FALSE;
                       _APP_SD_vInitFrameS114(gAppSdContext.pCurCtxCtrl->s115.pbIndex);
                    }
                    else
                    {
                       _APP_SD_vInitFrameS924();
                    }
                    break;
                // depending on current context do something
                case APP_SD_CONTEXT_S117:
                {
                    // depending on selected index
                    Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(gAppSdContext.pCurCtxCtrl->common.listData));
                    switch(selIdx)
                    {
                        case 1:
                            /* Stay in S117 during Playback of voice tag */
                            if ( BT_TRUE == _APP_SD_u8VcrActive)
                            {
                                _APP_SD_vInitFrameS924();
                                _APP_SD_u8VcrActive = BT_FALSE;
                            }
                            break;
                        case 2:
                        case 3:
                        case 4:
                            /* Show S924 during recording of new voice tag */
                            _APP_SD_vInitFrameS924();
                            break;
                        default:
                            break;
                    }
                    break;
                }
                case APP_SD_CONTEXT_S405:
                    /* #4935 show SC14 only, if 'Vorlesen' is selected */
                    if(VCR_HAPTIC_READ_SMS == VCR_eGetHapticTrigTypeStatus())
                    {   /* read out sms triggered by SD */
                        _APP_SD_vInitFrameSC14(gAppSdContext.pCurCtxCtrl->s405.smsIndex);
                    }
                    else
                    {
                        _APP_SD_vInitFrameS924();
                    }
                    break;
                default:
                    // TODO: replace cur ctx if S903,...
                    _APP_SD_vInitFrameS924();
                    break;
            }
            break;
        }
        case VCR_NOTIFY_SIVR_DEACTIVATE:
        {
            if (gAppSdContext.outgoingCallViaVcrInProgress == BT_TRUE)
            {
                gAppSdContext.outgoingCallViaVcrInProgress = BT_FALSE;
                gAppSdContext.dialing_was_initiated_by_vcrOnceFlag = BT_TRUE;
                _APP_SD_vInitFrameS801_PN((const Uint8Type *)"", 1, BT_FALSE);
            }
            else
            {
                switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
                {
                    case APP_SD_CONTEXT_S117:
                    {
                        // depending on selected index
                        Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(gAppSdContext.pCurCtxCtrl->common.listData));
                        switch(selIdx)
                        {
                            case 1:
                                /* Stayed in S117 during Playback of voice tag so just
                                 * do nothing when VCR is deactivated  */
                                break;
                            case 2:
                            case 3:
                            case 4:
                              // go back to MMI screen (release context for phone)
                              if(BT_FALSE == _APP_SD_bPhoneContextActive())
                              {
                                  _APP_SD_vReleasePhoneContext();
                              }
                              else
                              {
                                  /* Go back to S117 */ // <-- NO, we are still in S117, see context switch / case !!!
                                  // #2137, if replay was pressed and down button ( one or several times, so that replay is not selected anymore, the
                                  // context is leaved via history back as soon as vcr deactivates itself
                                  // !!! if we are still in context S117, e.g. VCR was active cause of REPLAYing the current callername, we should not
                                  // go back in history here, cause we wanna stay in S117 here!!!
                                  //_APP_SD_vCtxHistoryStepBack();
                              }
                                break;
                            default:
                                break;

                        }
                        break;
                    }
                    case APP_SD_CONTEXT_S642:
                    {
                        if(BT_TRUE == KPB_bIsAsgPresentation())     // RT #1788
                        {
                          /* go again to HandleInitFrameS642 to play the current * selected ringtone in a loop */
                          gAppSdContext.pCurCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
                          gAppSdContext.pCurCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;

                          (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                              MSEC(200),
                                                              0);
                              }
                        break;
                    }
                    case APP_SD_CONTEXT_SC14:
                        if(BT_TRUE == gAppSdContext.bSmsDelete)
                        {
                            Uint16Type numSms = APP_SMS_u16GetNumReadSms() +
                                                APP_SMS_u16GetNumUnreadSms();
                            if( numSms > 0 )
                            {
                                _APP_SD_vInitFrameS404(numSms);
                            }
                            else
                            {
                                _APP_SD_vInitFrameS402();
                            }
                            gAppSdContext.bSmsDelete = BT_FALSE;
                        }
                        else
                        {
                            _APP_SD_vCtxHistoryStepBack();
                        }
                        break;
                    case APP_SD_CONTEXT_S924:
                    case APP_SD_CONTEXT_S929:
                        // go back to MMI screen (release context for phone)
                        if((gAppSdContext.ctxInView == APP_SD_UHV_ACTIVE_TRIGGER_NOT_IN_ASG_VIEW) ||(BT_FALSE == _APP_SD_bPhoneContextActive()) || (BT_FALSE == _APP_SD_bIsKl15On()))
                        {
                            _APP_SD_vReleasePhoneContextWithStepBack();
                        }
                        else
                        {
                            /* #7702: phonemenue useable during active VR */
                            Uint16Type pbSize;
                            if (BT_TRUE == gAppSdContext.bManualPbUpdateFinished)
                            {
                                pbSize = APP_PHONEBOOK_u16GetCurrentPBSize(APP_PHONEBOOK_enUsersPB);
                                if(pbSize > 0)
                                {
                                    /* show phonebook entries */
                                    _APP_SD_vInitFrameS104(pbSize);
                                }
                                else
                                {
                                    /* no entries available */
                                    _APP_SD_vInitFrameS103();
                                }
                                gAppSdContext.bManualPbUpdateFinished = BT_FALSE;
                            }
                            else
                            {
                                /* go back to context before voice reco was activated */
                                _APP_SD_vCtxHistoryStepBack();
                                /* replace (history step back) screen S408_BP*/

/*RT12983: This will be handled in history context step back */
#if 0
                                if (BT_TRUE == gAppSdContext.bPbUpdateComplete)
                                {
                                    gAppSdContext.bPbUpdateComplete = BT_FALSE;
                                    if (gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_S663_PB)
                                    {
                                        DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "HandleVcrEvent: ctx step back twice - manual pb update run and VCR started");
                                        _APP_SD_vCtxHistoryStepBack();
                                    }
                                }
                                else if ((gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_SC12) &&
                                    (AT_INVALID_DEVICE_ID != ERM_u8GetActivePlayer()))
                                {
                                    DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "HandleVcrEvent: VCR ended and SC12 before but MP arlready connected");
                                    _APP_SD_vCtxHistoryStepBack();
                                }
#endif

                                if ((gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_SC12) &&
                                    (AT_INVALID_DEVICE_ID != ERM_u8GetActivePlayer()))
                                {
                                    DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "HandleVcrEvent: VCR ended and SC12 before but MP arlready connected");
                                    _APP_SD_vCtxHistoryStepBack();
                                }
                            }
                        }
                        break;
                    default:
                        /* to nothing by default */
                        break;
                }
            }
            break;
        }
        case VCR_NOTIFY_CONTACT_AMBIGUOUS:
        {
            if(pVcr->data.contactAmb.num_ids > 0)
            {
                _APP_SD_vInitFrameSC01(&(pVcr->data.contactAmb));
            }
            else
            {
                DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "vHandleVcrEvent: no pb index avail");
            }
            break;
        }
        case VCR_NOTIFY_MULTIPLE_NUMBERS:
        {
            _APP_SD_vInitFrameS105(pVcr->data.contactUni.pbIdx);
            break;
        }
        case VCR_NOTIFY_DIAL_NUMBER_CHANGED:
        {
            /* get number from VCR and show it */
            ATPhoneNumberType number;
            Uint16Type  len  = 0;
          (void)memset(number, 0, sizeof(number));
            if(SUCCESS == VCR_sFGetCurrentPhoneNumberforDial(&number, &len))
            {
                _APP_SD_vInitFrameS929(number,len);
            }
            else
            {

                DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vHandleVcrEvent: Error reading number from VCR, notif: %d",
                               pVcr->notId);
            }
            break;
        }
        case VCR_NOTIFY_DIAL_NUMBER_DELETE:
        {
            /* get number from VCR and show it */
            ATPhoneNumberType number;
            Uint16Type  len  = 0;
          (void)memset(number, 0, sizeof(number));

            _APP_SD_vInitFrameS929(number,len);
            break;
        }
        case VCR_NOTIFY_NOT_READY:
        {
            /* VCR can not started, because flash erase in progress */
            switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
            {
                case APP_SD_CONTEXT_S115:
                  // check if VCR can be started has been made already in HandleButtonS115
                  //gAppSdContext.pCurCtxCtrl->s115.deletePressed = BT_FALSE;
                  break;
                default:
                  _APP_SD_vInitFrameS928();
                  break;
            }
            break;
        }
        default:

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vHandleVcrEvent: unsup vcr not: %d",
                          pVcr->notId);
            return FAIL;
    }
    return SUCCESS;
}


/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_sfHandleSmsEvent                                      */
/**
  \brief        Handles incoming APP_SMS notification events

  \param        pSms
                Incoming SMS notification event

  \return       SuccessFailType
                SUCCESS or FAIL

 */
/*----------------------------------------------------------------------------*/
SuccessFailType _APP_SD_sfHandleSmsEvent(const AppSdSmsEventType *pSms)
{

    DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "HandleSmsEvent: event $APP_SMS_enNotificationId$ = %d",
                  pSms->notId);

    switch(pSms->notId)
    {
        case APP_SMS_SUPPORTED:
            switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
            {
                case APP_SD_CONTEXT_S410:
                {
                    Uint16Type numSms = APP_SMS_u16GetNumReadSms() +
                                        APP_SMS_u16GetNumUnreadSms();
                    if( numSms > 0 )
                    {
                        _APP_SD_vInitFrameS404(numSms);
                    }
                    else
                    {
                        _APP_SD_vInitFrameS402();
                    }
                    break;
                }
                case APP_SD_CONTEXT_S101:
                {
                    /* add the messages menu entry */
                    if(gAppSdContext.pCurCtxCtrl->s101.messagesAvail == BT_FALSE)
                    {
                        gAppSdContext.pCurCtxCtrl->common.listData.numListElems++;
                        gAppSdContext.pCurCtxCtrl->s101.messagesAvail = BT_TRUE;

                        _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                    }
                    break;
                }
            }
            break;
        case APP_SMS_UNSUPPORTED:
            if(APP_SD_CONTEXT_S410 == gAppSdContext.pCurCtxCtrl->common.ctxId)
            {
                _APP_SD_vInitFrameS402();
            }
            break;
        case APP_SMS_NEW_SMS:
        {
            const ERMUserProfileType * userProfile = ERM_pGetActiveUserProfile();
            // do not show popup if we have not yet created the associated user profile
            // or one or more calls active
            if((NULL != userProfile) &&
               (BT_TRUE == APP_PHONE_AT_PNCC_bAllCallStatesIdle()) &&   //#2570
               (BT_FALSE == VCR_bCheckSIVRIsActive()))
            {
                // show "Neue Mitteilung"
                if( APP_SD_CONTEXT_S642 == gAppSdContext.pCurCtxCtrl->common.ctxId )
                {
                    (void)APP_DEVICE_rcStopRingtoneNonBlock();
                }
                _APP_SD_vInitFrameS903();
            }
            break;
        }
        case APP_SMS_NUMBER_OF_NEW_SMS_CHANGED:
            if( APP_SD_CONTEXT_S404 == gAppSdContext.pCurCtxCtrl->common.ctxId )
            {   /* reload list */
                _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
            }
            else if( APP_SD_CONTEXT_S903 == gAppSdContext.pCurCtxCtrl->common.ctxId )
            {
                _APP_SD_vCtxHistoryStepBack();
            }
            break;

        case APP_SMS_DELETED_SMS:
        {
            if(VCR_HAPTIC_READ_SMS == VCR_eGetHapticTrigTypeStatus())
            {
                gAppSdContext.bSmsDelete =  BT_TRUE;
            }
            switch (gAppSdContext.pCurCtxCtrl->common.ctxId)
            {
                case APP_SD_CONTEXT_S404:
                    /* reload list */
                    _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                    DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "HandleSmsEvent: Delete SMS refresh Frame S404");
                    break;
                case APP_SD_CONTEXT_S405:
                case APP_SD_CONTEXT_S413:
                case APP_SD_CONTEXT_S406:
                case APP_SD_CONTEXT_S213:
                case APP_SD_CONTEXT_S409:
                case APP_SD_CONTEXT_S428:
                case APP_SD_CONTEXT_S425:
                case APP_SD_CONTEXT_S408_USERLIST:
                {
                    Uint16Type numSms = APP_SMS_u16GetNumReadSms() +
                                        APP_SMS_u16GetNumUnreadSms();
                    if(numSms > 0)
                    {
                        _APP_SD_vInitFrameS404(numSms);
                        DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "HandleSmsEvent: Delete SMS init Frame S404 %d > 0",
                                     numSms);
                    }
                    else
                    {
                        /* no entries available */
                        _APP_SD_vInitFrameS402();
                        DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "HandleSmsEvent: Delete SMS init Frame S402 (%d)",
                                     numSms);
                    }
                    break;
                }
                default:
                    break;
            }
            break;
        }
        default:

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandleSmsEvent: unsup sms event: %d",
                          pSms->notId);
            break;
    }
    return SUCCESS;
}


/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_sfHandlePhoneEvent                                    */
/**
  \brief        Handles incoming APP_PHONE notification events

  \param        pPhone
                Incoming PHONE notification event

  \return       SuccessFailType
                SUCCESS or FAIL

 */
/*----------------------------------------------------------------------------*/
SuccessFailType _APP_SD_sfHandlePhoneEvent(const AppSdPhoneEventType *pPhone)
{

    DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "HaPhEvent: $APP_PHONE_enNotificationId$ = %d", pPhone->notId);

    switch(pPhone->notId)
    {
        case APP_PHONE_OPERATOR_NAME_CHANGED:
        case APP_PHONE_NW_SIGSTRENGHT_CHANGED:
        case APP_PHONE_ROAMING_CHANGED:
        case APP_PHONE_SERV_AVAIL_CHANGED:
        case APP_PHONE_BATT_LEVEL_CHANGED:
        case APP_PHONE_HFP_VERSION_CHANGED:       // sometimes battery symbol is not shown cause level has been received before HFP1.5 support indication. If no other PIEV arrives, battery symbol is not shown.
            if(( KPB_bIsFsgQueuedUp() != BT_TRUE )&&
                ((gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_SP18) ||
                (gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_S018)))
            {
                _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
            }
            break;
        case APP_PHONE_MIC_MUTE_CHANGED:
            switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
            {
                case APP_SD_CONTEXT_S803:
                case APP_SD_CONTEXT_S812:
                case APP_SD_CONTEXT_S815:
                case APP_SD_CONTEXT_SC24:
                    _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                    break;
                    default:
                    /* ignore the event */
                    break;
            }
            break;

        case APP_PHONE_HANDSFREE_MODE_CHANGED:
            _APP_SD_vHandleHandsFreeModeChanged();
            break;
        case APP_PHONE_HEADSET_MODE_CHANGED:
            switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
            {
                case APP_SD_CONTEXT_S801:
                case APP_SD_CONTEXT_S803:
                case APP_SD_CONTEXT_S812:
                case APP_SD_CONTEXT_S815:
                    /* refresh frame and toggle "Headset" and "Handsfree" menue text */
                    _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                    break;
                case APP_SD_CONTEXT_S901:
                    break;
                default:
                    break;
            }
            break;
        case APP_PHONE_CALL_STATE_CHANGED:      /* PLCC */
        {
            const ERMUserProfileType *pUser = ERM_pGetUserProfile_DevId(ERM_u8GetActivePhone());
            if( pUser == NULL)
            {
                /* incoming call but no profile available, create it implicitly */

                BooleanType bPlayerCoded;
                APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_ERROR_BUSY;
                const ERMBTDeviceTableType *pBtDevice = ERM_GetBTDevice(ERM_u8GetActivePhone());

                EEPROM_LAYOUT_vGetPlayerEnabled(&bPlayerCoded);

                if (bPlayerCoded && pBtDevice->a2dp_sink_supported == AT_SUPPORTED)
                {
                    rspCode = APP_DEVICE_rcActivateMdiDevice(NULL,ERM_u8GetActivePhone());

                    //connect also media player of the device in this case

                    switch(rspCode)
                    {
                        case APP_COMMON_RSP_ERROR_BUSY:
                            APP_DEVICE_vSetActivatePlayerPendingFlag(NULL, ERM_u8GetActivePhone());
                            break;
                        case APP_COMMON_RSP_OK:
                            break;
                        default:
                            break;
                    }
                }

                APP_DEVICE_vAddMissingUserProfileImplicitlyBySD();

                DEBUG_VALUE2( APP_SD_SWI_TRC, MOD_APP_SD, "HaPhEvent: implicitly create prof ctx %d (%d)",
                             gAppSdContext.pCurCtxCtrl->common.ctxId,
                             ERM_u8GetActivePhone() );



                //RS: hack to clean up the history
                _APP_SD_vCtxHistoryReset(gAppSdContext.pCurCtxCtrl);


                if (bPlayerCoded  && pBtDevice->a2dp_sink_supported == AT_SUPPORTED)
                {
                    APP_DEVICE_vAddMissingPlayerProfileImplicitlyBySD();
                }
            }

            _APP_SD_vHandleCallStateChanged();
            break;
        }
        case APP_PHONE_OUTG_CALL_INDICATION_TIMEOUT:
        {
            // process for S801 only
            switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
            {
                case APP_SD_CONTEXT_S801:
                    _APP_SD_vHandleCallStateChanged();
                    break;
                default:

                    DEBUG_VALUE2( APP_SD_SWI_TRC, MOD_APP_SD, "HaPhEvent: Ign. notId %d for ctx: %d",
                                  pPhone->notId,
                                  gAppSdContext.pCurCtxCtrl->common.ctxId );
                    break;
            }
            break;
        }

        case APP_PHONE_OUTG_CALL_ERROR:
            _APP_SD_vInitFrameS802(APP_SD_enS802_DIAL_ERROR);
            break;

        case APP_PHONE_REDIAL_DENIED_DUE_TO_EMPTY_STACK:
        {   /* redial was denied by APP_PHONE directly e.g. due to an empty call stack */
            _APP_SD_vInitFrameS802(APP_SD_enS802_DIAL_ERROR);
            break;
        }

        // Susanne: 07.08.09 Triggered now by APP_PB notification
        //case APP_PHONE_MISSED_CALLS:
        //    _APP_SD_vInitFrameS904();
        //    break;

        default:

            DEBUG_VALUE1( APP_SD_SWI_WNG, MOD_APP_SD, "HaPhEvent: unhandled event: %d",
                          pPhone->notId);
            break;
    }
    return SUCCESS;
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_sfHandlePhoneBookEvent                                */
/**
  \brief        Handles incoming APP_PHONEBOOK notification events

  \param        pPhoneBook
                Incoming PHONEBOOK notification event

  \return       SuccessFailType
                SUCCESS or FAIL

 */
/*----------------------------------------------------------------------------*/
SuccessFailType _APP_SD_sfHandlePhoneBookEvent(const AppSdPhoneBookEventType *pPhoneBook)
{

    DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "HaPbEvent: $APP_PHONE_enNotificationId$ = %d", pPhoneBook->notId);

    switch(pPhoneBook->notId)
    {
        case APP_PB_DOWNLOAD_COUNT_CHANGED:
            //if(gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_S102) /*RT13591*/
            DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "13591: Visibility on off = %d", _KPB_bGetVisbilitySetOnOff());
            if((gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_S102) && (BT_TRUE == _KPB_bGetVisbilitySetOnOff()))
            {
                // #11979
                // do not set the activate frame state to false, since a new screen
                // (e.g. idle screen , LSS OK longpress) won't be activated otherwise
                //_APP_SD_vActivateFrame(BT_FALSE, __LINE__);      //RT #3545
                _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
            }
            break;
        case APP_PB_USER_PB_UPDATE_FINISHED:
            if(gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_S102)
            {   // just refresh frame and wait for size to become available
//              _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);          //RT #908
                _APP_SD_vInitFrameS102_last();          //RT #908
            }
            break;

        // decision for the correct notifcation is made in APP_PHONEBOOK
        // pb changed:              first sync, manual sync or new pb after reconenct or after change of sorting
        // pb changed incompl. :    like above but PPBU:2 received, size > 0
        // pb not changed:          no changes after reconnect
        // pb not changed incompl.: like above but PPBU:2 received, size > 0
        // pb not available:        size is zero and PPBU:1 or PPBU:2 has been received
        case APP_PB_USERS_PB_CHANGED:
        case APP_PB_USERS_PB_CHANGED_INCOMPLETE:
        case APP_PB_USERS_PB_NOT_CHANGED:
        case APP_PB_USERS_PB_NOT_CHANGED_INCOMPLETE:
        case APP_PB_USERS_PB_NOT_AVAILABLE:
            switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
            {
                // SUSANNE: 20.10.2009
                case APP_SD_CONTEXT_SC12:
                case APP_SD_CONTEXT_SC12_2:
                    /* ignore the event if a player is connected */

                    DEBUG_VALUE2( APP_SD_SWI_WNG, MOD_APP_SD, "HaPbEvent: ignored event: %d ctx %d",
                                  pPhoneBook->notId,
                                  gAppSdContext.pCurCtxCtrl->common.ctxId);
                    break;

                // SUSANNE: uncomment this case to suppress popup
                //case APP_SD_CONTEXT_S102:
                //{
                //    // SUSANNE: As discussed with Thorsten it looks "Scheisse" when S102 is shown
                //    // for a short moment, than it is overlayed by one of the pb popups
                //    // BUT: As VW wants this POPUP here, we show it anyway.
                //    // TODO: Maybe we can show it when S102 times out, in this case we need to save the notification
                //    // to be able to show the correct popup
                //    break;
                //}

                //SUSANNE 17.10.2009 We need to change the Popup handling for phonebook notifications as
                // discussed with Lars Krämer
                // popups are allowed to be shown in any context
                //case APP_SD_CONTEXT_S104:
                //    if( BT_FALSE == gAppSdContext.manualPbSyncInProgress )
                //    {   /* show only if this was not automatic download */
                //        _APP_SD_vInitFrameSC22();
                //    }
                //    break;

                default:
                {
                    const ERMUserProfileType * profile = ERM_pGetActiveUserProfile();
                    // S930 and S923 are not shown anymore
                    if(NULL == profile)
                    {   /* do not handle if there is no active user */

                        DEBUG_VALUE1(APP_SD_SWI_WNG, MOD_APP_SD, "HaPbEvent: ign. %d, profile NULL", pPhoneBook->notId);
                        return SUCCESS;
                    }
                    // pb changed -> show SC22
                    // pb not changed but manual sync -> show SC22
                    switch(pPhoneBook->notId)
                    {
                        case APP_PB_USERS_PB_CHANGED:
                            /* successfully loaded  new pb*/
                            if( APP_SD_CONTEXT_S642 == gAppSdContext.pCurCtxCtrl->common.ctxId )
                            {
                                (void)APP_DEVICE_rcStopRingtoneNonBlock();
                            }
                            _APP_SD_vInitFrameSC22();
                            break;
                        case APP_PB_USERS_PB_CHANGED_INCOMPLETE:
                            /* incompletly loaded */
                            if( APP_SD_CONTEXT_S642 == gAppSdContext.pCurCtxCtrl->common.ctxId )
                            {
                                (void)APP_DEVICE_rcStopRingtoneNonBlock();
                            }
                            _APP_SD_vInitFrameS925();
                            break;
                        case APP_PB_USERS_PB_NOT_CHANGED:
                            // show nothing
                            break;
                        case APP_PB_USERS_PB_NOT_CHANGED_INCOMPLETE:
                            // show nothing
                            break;
                        case APP_PB_USERS_PB_NOT_AVAILABLE:
                            /* loading pb failed */
                            if( APP_SD_CONTEXT_S642 == gAppSdContext.pCurCtxCtrl->common.ctxId )
                            {
                                (void)APP_DEVICE_rcStopRingtoneNonBlock();
                            }
                            _APP_SD_vInitFrameS927();
                            break;
                        default:

                            DEBUG_TEXT(APP_SD_SWI_ERR, MOD_APP_SD, "HdlPbEv: inv. UsersPb Not.");
                            break;
                    }
                }
                break;
            }
            gAppSdContext.manualPbSyncInProgress = BT_FALSE;
            break;

        case APP_PB_MISSED_PB_CHANGED:
        /*case APP_PB_MISSED_PB_NOT_CHANGED:*/ /*RT15135: Removed because even for rejected call missed call pop is shown */
        {
            const ERMUserProfileType * userProfile = ERM_pGetActiveUserProfile();
            if( APP_PHONE_u16MissedCalls() &&
                0 < APP_PHONEBOOK_u16GetCurrentPBSize(APP_PHONEBOOK_enMissedCalls) &&
                NULL != userProfile )
            { // show popup only if we detected missed calls in TMS and missed call stack size > 0
              // and an already existing profile
                if( APP_SD_CONTEXT_S642 == gAppSdContext.pCurCtxCtrl->common.ctxId )
                {
                    (void)APP_DEVICE_rcStopRingtoneNonBlock();
                }
                _APP_SD_vInitFrameS904();
            }
            break;
        }
        /*RT15135: Removed because even for rejected call missed call pop is shown */
        /* Ignore this notification */
        case APP_PB_MISSED_PB_NOT_CHANGED:
            DEBUG_VALUE1(APP_SD_SWI_WNG, MOD_APP_SD, "HaPbEvent: unhandled event: %d", pPhoneBook->notId);
            break;
        case APP_PB_MISSED_CALLS_RESET_BY_HMI:
            switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
            {
                case APP_SD_CONTEXT_S904:
                  // we do not need to signal this any longer cause missed calls where watched e.g. via headunit
                  _APP_SD_vCtxHistoryStepBack();
                  break;
            }
            break;
        case APP_PB_SORTING_TIMED_OUT:
            // update pb after sync failed, show info for user and cancel Please wait frame
            _APP_SD_vInitFrameS927();
            break;

        case APP_PB_RECEIVED_PB_CHANGED:          // RT #4184
        case APP_PB_DIALED_PB_CHANGED:
            if(gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_S211)
            {
                Uint16Type pbSize = 0;
                pbSize = APP_PHONEBOOK_u16GetCurrentPBSize(gAppSdContext.pCurCtxCtrl->s211.pbType);
                if(pbSize > 0)
                {
                    _APP_SD_vInitFrameS211(gAppSdContext.pCurCtxCtrl->s211.pbType, pbSize);
                }
                else
                {
                    /* no entries available */
                    _APP_SD_vInitFrameS103();
                }
            }
            break;
        default:

            DEBUG_VALUE1(APP_SD_SWI_WNG, MOD_APP_SD, "HaPbEvent: unhandled event: %d", pPhoneBook->notId);
            break;
    }

    return SUCCESS;
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_sfHandleTimeoutEvent                                  */
/**
  \brief        Handles incoming Timeout events

  \brief        Description:\n
                Some frames can have a timeout (e.g. Popups). It this timeout
                expired an timeout event is generated. Depending on the
                current CtxId the next action is triggerd.

  \param        pTimeout
                Pointer to the incoming Timeout event

  \return       SuccessFailType
                SUCCESS or FAIL

 */
/*----------------------------------------------------------------------------*/
SuccessFailType _APP_SD_sfHandleTimeoutEvent(const AppSdTimeoutEventType *pTimeout)
{
    APP_SMS_enSupportState smsSupport;
    Uint16Type numSms;
    Uint16Type pbSize;

    DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "HandleTimeoutEvent: ctx $APP_SD_enContextId$ = %d",
                  pTimeout->ctxId);

    if(gAppSdContext.pCurCtxCtrl->common.ctxId == pTimeout->ctxId)
    {
        switch(pTimeout->ctxId)
        {
            case APP_SD_CONTEXT_S001:
                //gAppSdContext.pCurCtxCtrl->s001.subState = APP_SD_S001_CONNECT_NOT_SENT;
                //gAppSdContext.pCurCtxCtrl->s001.connectAttempt++;
                //_APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                if(gAppSdContext.pCurCtxCtrl->s001.abort == BT_TRUE)
                {
                  _APP_SD_vInitFrameS001(gAppSdContext.pCurCtxCtrl->s001.connectAttempt);
                }
                else
                {
                  _APP_SD_vInitFrameS001(gAppSdContext.pCurCtxCtrl->s001.connectAttempt+1);
                }
                break;
//            case APP_SD_CONTEXT_SC17:
//                _APP_SD_vInitFrameS007(gAppSdContext.pCurCtxCtrl->sc17.deviceId);
//                break;
            case APP_SD_CONTEXT_S663_PB:
                // update pb after sync failed, show info for user and cancel Please wait frame
                _APP_SD_vInitFrameS927();
                break;
            case APP_SD_CONTEXT_S103:		//RT 2376
            case APP_SD_CONTEXT_S408:
            case APP_SD_CONTEXT_S428:
            case APP_SD_CONTEXT_S501:
            case APP_SD_CONTEXT_S521:
//            case APP_SD_CONTEXT_S532:   // RT 2557
            case APP_SD_CONTEXT_S533:
            case APP_SD_CONTEXT_S566:
            case APP_SD_CONTEXT_S568:
            case APP_SD_CONTEXT_S573:
            case APP_SD_CONTEXT_S582:
            case APP_SD_CONTEXT_S599:
            case APP_SD_CONTEXT_S664:
			case APP_SD_CONTEXT_S804:		// RT 12883
            case APP_SD_CONTEXT_S806:
            case APP_SD_CONTEXT_S807:
            case APP_SD_CONTEXT_S814:
            case APP_SD_CONTEXT_S917:
            case APP_SD_CONTEXT_S923:
//              case APP_SD_CONTEXT_S925:		//RT #3545
//              case APP_SD_CONTEXT_S927:		//RT #3545
            case APP_SD_CONTEXT_S928:
            case APP_SD_CONTEXT_S930:
            case APP_SD_CONTEXT_S934:
            case APP_SD_CONTEXT_S935:
            case APP_SD_CONTEXT_SC04:
            case APP_SD_CONTEXT_SC07:
            case APP_SD_CONTEXT_SC23:
                /* these frames need only simple stepBack handling */
                _APP_SD_vCtxHistoryStepBack();
                break;
            case APP_SD_CONTEXT_SC12:           //RT #8072
            case APP_SD_CONTEXT_SC12_2:         //RT #8072
                if(AT_INVALID_DEVICE_ID != ERM_u8GetActivePlayer())
                {
                   _APP_SD_vInitFrameS574(ERM_u8GetActivePlayer());
                }
                else
                {
                   _APP_SD_vInitFrameS518();
                }
                break;
            case APP_SD_CONTEXT_S533_2:
//                _APP_SD_vInitFrameS502();
                _APP_SD_vCtxHistoryStepBack();
                _APP_SD_vCtxHistoryStepBack();
                _APP_SD_vCtxHistoryStepBack();
                break;

            case APP_SD_CONTEXT_S565:
                _APP_SD_vCtxHistoryStepBack();
                break;
            case APP_SD_CONTEXT_S425:
                /* SMS */
                smsSupport = APP_SMS_enGetSmsSupportState();
                switch( smsSupport)
                {
                    case APP_SMS_NOT_INITIALIZED:
                        // wait for intialization to be finished
                        _APP_SD_vInitFrameS410();
                        break;
                    case APP_SMS_INITIALIZED_AND_UNSUPPORTED:
                        /* no entries available */
                        _APP_SD_vInitFrameS402();
                        break;
                    case APP_SMS_INITIALIZED_AND_SUPPORTED:
                    {
                        numSms = APP_SMS_u16GetNumReadSms() +
                                 APP_SMS_u16GetNumUnreadSms();
                        if(numSms > 0)
                        {
                            _APP_SD_vInitFrameS404(numSms);
                        }
                        else
                        {
                            /* no entries available */
                            _APP_SD_vInitFrameS402();
                        }
                        break;
                    }
                    default:
                        /* no entries available */
                        _APP_SD_vInitFrameS402();
                        break;
                }
                break;
            case APP_SD_CONTEXT_S402:
                _APP_SD_vInitFrameS101();
                break;
            case APP_SD_CONTEXT_S574:
            case APP_SD_CONTEXT_S408_ABR:
            case APP_SD_CONTEXT_S408_USERLIST:
            case APP_SD_CONTEXT_S408_PLAYER:
                  //if((gAppSdContext.lastConnectionDevice.playerState == APP_SD_MDI_PLAY)&& \
                  //   (APP_MDI_GetPlayStatus() != APP_MDI_ACT_STATE_PLAY))
                  //{
                  //    APP_MDI_sfSetPlayMode(APP_MDI_RESUME);
                  //}
                  //gAppSdContext.lastConnectionDevice.playerState = APP_SD_MDI_STOP;
                /* unmute of player handled in InitIdleScreen */
                _APP_SD_vInitIdleScreen(0);
                break;
            case APP_SD_CONTEXT_S408_DEL:
                switch(gAppSdContext.deleteActionPressedinScreen)
                {
                    case APP_SD_CONTEXT_S513:
                        _APP_SD_vInitFrameS514( gAppSdContext.s408DelDeviceId,
                                                BT_FALSE,
                                                gAppSdContext.s408DelDeviceName,
                                                gAppSdContext.s408DelDeviceNameLength);
                        break;
                    case APP_SD_CONTEXT_S555:
                        _APP_SD_vInitFrameS514( gAppSdContext.s408DelDeviceId,
                                                BT_TRUE,
                                                gAppSdContext.s408DelDeviceName,
                                                gAppSdContext.s408DelDeviceNameLength);
                        break;
                    case APP_SD_CONTEXT_S576:
                        _APP_SD_vInitFrameS578( gAppSdContext.s408DelDeviceId,
                                                gAppSdContext.pCurCtxCtrl->s576.deviceType,
                                                gAppSdContext.s408DelDeviceName,
                                                gAppSdContext.s408DelDeviceNameLength);
                        break;
                    case APP_SD_CONTEXT_S579:
                        _APP_SD_vInitFrameS578( gAppSdContext.s408DelDeviceId,
                                                gAppSdContext.pCurCtxCtrl->s579.deviceType,
                                                gAppSdContext.s408DelDeviceName,
                                                gAppSdContext.s408DelDeviceNameLength);
                        break;
                    default:
                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "handletimeoutevent: deleteActionPressedinScreen: %d not expected here show idlescreen",
                                      gAppSdContext.deleteActionPressedinScreen);
                        _APP_SD_vInitIdleScreen(0);
                        break;
                }
                gAppSdContext.deleteActionPressedinScreen = APP_SD_CONTEXT_INVALID;
                ERM_DeleteDeviceIfPpdeTimeout(gAppSdContext.s408DelDeviceId);
                break;
            case APP_SD_CONTEXT_S102:
                /* PHONEBOOK */
                pbSize = APP_PHONEBOOK_u16GetCurrentPBSize(APP_PHONEBOOK_enUsersPB);
                if(pbSize > 0)
                {
                    /* show phonebook entries */
                    _APP_SD_vInitFrameS104(pbSize);
                }
                else
                {
                    /* no entries available */
                    _APP_SD_vInitFrameS103();
                }
                gAppSdContext.bManualPbUpdateFinished = BT_FALSE; // RT #5847
                break;
//              case APP_SD_CONTEXT_S103:				//RT 2376http://rt02.s1nn.int/rt/Ticket/Display.html
//                  _APP_SD_vInitFrameS201();         // RT #1416
//                  break;
            case APP_SD_CONTEXT_S554:
            case APP_SD_CONTEXT_S927:		//RT #3545
            case APP_SD_CONTEXT_S925:
            case APP_SD_CONTEXT_SA01:
            case APP_SD_CONTEXT_SA02:
            case APP_SD_CONTEXT_SA03:
            {
                if((BT_FALSE == _APP_SD_bPhoneContextActive()) &&
                   (BT_FALSE == VCR_bCheckSIVRIsActive()) &&
                   (BT_TRUE == APP_PHONE_AT_PNCC_bAllCallStatesIdle()))  /*RT14798*/
                {
                    _APP_SD_vReleasePhoneContext();
                }
                else
                {
                    //SUSANNE: 19.10.2009 Due to new popup handling step back and do not show PB
                    _APP_SD_vCtxHistoryStepBack();
                }
                break;
            }
            case APP_SD_CONTEXT_SC22:
            {
                if ((BT_TRUE == gAppSdContext.bManualPbUpdateFinished) &&
                    (BT_FALSE == VCR_bCheckSIVRIsActive()))  /*RT #7702 */
                {
                    pbSize = APP_PHONEBOOK_u16GetCurrentPBSize(APP_PHONEBOOK_enUsersPB);

                    if(BT_FALSE == _APP_SD_bPhoneContextActive())
                    {
                        _APP_SD_vReleasePhoneContext();
                    }
                    if(pbSize > 0)
                    {
                        /* show phonebook entries */
                        if (NULL != _APP_SD_pGetHistoryContext(APP_SD_CONTEXT_S642))//RT15182
                                APP_DEVICE_rcStopRingtoneNonBlock();
                        _APP_SD_vInitFrameS104(pbSize);
                        gAppSdContext.bManualPbUpdateFinished = BT_FALSE;
                    }
                    else
                    {
                        /* no entries available */
                        _APP_SD_vInitFrameS103();
                        gAppSdContext.bManualPbUpdateFinished = BT_FALSE;
                    }
                }
                else
                {
                    if((BT_FALSE == _APP_SD_bPhoneContextActive()) &&
                       (BT_FALSE == VCR_bCheckSIVRIsActive()))
                    {
                        _APP_SD_vReleasePhoneContext();
                        gAppSdContext.bManualPbUpdateFinished = BT_FALSE;
                    }
                    else
                    {
                        //SUSANNE: 19.10.2009 Due to new popup handling step back and do not show PB
                        _APP_SD_vCtxHistoryStepBack();
                    }
                }
                break;
            }
            case APP_SD_CONTEXT_S301:
                _APP_SD_vInitFrameS305();
                break;
            case APP_SD_CONTEXT_S114:
            case APP_SD_CONTEXT_S116:
                /* loop will be detected */
                _APP_SD_vInitFrameS117(gAppSdContext.pCurCtxCtrl->s116.pbIndex);
                break;
            case APP_SD_CONTEXT_S511:
                _APP_SD_vInitFrameS512((Uint8Type)ERM_u16GetNumberOfUserProfiles(),gAppSdContext.pendingProfile.deviceId);
                break;
            case APP_SD_CONTEXT_S518:
                APP_MDI_bUnmutePlayer(APP_MDI_MUTE_DEVICE_CONNECT, UNMUTE_IMMEDIATELY);
                _APP_SD_vCtxHistoryStepBack();
                break;
            case APP_SD_CONTEXT_S522:
                if(gAppSdContext.pCurCtxCtrl->s522.lastCtxId == APP_SD_CONTEXT_SC03)
                {
                  _APP_SD_vInitFrameSC13();
                }
                else if(gAppSdContext.pCurCtxCtrl->s522.lastCtxId == APP_SD_CONTEXT_S562)
                {
                  _APP_SD_vInitFrameS581();
                }
                else if(gAppSdContext.pCurCtxCtrl->s522.lastCtxId == APP_SD_CONTEXT_S502)
                {
                    //start search only if car speed is slowwer than 5 km/h
                    if( APP_CAN_Speed_un16CurrentVehicleSpeed() < U16_SPEED_LIMIT_LOW )
                    {
                        _APP_SD_vInitFrameS520();
                    }
                    else
                    {
                        //show popup
                        _APP_SD_vInitFrameS407();
                    }
                }
                else if((gAppSdContext.pCurCtxCtrl->s522.lastCtxId == APP_SD_CONTEXT_S542) || \
                        (gAppSdContext.pCurCtxCtrl->s522.lastCtxId == APP_SD_CONTEXT_S571) || \
                        (gAppSdContext.pCurCtxCtrl->s522.lastCtxId == APP_SD_CONTEXT_S408))
                {
                  _APP_SD_vInitFrameS517( gAppSdContext.pCurCtxCtrl->s522.deviceId,
                                          gAppSdContext.pCurCtxCtrl->s522.deviceType,
                                          gAppSdContext.pCurCtxCtrl->s522.bConnect);
                }
                else if(gAppSdContext.pCurCtxCtrl->s522.lastCtxId == APP_SD_CONTEXT_S002)
                {
                    if(gAppSdContext.pCurCtxCtrl->s522.enMuteReason == APP_SD_MDI_MUTE_FOR_CONNECT)
                    {
                        _APP_SD_vInitFrameS001(0);
                    }
                    else
                    {
                        _APP_SD_vInitFrameS520();
                    }
                }
                else if((gAppSdContext.pCurCtxCtrl->s522.lastCtxId == APP_SD_CONTEXT_S541) || \
                        (gAppSdContext.pCurCtxCtrl->s522.lastCtxId == APP_SD_CONTEXT_S541_2))/* bugfix for RT #6317, TB */
                {
                    _APP_SD_vInitFrameS517( gAppSdContext.pCurCtxCtrl->s522.deviceId,
                                            gAppSdContext.pCurCtxCtrl->s522.deviceType,
                                            gAppSdContext.pCurCtxCtrl->s522.bConnect);
                }
                else if((gAppSdContext.pCurCtxCtrl->s522.lastCtxId == APP_SD_CONTEXT_S515) || \
                        (gAppSdContext.pCurCtxCtrl->s522.lastCtxId == APP_SD_CONTEXT_S572))
                {
                    if(gAppSdContext.pCurCtxCtrl->s522.enMuteReason == APP_SD_MDI_MUTE_FOR_CONNECT)
                    {
                        _APP_SD_vInitFrameS517( gAppSdContext.pCurCtxCtrl->s522.deviceId,
                                                gAppSdContext.pCurCtxCtrl->s522.deviceType,
                                                gAppSdContext.pCurCtxCtrl->s522.bConnect);
                    }
                    else
                    {
                        _APP_SD_vInitFrameS408_SSP( gAppSdContext.pCurCtxCtrl->s522.deviceId,\
                                gAppSdContext.pCurCtxCtrl->s522.deviceType);
                    }
                }
                else
                {
                    /* bugfix for RT #6317, TB */
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandleTimeoutEvent: no following jump defined in Timeout ctxId %d",
                                  gAppSdContext.pCurCtxCtrl->s522.lastCtxId);
                    _APP_SD_vInitIdleScreen(0);
                }
                break;
            case APP_SD_CONTEXT_S543:
                /* don't do InitFrameS541 to go back, since we step into S543 from APP_SD_CONTEXT_S515 too */
                //_APP_SD_vInitFrameS541(ERM_u16GetNumberOfUserProfiles());
                _APP_SD_vCtxHistoryStepBack();
                break;
            case APP_SD_CONTEXT_S514:
                /* check if we needed to delete a user cause we want to create a new one */
                if( BT_TRUE == gAppSdContext.pendingProfile.bPending)
                {
                    /* give the new user a name and create the profile */
                    //_APP_SD_vInitFrameS535(gAppSdContext.pendingProfile.deviceId);
                    _APP_SD_vInitFrameS534(gAppSdContext.pendingProfile.deviceId);
                    (void)_APP_SD_vResetPendingProfile();
                }
                else
                {   /* go back to list of paired users or S002 if active user was deleted */
                    if( BT_TRUE == gAppSdContext.pCurCtxCtrl->s514.bIsActive )
                    {   // deleted user was active
                        //RS: replaced because the handling is contained in InitIdleScreen
                          //_APP_SD_vInitFrameS002();
                          //if((gAppSdContext.lastConnectionDevice.playerState == APP_SD_MDI_PLAY)&& \
                          //   (APP_MDI_GetPlayStatus() != APP_MDI_ACT_STATE_PLAY))
                          //{
                          //    APP_MDI_sfSetPlayMode( /*NULL, */APP_MDI_RESUME);
                          //}
                          //gAppSdContext.lastConnectionDevice.playerState = APP_SD_MDI_STOP;
                        _APP_SD_vInitIdleScreen(0);
                    }
                    else
                    {   // deleted user was not active
                        _APP_SD_vInitFrameS541((Uint8Type)ERM_u16GetNumberOfUserProfiles());
                    }
                }
                break;
            //case APP_SD_CONTEXT_S518:
            case APP_SD_CONTEXT_S539:
            case APP_SD_CONTEXT_S802:   // RT #3811
            {
                _APP_SD_vInitIdleScreen(0);
                break;
            }
            case APP_SD_CONTEXT_S578:
            {
                // depending on device type and if the last device of
                // device type was deleted, go to next context
                Uint16Type numProfiles = 0;
                switch( gAppSdContext.pCurCtxCtrl->s578.deviceType )
                {
                    case APP_DEVICE_enTYPE_HEADSET:
                        numProfiles = ERM_u16GetNumberOfHeadsetProfiles();
                        if( 0 < numProfiles )
                        {
                            _APP_SD_vInitFrameS567((Uint8Type)numProfiles);
                        }
                        else
                        {
                            _APP_SD_vInitFrameS562();
                        }
                        break;
                    case APP_DEVICE_enTYPE_PLAYER:
                        numProfiles = ERM_u16GetNumberOfPlayerProfiles();
                        if( 0 < numProfiles )
                        {
                            _APP_SD_vInitFrameS5B2((Uint8Type)numProfiles);
                        }
                        else
                        {
                            _APP_SD_vInitFrameSC03(0);
                        }
                        break;
                    default:
                        /* bugfix for RT #6317, TB */
                        DEBUG_VALUE2( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandleTimeoutEvent: no following jump defined in Timeout ctxId %d and deviceType %d",
                                      pTimeout->ctxId, gAppSdContext.pCurCtxCtrl->s578.deviceType);
                        _APP_SD_vInitIdleScreen(0);
                        break;
                }
                break;
            }
            case APP_SD_CONTEXT_S914:
                gAppSdContext.bManualPbUpdateFinished = BT_FALSE; // RT #5847
                if(BT_FALSE == _APP_SD_bPhoneContextActive())
                {
                    _APP_SD_vReleasePhoneContext();
                }
                else
                {
                    /* this can happen asynchonously */
                    // Ticket #4502 we should not jump into IdleScreen if there is a search active cause this will lead to errors
                    // when user retriggers a search from S002 or player menu  */
                    Sint16Type phoneSearchHistIndex     = _APP_SD_s16GetHistoryIndex(APP_SD_CONTEXT_S520);  // phoneSearch
                    Sint16Type playerSearchHistIndex    = _APP_SD_s16GetHistoryIndex(APP_SD_CONTEXT_SC13);  // playerSearch
                    Sint16Type mpPhConnectHistIndex     = _APP_SD_s16GetHistoryIndex(APP_SD_CONTEXT_S51D);  // pin entry
//                    Sint16Type playerNameHistIndex      = _APP_SD_s16GetHistoryIndex(APP_SD_CONTEXT_S580);  // player name
                    // TODO: might be activated if headset feature is clarified:
                    // Sint16Type headsetSearchHistIndex   = _APP_SD_s16GetHistoryIndex(APP_SD_CONTEXT_S581);  // headsetSearch

                    /* player or headset was disconnected, check if we have a phone connected or not */
                    if((AT_INVALID_DEVICE_ID == ERM_u8GetActivePhone()) &&
                       (phoneSearchHistIndex == -1) && (playerSearchHistIndex == -1) && (mpPhConnectHistIndex == -1) /*&& (playerNameHistIndex == -1)*/)
                    {   /* no phone connected, but also no phone nor player search in progress */
                        _APP_SD_vInitIdleScreen(0);
                    }
                    else
                    {   /* still a phone conencted or player / phone search in progress, step back */
                        _APP_SD_vCtxHistoryStepBack();
                    }
                }
                break;
            case APP_SD_CONTEXT_S913:
            {
                /* this can happen asynchonously */
                // Ticket #4502 we should not jump into IdleScreen if there is a search active cause this will lead to errors
                // when user retriggers a search from S002 or player menu  */
                Sint16Type phoneSearchHistIndex     = _APP_SD_s16GetHistoryIndex(APP_SD_CONTEXT_S520);  // phoneSearch
                Sint16Type playerSearchHistIndex    = _APP_SD_s16GetHistoryIndex(APP_SD_CONTEXT_SC13);  // playerSearch
                // TODO: might be activated if headset feature is clarified:
                // Sint16Type headsetSearchHistIndex   = _APP_SD_s16GetHistoryIndex(APP_SD_CONTEXT_S581);  // headsetSearch

                gAppSdContext.bManualPbUpdateFinished = BT_FALSE; // RT #5847
                if((phoneSearchHistIndex != -1) ||
                    playerSearchHistIndex != -1 )
                {   /* phone or player search in progress when popup arrives */
                    _APP_SD_vCtxHistoryStepBack();
                }
                else
                {
                    _APP_SD_vInitIdleScreen(0);
                }
                break;
            }
            case APP_SD_CONTEXT_S597:
                /* here the disconnect of the phone was explicitly triggered by the user, so initIdle screen is ok */
                //RT: #4001
                _APP_SD_vInitIdleScreen(0);
                break;
            case APP_SD_CONTEXT_S663:
              {
                ATPhoneBookDwnlState dwldState  = APP_PHONEBOOK_enGetPBDwldState();
                /* same handling no matter if manual sync or automatic download */
                if( AT_PB_LOADING == dwldState )
                {   /* currently loading */
                  _APP_SD_vInitFrameS102();
                }
                else
                {   /* loading finished */
                    _APP_SD_vInitFrameS102_last();
                }
                break;
              }
            case APP_SD_CONTEXT_S517:
            {
                DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "Handletimeout S517: release context in APP_DEVICE");
                APP_DEVICE_vEmergencyReleaseContextFromAppSd();
                _APP_SD_vInitFrameS518();

                break;
            }
            case APP_SD_CONTEXT_S517_PASSIVE:
            {
                DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "Handletimeout S517_PASSIVE: timeout");
                _APP_SD_vInitFrameS518();
                break;
            }
            case APP_SD_CONTEXT_S916:
            case APP_SD_CONTEXT_S942:
                /* SD display off */
                /* shutdown is handled in KPB after APP_CSHDL notification */

                _APP_SD_vReleasePhoneContext();
                break;
            case APP_SD_CONTEXT_S408_PRECALL:
                /* in case no PLCC is received after 10 sec. */
                gAppSdContext.preCallStateIsActive = BT_FALSE;
                _APP_SD_vCtxHistoryStepBack();
                break;
            case APP_SD_CONTEXT_S534:
                if(gAppSdContext.pCurCtxCtrl->s534.subState == APP_SD_S534_WAIT_FOR_TIMEOUT)
                {
                    _APP_SD_vInitFrameS534(gAppSdContext.pCurCtxCtrl->s534.deviceId);
                }
                else
                {
                    DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "Handletimeout APP_SD_CONTEXT_S534: stucked with creating profile ... ");
                    _APP_SD_vInitIdleScreen(0);
                }
                break;

            case APP_SD_CONTEXT_S52C:
            {
            	 /* screen s52C should stay visible for at least 1 second. The
				 * screen is closed if the timeout is gone or we received the
				 * positive/negative pairing notification from ERM.
				 */
				if (APP_SD_S52C_PPRS_RECEIVED == gAppSdContext.pCurCtxCtrl->s52C.subState)
				{
					if (gAppSdContext.pCurCtxCtrl->s52C.appDeviceType == APP_DEVICE_enTYPE_UNKNOWN)
					{
						_APP_SD_vInitFrameS517_PASSIVE();
					}
					else
					{
						DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "S52C: In Timeout, PPRS Success");

						if(BT_TRUE == ERM_vCheckforprofileId(gAppSdContext.pCurCtxCtrl->s52C.deviceId))
						{
						    _APP_SD_vInitFrameS408(gAppSdContext.pCurCtxCtrl->s52C.deviceId,gAppSdContext.pCurCtxCtrl->s52C.appDeviceType);
						    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "Connecting device ID %d ",
						            gAppSdContext.pCurCtxCtrl->s52C.deviceId);
						    gAppSdContext.bDelepairingonlyondevice =BT_TRUE;
						}
						else
						{
						    _APP_SD_vInitFrameS517(gAppSdContext.pCurCtxCtrl->s52C.deviceId,gAppSdContext.pCurCtxCtrl->s52C.appDeviceType, BT_TRUE);
						}
					}
				}
				else if (APP_SD_S52C_PPRS_FAILED == gAppSdContext.pCurCtxCtrl->s52C.subState)
				{
					if (BT_FALSE == _APP_SD_bPhoneContextActive())
					{
						_APP_SD_vReleasePhoneContext();
					}
					else
					{
						DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "S52C: In Timeout PPRS, Failed");
						_APP_SD_vInitFrameS518();
					}
				}
				else
				{
					DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "S52C: In Timeout, Gone");
					_APP_SD_vInitFrameS52D(gAppSdContext.pCurCtxCtrl->s52C.deviceId, gAppSdContext.pCurCtxCtrl->s52C.appDeviceType);
				}
				break;
            }
            case APP_SD_CONTEXT_S52D:
            {
                /* screen s52D should stay visible for at least 1 second. The
                 * screen is closed if the timeout is gone or we received the
                 * positive/negative pairing notification from ERM.
                 */
                if (APP_SD_S52D_PPRS_RECEIVED == gAppSdContext.pCurCtxCtrl->s52D.subState)
                {
                    if (gAppSdContext.pCurCtxCtrl->s52D.appDeviceType == APP_DEVICE_enTYPE_UNKNOWN)
                    {
                        _APP_SD_vInitFrameS517_PASSIVE();
                    }
                    else
                    {
                        if(BT_TRUE== ERM_vCheckforprofileId(gAppSdContext.pCurCtxCtrl->s52D.deviceId))
                        {
                            _APP_SD_vInitFrameS408(gAppSdContext.pCurCtxCtrl->s52D.deviceId,gAppSdContext.pCurCtxCtrl->s52D.appDeviceType);
                            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "Connecting device ID %d within context of S408",
                                    gAppSdContext.pCurCtxCtrl->s52D.deviceId);
                            gAppSdContext.bDelepairingonlyondevice =BT_TRUE;
                        }
                        else
                        {
                            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "Connecting device ID %d within context of S517",
                                                                gAppSdContext.pCurCtxCtrl->s52D.deviceId);
                            _APP_SD_vInitFrameS517(gAppSdContext.pCurCtxCtrl->s52D.deviceId,gAppSdContext.pCurCtxCtrl->s52D.appDeviceType, BT_TRUE);
                        }
                    }
                }
                else if (APP_SD_S52D_PPRS_FAILED == gAppSdContext.pCurCtxCtrl->s52D.subState)
                {
                    if (BT_FALSE == _APP_SD_bPhoneContextActive())
                    {
                        _APP_SD_vReleasePhoneContext();
                    }
                    else
                    {
                        _APP_SD_vInitFrameS521();
                    }
                }
                else
                {
                    gAppSdContext.pCurCtxCtrl->s52D.subState = APP_SD_S52D_TIMEOUT_GONE;
                }
                break;
            }
            default:

                DEBUG_VALUE1( APP_SD_SWI_DBG, MOD_APP_SD, "HandleTimeoutEvent: : ctxId %d not handled",
                              pTimeout->ctxId);

                break;
        }
    }
    else
    {

        DEBUG_VALUE2( APP_SD_SWI_ERR, MOD_APP_SD, "HandleTimeoutEvent: timeout ctxId %d != current ctxId %d",
                      pTimeout->ctxId,
                      gAppSdContext.pCurCtxCtrl->common.ctxId );
    }

    return SUCCESS;
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_sfHandleButtonEvent                                   */
/**
  \brief        Handles incoming Button events

  \param        pButton
                Pointer to an incoming Button event

  \return       SuccessFailType
                SUCCESS or FAIL

 */
/*----------------------------------------------------------------------------*/
SuccessFailType _APP_SD_sfHandleButtonEvent(AppSdBtnEventType *pButton)
{
    if(KPB_bIsKeyAssigned(pButton->id) == BT_FALSE)
    {
        // RS: added check of gAppSdContext.activate to make really sure that the button has to be evaluated
        //     because it can happen that we are between the switch of 2 frames and KPB_bIsAsgPresentation()
        //     returns false
        //     maybe it is sufficient to just check gAppSdContext.activate
        if(!(_APP_SD_bPhoneContextActive())||(gAppSdContext.ctxInView == APP_SD_UHV_ACTIVE_TRIGGER_NOT_IN_ASG_VIEW)) //&& (gAppSdContext.activate != BT_TRUE)) //after discussion with T.Brust: activate not necessary here
        {
            /* special handling for Hook, SOS, Service and Pannen -> RT 3122 */

            DEBUG_VALUE2( APP_SD_SWI_TRC, MOD_APP_SD, "HaBtnEv: key %d (%d), special handling",
                          pButton->id,
                          pButton->pressType);

            switch(pButton->id)
            {
                case enLogiButManVirtualButtonInfo:
                    /* Info-Ruf */
                    (void)_APP_SD_vSetCtxHistoryState(APP_SD_WAIT_BACK_TO_ASG_MENU, __LINE__);
                    _APP_SD_vInitFrameSA01();
                    break;
                case enLogiButManVirtualButtonService:
                    /* Pannen-Ruf */
                    (void)_APP_SD_vSetCtxHistoryState(APP_SD_WAIT_BACK_TO_ASG_MENU, __LINE__);
                    _APP_SD_vInitFrameSA02();
                    break;
                case enLogiButManVirtualButtonSos:
                    /* SOS-Ruf */
                    (void)_APP_SD_vSetCtxHistoryState(APP_SD_WAIT_BACK_TO_ASG_MENU, __LINE__);
                    _APP_SD_vInitFrameSA03();
                    break;
                case enLogiButManMflHook:
                    _APP_SD_vActivateFrame(BT_TRUE, __LINE__);
                    (void)_APP_SD_vSetCtxHistoryState(APP_SD_UHV_IN_ASG_VIEW, __LINE__);
                    if( (pButton->pressType == enLogiButManLongPress) && (AT_INVALID_DEVICE_ID == ERM_u8GetActivePhone()))
                    {
                        _APP_SD_vInitFrameS001(0);
                    }
                    else
                    {
                        if (_APP_SD_bCurrentFrameStaysActiveWhenNotInPhoneContext())
                        {
                                _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                        }
                        else
                        {
                                _APP_SD_vInitIdleScreen(0);

                        }
                    }
                    break;
                default:

                    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "HaBtnEv: key %d not assigned",
                                  pButton->id);
                    break;
            }
        }
        else
        {

            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "HaBtnEv: key %d not assigned (2)",
                          pButton->id);
        }
    }
    else
    {
        switch(pButton->id)
        {
            case enLogiButManVirtualButtonInfo:
                /* Info-Ruf */
                switch(pButton->pressType)
                {
                    case enLogiButManLongPress:
                        _APP_SD_vInitFrameS801_PN(gAppSdContext.prompts[APP_SD_en_S801_ta_call_info_1_Zeile_1],
                                                  gAppSdContext.prompts_len[APP_SD_en_S801_ta_call_info_1_Zeile_1],
                                                  BT_FALSE);
                        break;
                    case enLogiButManShortPressAtSingleFunction:
                        if(APP_SD_CONTEXT_S642 == gAppSdContext.pCurCtxCtrl->common.ctxId)
                        {
                            (void)APP_DEVICE_rcStopRingtoneNonBlock();
                        }
                        _APP_SD_vInitFrameSA01();
                        break;
                    default:
                        break;
                }
                break;
            case enLogiButManVirtualButtonService:
                /* Pannen-Ruf */
                switch(pButton->pressType)
                {
                    case enLogiButManLongPress:
                        _APP_SD_vInitFrameS801_PN(gAppSdContext.prompts[APP_SD_en_S801_ta_call_service_1_Zeile_1],
                                                  gAppSdContext.prompts_len[APP_SD_en_S801_ta_call_service_1_Zeile_1],
                                                  BT_FALSE);
                        break;
                    case enLogiButManShortPressAtSingleFunction:
                        if(APP_SD_CONTEXT_S642 == gAppSdContext.pCurCtxCtrl->common.ctxId)
                        {
                            (void)APP_DEVICE_rcStopRingtoneNonBlock();
                        }
                        _APP_SD_vInitFrameSA02();
                        break;
                    default:
                        break;
                }
                break;
            case enLogiButManVirtualButtonSos:
                /* SOS-Ruf */
                switch(pButton->pressType)
                {
                    case enLogiButManLongPress:
                        _APP_SD_vInitFrameS801_PN(gAppSdContext.prompts[APP_SD_en_S801_ta_call_sos_1_Zeile_1],
                                                  gAppSdContext.prompts_len[APP_SD_en_S801_ta_call_sos_1_Zeile_1],
                                                  BT_FALSE);
                        break;
                    case enLogiButManShortPressAtSingleFunction:
                        if(APP_SD_CONTEXT_S642 == gAppSdContext.pCurCtxCtrl->common.ctxId)
                        {
                            (void)APP_DEVICE_rcStopRingtoneNonBlock();
                        }
                        _APP_SD_vInitFrameSA03();
                        break;
                    default:
                        break;
                }
                break;
            case enLogiButManMflBack:
                if (APP_SD_CONTEXT_S904 == gAppSdContext.pCurCtxCtrl->common.ctxId)
                {
                    DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HaBtnEv: Back in screen S904 reset new missed call");
                    // remove showing
                    APP_PHONEBOOK_vResetMissedCallsByHMI();         // RT #5132
                }
                if(pButton->pressType == enLogiButManLongPress)
                {
                    if(APP_CAN_SK_Skoda == APP_CAN_enGetMarke())    // bugfix for RT #1497
                    {
                      /* short pressed Mfl Back Button, go back to HMI menu */
                      _APP_SD_FB_vPresReqOff(__LINE__);
                    }
                    else
                    {
                      _APP_SD_vCtxHistoryStepBack();
                    }
                    break;
                }
                else
                {
                    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
                    {
                        case APP_SD_CONTEXT_S101:
                            _APP_SD_vInitIdleScreen(0);
                            break;
                        case APP_SD_CONTEXT_S102:
                            _APP_SD_bHandleButtonS102(gAppSdContext.pCurCtxCtrl, pButton);
                            break;
                        case APP_SD_CONTEXT_S104:
                            _APP_SD_bHandleButtonS104(gAppSdContext.pCurCtxCtrl, pButton);
                            break;
                        /* add here ctxIds where the back key shall have no effect */
                        case APP_SD_CONTEXT_S001:
//                        case APP_SD_CONTEXT_S007:
                        case APP_SD_CONTEXT_S408:
                        case APP_SD_CONTEXT_S408_PRECALL:
                        case APP_SD_CONTEXT_S408_USERLIST:
                        case APP_SD_CONTEXT_S408_ABR:
                        case APP_SD_CONTEXT_S408_DEL:
                        case APP_SD_CONTEXT_S408_PLAYER:
                        case APP_SD_CONTEXT_S425:
                        case APP_SD_CONTEXT_S428:
                        case APP_SD_CONTEXT_S517:         // RT #1241
//                        case APP_SD_CONTEXT_S535:
//                        case APP_SD_CONTEXT_S580:
                        case APP_SD_CONTEXT_S597:
                        case APP_SD_CONTEXT_S663_PB:
                        case APP_SD_CONTEXT_S801:
                        case APP_SD_CONTEXT_S803:
                        case APP_SD_CONTEXT_S811:
                        case APP_SD_CONTEXT_S812:
                        case APP_SD_CONTEXT_S813:
                        case APP_SD_CONTEXT_S815:
                        case APP_SD_CONTEXT_S901:
//                        case APP_SD_CONTEXT_SC17:
                        case APP_SD_CONTEXT_S902:
                        case APP_SD_CONTEXT_S924:
                        case APP_SD_CONTEXT_S929:           // RT #1491
                        case APP_SD_CONTEXT_SC14:
                        case APP_SD_CONTEXT_SC20:

                            DEBUG_VALUE1( APP_SD_SWI_WNG, MOD_APP_SD, "HaBtnEv: back key disabled (ctx %d)",
                                          gAppSdContext.pCurCtxCtrl->common.ctxId);
                            break;
                        case APP_SD_CONTEXT_S642:
                            _APP_SD_bHandleButtonS642(gAppSdContext.pCurCtxCtrl, pButton);
                            break;
                        case APP_SD_CONTEXT_S512:
                            _APP_SD_bHandleButtonS512(gAppSdContext.pCurCtxCtrl, pButton);
                            break;
                        case APP_SD_CONTEXT_S515:
                            _APP_SD_bHandleButtonS515(gAppSdContext.pCurCtxCtrl, pButton);
                            break;
                        case APP_SD_CONTEXT_SC13:
                            _APP_SD_bHandleButtonSC13(gAppSdContext.pCurCtxCtrl, pButton);
                            break;
                        case APP_SD_CONTEXT_S520:
                            _APP_SD_bHandleButtonS520(gAppSdContext.pCurCtxCtrl, pButton);
                            break;
                        case APP_SD_CONTEXT_S581:
                            _APP_SD_bHandleButtonS581(gAppSdContext.pCurCtxCtrl, pButton);
                            break;
                        case APP_SD_CONTEXT_S933:
                            _APP_SD_bHandleButtonS933(gAppSdContext.pCurCtxCtrl, pButton);
                            break;
                        case APP_SD_CONTEXT_S51D:
                            _APP_SD_bHandleButtonS51D(gAppSdContext.pCurCtxCtrl, pButton);
                            break;
                        case APP_SD_CONTEXT_S51D_ACCEPT:
                            _APP_SD_bHandleButtonS51D_ACCEPT(gAppSdContext.pCurCtxCtrl, pButton);
                            break;
                        case APP_SD_CONTEXT_S018:
                        case APP_SD_CONTEXT_SP18:       // bugfix for RT #1120
                        case APP_SD_CONTEXT_S002:
                            if(APP_CAN_SK_Skoda == APP_CAN_enGetMarke())      // bugfix for RT #1497
                            {
                              /* short pressed Mfl Back Button, go back to HMI menu */
                              _APP_SD_FB_vPresReqOff(__LINE__);
                            }
                            else
                            {
                              /* stay still in idle screen */
                            }
                            break;
                        // #3472
                        // frames where we want to delete something, should handle back button on its own
                        // this way they are able to ignore the back button as soon as the user triggered the
                        // deletion of something ( profile, sms, ... )
                        case APP_SD_CONTEXT_S115:
                            _APP_SD_bHandleButtonS115(gAppSdContext.pCurCtxCtrl, pButton);
                            break;
                        case APP_SD_CONTEXT_S413:
                            _APP_SD_bHandleButtonS413(gAppSdContext.pCurCtxCtrl, pButton);
                            break;
                        case APP_SD_CONTEXT_S513:
                            _APP_SD_bHandleButtonS513(gAppSdContext.pCurCtxCtrl, pButton);
                            break;
                        case APP_SD_CONTEXT_S555:
                            _APP_SD_bHandleButtonS555(gAppSdContext.pCurCtxCtrl, pButton);
                            break;
                        case APP_SD_CONTEXT_S576:
                            _APP_SD_bHandleButtonS576(gAppSdContext.pCurCtxCtrl, pButton);
                            break;
                        case APP_SD_CONTEXT_S579:
                            _APP_SD_bHandleButtonS579(gAppSdContext.pCurCtxCtrl, pButton);
                            break;
                        case APP_SD_CONTEXT_S914:
                            /* player or headset was disconnected, check if we have a phone connected or not */
                            if(AT_INVALID_DEVICE_ID == ERM_u8GetActivePhone())
                            {
                                /* no phone connected */
                                _APP_SD_vInitIdleScreen(0);
                            }
                            else
                            {   /* still a phone conencted, step back */
                                _APP_SD_vCtxHistoryStepBack();
                            }
                            break;
                        case APP_SD_CONTEXT_S917:
                            {
                                _APP_SD_bHandleButtonS917(gAppSdContext.pCurCtxCtrl, pButton);
                                break;
                            }
                        case APP_SD_CONTEXT_SC03:
                            // #4502 need to handle back button in a special manner, cause
                            // phone might be disconnected in the meantime and we need to show
                            // S002 instead of S502
                            _APP_SD_bHandleButtonSC03(gAppSdContext.pCurCtxCtrl, pButton);
                            break;
                        case APP_SD_CONTEXT_S52C:
                        {
                            _APP_SD_bHandleButtonS52C(gAppSdContext.pCurCtxCtrl, pButton);
                            break;
                        }
                        default:
                            // go back to MMI screen (release context for phone)
                            if(BT_FALSE == _APP_SD_bPhoneContextActive())
                            {
                                _APP_SD_vReleasePhoneContext();
                            }
                            else
                            {
                                _APP_SD_vCtxHistoryStepBack();
                            }
                            break;
                    }
                }
                break;
            case enLogiButManLssUp:
            case enLogiButManLssDown:
                if(pButton->pressType == enLogiButManLongPress)
                {
                    _APP_SD_FB_vPresReqOff(__LINE__);
                }
                else
                {

                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaBtnEv: ignored btn %d", pButton->id);
                }
                break;
            case enLogiButManLssOk:
                if(pButton->pressType == enLogiButManLongPress)
                {
                    if (APP_SD_CONTEXT_S642 == gAppSdContext.pCurCtxCtrl->common.ctxId)
                    {
                        DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "HaBtnEv: long pressed %d, release mute and stop play ringtone",
                                pButton->id);
                        /* release mute and stop play ringtone */
                        (void)APP_DEVICE_rcStopRingtoneNonBlock();
                    }
                    switch (gAppSdContext.pCurCtxCtrl->common.ctxId)
                    {
                    case APP_SD_CONTEXT_S001:
                    case APP_SD_CONTEXT_S408:
                    case APP_SD_CONTEXT_S408_PRECALL:
                    case APP_SD_CONTEXT_S408_USERLIST:
                    case APP_SD_CONTEXT_S408_ABR:
                    case APP_SD_CONTEXT_S408_DEL:
                    case APP_SD_CONTEXT_S408_PLAYER:
                    case APP_SD_CONTEXT_S517:
                    case APP_SD_CONTEXT_S520:
//                    case APP_SD_CONTEXT_S580:
                    case APP_SD_CONTEXT_S581:
                    case APP_SD_CONTEXT_S804:
                    case APP_SD_CONTEXT_S814:
                    case APP_SD_CONTEXT_S815:
                    case APP_SD_CONTEXT_S924:
                    case APP_SD_CONTEXT_S929:
                    case APP_SD_CONTEXT_S933:
                    case APP_SD_CONTEXT_S941:
                    case APP_SD_CONTEXT_S942:
                    case APP_SD_CONTEXT_S945:
                    case APP_SD_CONTEXT_SC12:
                    case APP_SD_CONTEXT_SC13:
                    case APP_SD_CONTEXT_SC14:
                    case APP_SD_CONTEXT_SC24:
                    case APP_SD_CONTEXT_S811:
                    case APP_SD_CONTEXT_S812:
                    case APP_SD_CONTEXT_S813:
                    case APP_SD_CONTEXT_S803:
                    case APP_SD_CONTEXT_SC20:
                    case APP_SD_CONTEXT_S801:
                    case APP_SD_CONTEXT_S901:
                    case APP_SD_CONTEXT_S902:
                    case APP_SD_CONTEXT_S511:
                    case APP_SD_CONTEXT_S512:
                    case APP_SD_CONTEXT_S513:
                    case APP_SD_CONTEXT_S514:
                    case APP_SD_CONTEXT_S555:
                    case APP_SD_CONTEXT_S51D:
                    case APP_SD_CONTEXT_S51D_ACCEPT:
                    case APP_SD_CONTEXT_S52C:
                    case APP_SD_CONTEXT_S52D:
                    case APP_SD_CONTEXT_S410:
                    case APP_SD_CONTEXT_S542:
                    case APP_SD_CONTEXT_S663:
                    case APP_SD_CONTEXT_S663_PB:
                    case APP_SD_CONTEXT_S010:
                        break;
                    default:
                        DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "HaBtnEv: long pressed Lss OK: Frame Id %d",
                                gAppSdContext.pCurCtxCtrl->common.ctxId);
                        _APP_SD_vInitIdleScreen(0);
                        break;
                    }

                }
                else
                {

                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaBtnEv: ignored btn %d", pButton->id);
                }
                break;
            default:
                if( APP_SD_HANDLER_EXISTS(_APP_SD_sfHandleButtonTable, gAppSdContext.pCurCtxCtrl->common.ctxId) )
                {
                    if ( _APP_SD_sfHandleButtonTable[gAppSdContext.pCurCtxCtrl->common.ctxId](gAppSdContext.pCurCtxCtrl, pButton) != BT_TRUE)
                    {

                        DEBUG_VALUE2( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandleButtonEvent: ctx %d ignored key %d",
                                      gAppSdContext.pCurCtxCtrl->common.ctxId, pButton->id);
                    }
                }
                else
                {

                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandleButtonEvent: no Handler for ctx %d",
                                  gAppSdContext.pCurCtxCtrl->common.ctxId);
                    return FAIL;
                }
                break;
        }
    }
    return SUCCESS;
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_sfCtxHistoryScreenHandling_VisibleON                  */
/**
  \brief        Managed the Screens which are event based and must be release
                the context if the ASG was not in phone context.

  \return       void

 */
/*----------------------------------------------------------------------------*/
void _APP_SD_sfCtxHistoryScreenHandling_VisibleON(void)
{
    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        /* check if we have a frame that depends on an event */
        case APP_SD_CONTEXT_S001:
        case APP_SD_CONTEXT_S102:
        case APP_SD_CONTEXT_S103:
        case APP_SD_CONTEXT_S104:
        case APP_SD_CONTEXT_S105:
        case APP_SD_CONTEXT_S114:
        case APP_SD_CONTEXT_S115:
        case APP_SD_CONTEXT_S116:
        case APP_SD_CONTEXT_S117:
        case APP_SD_CONTEXT_S201:
        case APP_SD_CONTEXT_S211:
        case APP_SD_CONTEXT_S301:
        case APP_SD_CONTEXT_S305:
        case APP_SD_CONTEXT_S306:
        case APP_SD_CONTEXT_S406:
        case APP_SD_CONTEXT_S408_PRECALL:
        case APP_SD_CONTEXT_S51D_ACCEPT:
        case APP_SD_CONTEXT_S520:
        case APP_SD_CONTEXT_S52C:
        case APP_SD_CONTEXT_S52D:
        case APP_SD_CONTEXT_S554:       //RT #4045
        case APP_SD_CONTEXT_S801:
        case APP_SD_CONTEXT_S803:
        case APP_SD_CONTEXT_S804:
        case APP_SD_CONTEXT_S806:
        case APP_SD_CONTEXT_S807:
        case APP_SD_CONTEXT_S811:
        case APP_SD_CONTEXT_S812:
        case APP_SD_CONTEXT_S813:
        case APP_SD_CONTEXT_S901:
        case APP_SD_CONTEXT_S902:
        case APP_SD_CONTEXT_S903:
        case APP_SD_CONTEXT_S904:
        case APP_SD_CONTEXT_S913:
        case APP_SD_CONTEXT_S914:
        case APP_SD_CONTEXT_S917:
        case APP_SD_CONTEXT_S924:
        case APP_SD_CONTEXT_S925:       //RT #3545
        case APP_SD_CONTEXT_S927:       //RT #3545
        case APP_SD_CONTEXT_S928:
        case APP_SD_CONTEXT_S933:
        case APP_SD_CONTEXT_S941:
        case APP_SD_CONTEXT_S942:
        case APP_SD_CONTEXT_S945:
        case APP_SD_CONTEXT_SA01:       //RT #4045
        case APP_SD_CONTEXT_SA02:       //RT #4045
        case APP_SD_CONTEXT_SA03:       //RT #4045
        case APP_SD_CONTEXT_SC20:
        case APP_SD_CONTEXT_SC22:       //RT #3545
        case APP_SD_CONTEXT_SC23:
            if ((gAppSdContext.ctxInView == APP_SD_UHV_IN_ASG_VIEW)||(gAppSdContext.ctxInView == APP_SD_UHV_ACTIVE_TRIGGER_NOT_IN_ASG_VIEW))
            {
                (void)_APP_SD_vSetCtxHistoryState(APP_SD_UHV_IN_ASG_VIEW, __LINE__);
            }
            else
            {
                (void)_APP_SD_vSetCtxHistoryState(APP_SD_WAIT_BACK_TO_ASG_MENU, __LINE__);
            }
            break;
        case APP_SD_CONTEXT_SC01:
        case APP_SD_CONTEXT_S929:
            if(gAppSdContext.ctxInView == APP_SD_UHV_IN_ASG_VIEW)
            {
                (void)_APP_SD_vSetCtxHistoryState(APP_SD_UHV_IN_ASG_VIEW, __LINE__);
            }
            else
            {
                (void)_APP_SD_vSetCtxHistoryState(APP_SD_WAIT_BACK_TO_ASG_MENU, __LINE__);
            }
            break;
        default:
            (void)_APP_SD_vSetCtxHistoryState(APP_SD_UHV_IN_ASG_VIEW, __LINE__);
        break;
    }
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_sfCtxHistoryScreenHandling_VisibleOff                  */
/**
  \brief        Managed the Screens which are event based activated outside of
                the phone context and set a value to stable the current screen
                for reentry in the phone context.

  \return       void

 */
/*----------------------------------------------------------------------------*/
void _APP_SD_sfCtxHistoryScreenHandling_VisibleOff(void)
{
    if (_APP_SD_bCurrentFrameStaysActiveWhenNotInPhoneContext())
    {
        /* check if we have a frame that depends on the call state, VCR, PB */
        // don't switch back to idle screen in this Screens
        if((KPB_bIsFsgQueuedUp() == BT_TRUE)&&(gAppSdContext.ctxInView == APP_SD_WAIT_BACK_TO_ASG_MENU))
        {
            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "Dont change the history state, special handling for queued-up while wait back for asg menu");
        }
        else
        {
            (void)_APP_SD_vSetCtxHistoryState(APP_SD_UHV_ACTIVE_TRIGGER_NOT_IN_ASG_VIEW, __LINE__);
        }
    }
    else
    {
        switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
        {
            //case APP_SD_CONTEXT_S102:  /*RT13591*/ // when active call set on hold and phone context leaved from this screen so:
            case APP_SD_CONTEXT_S103:
            case APP_SD_CONTEXT_S104:
            case APP_SD_CONTEXT_S114:
            case APP_SD_CONTEXT_S115:
            case APP_SD_CONTEXT_S116:
            case APP_SD_CONTEXT_S117:
            case APP_SD_CONTEXT_S201:
            case APP_SD_CONTEXT_S211:
            case APP_SD_CONTEXT_S301:
            case APP_SD_CONTEXT_S305:
            case APP_SD_CONTEXT_S306:
            case APP_SD_CONTEXT_S806:
            {
                (void)_APP_SD_vSetCtxHistoryState(APP_SD_UHV_ACTIVE_TRIGGER_NOT_IN_ASG_VIEW, __LINE__);
                if( KPB_bIsFsgQueuedUp() != BT_TRUE )
                {
                    (void)_APP_SD_vInitIdleScreen(0); // regarding BAP_FRAME_CATALOGUE it is not allowed to update the FrID3 when not in context, after test we see it is possible at this place
                    // this issue has to be clarified. When doing this in _APP_SD_sfCtxHistoryScreenHandling_VisibleON the call stack screen S211 is displayed for 0,5 sec.
                }
                break;
            }
            case APP_SD_CONTEXT_S642:
            {
                (void)_APP_SD_vSetCtxHistoryState(APP_SD_UHV_NOT_IN_ASG_VIEW, __LINE__);
                /* release mute and stop play ringtone */
                (void)APP_DEVICE_rcStopRingtoneNonBlock();
                _APP_SD_vInitIdleScreen(0);
                break;
            }
            default:
            {
                (void)_APP_SD_vSetCtxHistoryState(APP_SD_UHV_NOT_IN_ASG_VIEW, __LINE__);
                if( KPB_bIsFsgQueuedUp() != BT_TRUE )
                {
                    _APP_SD_vInitIdleScreen(0);
                }
                break;
            }
        }
    }
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_bHandleButton001                                    */
/**
  \brief        Button handler for the context S001

  \param        pCtxCtrl
                Pointer to current context control structure

  \param        pButton
                Pointer to an incoming Button event

  \return       void

 */
/*----------------------------------------------------------------------------*/
BooleanType _APP_SD_bHandleButtonS001(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    Uint8Type profileId = ERM_GetLastActiveProfileId( pCtxCtrl->s001.connectAttempt, APP_DEVICE_enTYPE_PHONE);
    const ERMUserProfileType *pUserProfile = ERM_pGetUserProfile(profileId);

    switch(pButton->id)
    {
        case enLogiButManMflOk:
        {
            /* Abbruch */
            pCtxCtrl->s001.abort = BT_FALSE;
            pCtxCtrl->s001.abortPressed = BT_TRUE;

            if (pCtxCtrl->s001.subState != APP_SD_S001_CONNECT_SENT)
            {
                _APP_SD_vInitIdleScreen(0);
            }
            else
            {
                _APP_SD_vInitFrameS408_ABR(pUserProfile->deviceIndex, APP_DEVICE_enTYPE_PHONE);
            }
            break;
        }

        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS002(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;

        case enLogiButManMflHook:
            if( pButton->pressType == enLogiButManLongPress )
            {
                _APP_SD_vInitFrameS001(0);
            }
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            // Get number of user profiles
            if( 0 < ERM_u16GetNumberOfUserProfiles() )
            {   /* at least one user profile */
                switch(selIdx)
                {
                    case 1:
                        /* Verbinden */
                        //if(gAppSdContext.ermStartupDone == BT_TRUE)
                        if (ERM_bIsStartupDone() == BT_TRUE)
                        {
                            _APP_SD_vInitFrameS541_2((Uint8Type)ERM_u16GetNumberOfUserProfiles());
                        }
                        else
                        {
                            _APP_SD_vInitFrameS408_USERLIST();
                        }
                        break;
                    case 2:
                        /* Telefonsuche */
                        if( APP_CAN_Speed_un16CurrentVehicleSpeed() < U16_SPEED_LIMIT_LOW )
                        {
                            if(BT_TRUE == APP_MDI_bMutePlayer(APP_MDI_MUTE_DEVICE_SEARCH))
                            {
                                _APP_SD_vInitFrameS522(APP_SD_MDI_MUTE_FOR_SEARCH, AT_INVALID_DEVICE_ID,
                                                       APP_DEVICE_enTYPE_UNKNOWN, BT_FALSE);
                            }
                            else
                            {
                                _APP_SD_vInitFrameS520();
                            }
                        }
                        else
                        {
                            _APP_SD_vInitFrameS407();
                        }
                        break;
                    case 3:
                        /* Media Player */
                        _APP_SD_vInitFrameSC03(0);
                        break;
                    default:

                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton002: enOK not handled for pos %d",
                                      selIdx);
                        break;
                }
            }
            else
            {   /* no paired devices */
                switch(selIdx)
                {
                    case 1:
                        /* Hilfe */
                        _APP_SD_vInitFrameS008();
                        break;
                    case 2:
                        /* Telefonsuche */
                        if( APP_CAN_Speed_un16CurrentVehicleSpeed() < U16_SPEED_LIMIT_LOW )
                        {
                            if(BT_TRUE == APP_MDI_bMutePlayer(APP_MDI_MUTE_DEVICE_SEARCH))
                            {
                                _APP_SD_vInitFrameS522(APP_SD_MDI_MUTE_FOR_SEARCH, AT_INVALID_DEVICE_ID,
                                                       APP_DEVICE_enTYPE_UNKNOWN, BT_FALSE);
                            }
                            else
                            {
                                _APP_SD_vInitFrameS520();
                            }
                        }
                        else
                        {
                            _APP_SD_vInitFrameS407();
                        }
                        break;
                    case 3:
                        /* Media Player */
                        _APP_SD_vInitFrameSC03(0);
                        break;
                    default:

                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton002: enOK not handled for pos %d",
                                      selIdx);
                        break;
                }
            }
            break;
        }

        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}


BooleanType _APP_SD_bHandleButtonS008(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}
BooleanType _APP_SD_bHandleButtonS_18(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflHook:
        case enLogiButManMflOk:
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            _APP_SD_vInitFrameS101();

            break;
        case enLogiButManMflBack:
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonSC20(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            /* HandsFree ON */
            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
            pCtxCtrl->sc20.subStateBtn   = APP_SD_SC20_HANDSFREE_NOT_SENT;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflHook:
            if(pButton->pressType == enLogiButManLongPress)
            {
              /* HandsFree ON */
              pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
              pCtxCtrl->sc20.subStateBtn   = APP_SD_SC20_HANDSFREE_NOT_SENT;

              (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                  MSEC(0),
                                                  0);
            }
            else
            {
              /* HangUp */
              pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
              pCtxCtrl->sc20.subStateBtn   = APP_SD_SC20_HANGUP_NOT_SENT;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                  MSEC(0),
                                                  0);
            }
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS101(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflHook:
        {
            Uint16Type pbSize = APP_PHONEBOOK_u16GetCurrentPBSize(APP_PHONEBOOK_enLastDialed);
            if(pbSize > 0)
            {
                _APP_SD_vInitFrameS211(APP_PHONEBOOK_enLastDialed, pbSize);
            }
            else
            {
                /* no entries available */
                _APP_SD_vInitFrameS103();
            }
            break;
        }
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            switch(selIdx)
            {
                case 1:
                {
                    /* PHONEBOOK */
                    Uint16Type pbSize = APP_PHONEBOOK_u16GetCurrentPBSize(APP_PHONEBOOK_enUsersPB);
                    //APP_PHONEBOOK_enStatusCode pbState = APP_PHONEBOOK_AT_ePhonebookStatusGet();
                    //if((pbState == APP_PHONEBOOK_STATUS_DOWNLOAD_IPR) && (pbSize == 0) )
                    if( BT_TRUE == gAppSdContext.manualPbSyncInProgress )
                    {
                        /* the pb is not sync, show dl progress frame */
                        _APP_SD_vInitFrameS102();
                    }
                    else
                    {
                        if(pbSize > 0)
                        {
                            /* show phonebook entries */
                            _APP_SD_vInitFrameS104(pbSize);
                        }
                        else
                        {
                            /* no entries available */
                            _APP_SD_vInitFrameS103();
                        }
                    }
                    break;
                }
                case 2:
                    /* Digit Dial */
                    _APP_SD_vInitFrameS305();
                    break;
                case 3:
                    /* call stacks */
                    _APP_SD_vInitFrameS201();
                    break;
                case 4:
                    /* Voice Mail */
                    _APP_SD_vInitFrameS306();
                    break;
                case 5:
                {
                    if(pCtxCtrl->s101.messagesAvail == BT_TRUE)
                    {
                        /* SMS */
                        APP_SMS_enSupportState smsSupport = APP_SMS_enGetSmsSupportState();
                        switch( smsSupport)
                        {
                            case APP_SMS_NOT_INITIALIZED:
                                // wait for intialization to be finished
                                _APP_SD_vInitFrameS410();
                                break;
                            case APP_SMS_INITIALIZED_AND_UNSUPPORTED:
                                /* no entries available */
                                _APP_SD_vInitFrameS402();
                                break;
                            case APP_SMS_INITIALIZED_AND_SUPPORTED:
                            {
                                Uint16Type numSms = APP_SMS_u16GetNumReadSms() +
                                                    APP_SMS_u16GetNumUnreadSms();
                                if(numSms > 0)
                                {
                                    _APP_SD_vInitFrameS404(numSms);
                                }
                                else
                                {
                                    /* no entries available */
                                    _APP_SD_vInitFrameS402();
                                }
                                break;
                            }
                            default:
                                /* no entries available */
                                _APP_SD_vInitFrameS402();
                                break;
                        }
                    }
                    else
                    {
                        /* Bluetooth */
                        _APP_SD_vInitFrameS502(0);
                    }
                    break;
                }
                case 6:
                    if(pCtxCtrl->s101.messagesAvail == BT_TRUE)
                    {
                        /* Bluetooth */
                        _APP_SD_vInitFrameS502(0);
                    }
                    else
                    {
                        /* Settings */
                        _APP_SD_vInitFrameS601();
                    }
                    break;
                case 7:
                    if(pCtxCtrl->s101.messagesAvail == BT_TRUE)
                    {
                        /* Settings */
                        _APP_SD_vInitFrameS601();
                    }
                    else
                    {
//                          _APP_SD_vCtxHistoryStepBack();        //12.07.2009
                        /* activate the idle screen */
                        _APP_SD_vInitIdleScreen(0);        //12.07.2009
                    }
                    break;
                case 8:
//                      _APP_SD_vCtxHistoryStepBack();        //12.07.2009
                    /* activate the idle screen */
                    _APP_SD_vInitIdleScreen(0);        //12.07.2009
                    break;

                default:

                    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton101: enOK not handled for pos %d",
                                  selIdx);
                    break;
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS102(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        case enLogiButManMflBack:
              _APP_SD_vActivateFrame(BT_TRUE, __LINE__);      //RT #3958
              _APP_SD_vInitFrameS101();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS103(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();	//RT 2376
//              _APP_SD_vInitFrameS201();     // RT #1416
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}


BooleanType _APP_SD_bHandleButtonS104(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            if(pButton->pressType == enLogiButManLongPress)
            {
                if( (FALSE == _APP_SD_ListRollover) &&
                    (APP_SD_LC_u16GetSelectedIndex(&pCtxCtrl->common.listData) != pCtxCtrl->common.listData.numListElems))
                {
                    /* long press up/down handling */
                    /* do letterwise scroll handling */
                    pCtxCtrl->common.pendingType   = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->s104.subStateBtn     = APP_SD_S104_PB_SEARCH_NOT_SENT;
                    pCtxCtrl->s104.searchDirection = pButton->id;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(0),
                                                        0);
                }
            }
            else
            {
                _APP_SD_ListRollover = FALSE;
                APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

                pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
                pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                    MSEC(0),
                                                    0);
            }
            break;
        case enLogiButManMflBack:
            // SUSANNE: 28.12.2009: Die Spec is falsch. Hier wird bei Back aus dem PB immer auf T1
            // verwiesen. Bei einem aktiven Call macht es aber keinen Sinn ins Telefonhauptmenu zu springen.
            // Wie mit Herr Krämer besprochen (Hüsnü) sollen wir bei aktivem Call natürlich die History berücksichtigen.
            // Wir haben die folgenden Fälle zu berücksichtigen:
            // Call vorhanden ? -> History Back
            // Keiner vorhanden ? -> THM

            if( BT_FALSE == APP_PHONE_AT_PNCC_bAllCallStatesIdle())
            {   // there is a call!!! go back to call frame
                _APP_SD_vCtxHistoryStepBack();
            }
            else
            {   // no call present, show idle screen
                // in S101 history is reset when initialized from S104, so all the old stuff in history is gone
                _APP_SD_vInitFrameS101();
            }

            // Marc: 15.10.2009: Ticket #3214: Set history to Phone main menu
            //_APP_SD_vInitFrameS101();
            // Susanne: 31.08.2009: Ticket #2599: not just init Idle or THM, cause
            // we need to respect the history
            //_APP_SD_vCtxHistoryStepBack();
            //switch(pCtxCtrl->s104.initiator)
            //{
            //    case APP_SD_CONTEXT_S102:
            //        /*_APP_SD_vInitFrameS101();*/
            //        _APP_SD_vInitIdleScreen(0);    // bugfix for RT #1392
            //        break;
            //    default:
            //        _APP_SD_vCtxHistoryStepBack();
            //        break;
            //}
            // END: 31.08.2009
            break;
        case enLogiButManMflOk:
        {
            if((APP_CAN_SK_Skoda == APP_CAN_enGetMarke())&&(pButton->pressType == enLogiButManLongPress))
            {
                _APP_SD_ListRollover = FALSE;
                if((FALSE == _APP_SD_ListRollover) &&
                   (gAppSdContext.pCurCtxCtrl->s104.searchStringSize > 0) )
                {
                    /* long press up/down handling (up not yet supported) */
                    /* do letterwise scroll handling */
                    pCtxCtrl->common.pendingType   = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->s104.subStateBtn     = APP_SD_S104_PB_SEARCH_NOT_SENT;
                    pCtxCtrl->s104.searchDirection = enLogiButManMflDown;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(0),
                                                        0);
                }
            }
            else
            {
                Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
                if(selIdx > pCtxCtrl->s104.pbSize)
                {
                    // we are on BACK menue entry
                    // SUSANNE: 28.12.2009: Die Spec is falsch. Hier wird bei Back aus dem PB immer auf T1
                    // verwiesen. Bei einem aktiven Call macht es aber keinen Sinn ins Telefonhauptmenu zu springen.
                    // Wie mit Herr Krämer besprochen (Hüsnü) sollen wir bei aktivem Call natürlich die History berücksichtigen.
                    // Wir haben die folgenden Fälle zu berücksichtigen:
                    // Call vorhanden ? -> History Back
                    // Keiner vorhanden ? -> THM
                    if( BT_FALSE == APP_PHONE_AT_PNCC_bAllCallStatesIdle())
                    {   // there is a call!!! go back to call frame
                        _APP_SD_vCtxHistoryStepBack();
                    }
                    else
                    {   // no call present, show idle screen
                        // in S101 history is reset when initialized from S104, so all the old stuff in history is gone
                        _APP_SD_vInitFrameS101();
                    }
                }
                else
                {
                    _APP_SD_vInitFrameS105(selIdx);
                }
            }
            break;
        }
        case enLogiButManMflHook:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            if(selIdx <= pCtxCtrl->s104.pbSize)
            {
                pCtxCtrl->common.pendingType   = APP_SD_PENDING_BUTTON;
                pCtxCtrl->s104.subStateBtn     = APP_SD_S104_PB_REQUEST_ENTRIES_NOT_SEND;
                pCtxCtrl->s104.selectedIndex   = selIdx;

                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(0),
                                                        0);

                /* call the selected PB index with the PN index 0 (default number) */
             //   _APP_SD_vInitFrameS801_PB(selIdx, 0);
            }
            else
            {

                DEBUG_VALUE2( APP_SD_SWI_TRC, MOD_APP_SD, "HandleButtonS104: Hook ignored, %d > %d",
                              selIdx,
                              pCtxCtrl->s104.pbSize);
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}


BooleanType _APP_SD_bHandleButtonS105(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));

            if( selIdx <= pCtxCtrl->s105.pnSize )
            {
                // According to MENUEABLAEUFE_V17E we step directly to S801 on OK button press
                //_APP_SD_vInitFrameS111(pCtxCtrl->s105.pbIndex, selIdx);
                _APP_SD_vInitFrameS801_PB(pCtxCtrl->s105.pbIndex, selIdx);
            }
            else if(( selIdx == pCtxCtrl->s105.pnSize + 1 )&&(ERM_SIVR_FULL_SUPPORTED == ERM_enIsVcrSupported()))           /* RT 2429 */
            {   // Anrufname
                //TODO: Skip this if VCR is deactivated via Diagnose
                _APP_SD_vInitFrameS117(pCtxCtrl->s105.pbIndex);
            }
            else
            {   // Zurück
                _APP_SD_vCtxHistoryStepBack();
            }
            break;

        }
        case enLogiButManMflHook:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            /* call the current PB index with the selected PN index */
            // make sure that no static list entry is selected, e.g. 'zureuck'
            if( selIdx <= pCtxCtrl->s105.pnSize )
            {
                _APP_SD_vInitFrameS801_PB(pCtxCtrl->s105.pbIndex, selIdx);
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}


//BooleanType _APP_SD_bHandleButtonS111(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
//{
//    switch(pButton->id)
//    {
//        case enLogiButManMflUp:
//        case enLogiButManMflDown:
//            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);
//
//            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
//            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;
//
//            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
//                                                MSEC(0),
//                                                0);
//            break;
//        case enLogiButManMflOk:
//        {
//            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
//            switch(selIdx)
//            {
//                case 1:
//                    _APP_SD_vInitFrameS801_PB(pCtxCtrl->s111.pbIndex, pCtxCtrl->s111.pnIndex);
//                    break;
//                case 2:
//                    _APP_SD_vCtxHistoryStepBack();
//                    break;
//                default:
//                    break;
//            }
//            break;
//        }
//        case enLogiButManMflHook:
//        {
//            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
//            switch(selIdx)
//            {
//                case 1:
//                    _APP_SD_vInitFrameS801_PB(pCtxCtrl->s111.pbIndex, pCtxCtrl->s111.pnIndex);
//                    break;
//                default:
//                    break;
//            }
//            break;
//        }
//        default:
//            return BT_FALSE;
//    }
//    return BT_TRUE;
//}

BooleanType _APP_SD_bHandleButtonS114(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            // loop will be detected and replace old S117 with new one
            _APP_SD_vInitFrameS117(pCtxCtrl->s114.pbIndex);
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}



BooleanType _APP_SD_bHandleButtonS115(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    if(pCtxCtrl->s115.deletePressed == BT_TRUE)
    {

        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "sfHaBtnS115: del pressed, key ignored %x",
                      pButton->id);
        return BT_TRUE;
    }

    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            switch(selIdx)
            {
                case 1:
                    /* Ok */
                    // pending button deleting the voice tag for pbIndex
                    if(SUCCESS != VCR_sFHapticTrigger(VCR_HAPTIC_DELETE_NAME,
                                                      pCtxCtrl->s115.pbIndex))
                    {
                        _APP_SD_vInitFrameS928();
                    }
                    else
                    {   // started deletion of voice tag
                        gAppSdContext.pCurCtxCtrl->s115.deletePressed = BT_TRUE;
                    }
                    break;
                case 2:
                    /* Zurück */
                    _APP_SD_vCtxHistoryStepBack();
                    break;
                default:

                    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton115: enOK not handled for pos %d",
                                  selIdx);
            }
            break;
        }

        case enLogiButManMflBack:
            /* Zurück */
            _APP_SD_vCtxHistoryStepBack();
            break;

        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS116(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}



BooleanType _APP_SD_bHandleButtonS117(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            gAppSdContext.pCurCtxCtrl->s117.lastSelMenue = APP_SD_S117_UNKNOWN;
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;

        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            if(BT_TRUE == gAppSdContext.pCurCtxCtrl->s117.bVoiceTagAvailable)
            {
                switch(selIdx)
                {
                    case 1:
                        /* Wiedergeben */
                        // play voice tag and stay in this frame

                        // RT #4705
                        // request if VCR is in idle state or Haptic trigger was set bevor
                        if((VCR_eGetVoiceRecognitionStatus() != AT_SIVR_ENG_IDLE) || (VCR_eGetHapticTrigTypeStatus() != VCR_HAPTIC_NONE))
                        {
                            DEBUG_VALUE2( APP_SD_SWI_WNG, MOD_APP_SD, "HandleButtonS117 ignored play OK button, VCR state %d, Haptic trigger state %d", VCR_eGetVoiceRecognitionStatus(), VCR_eGetHapticTrigTypeStatus());
                            break;
                        }

                        if(SUCCESS != VCR_sFHapticTrigger(VCR_HAPTIC_PLAY_NAME,
                                                          pCtxCtrl->s117.pbIndex))
                        {
                            _APP_SD_vInitFrameS928();
                        }
                        else
                        {
                            gAppSdContext.pCurCtxCtrl->s117.lastSelMenue = APP_SD_S117_PLAY_TAG;
                        }
                        break;
                    case 2:
                        /* Aufnehmen */
                        if( BT_TRUE == ERM_bMaxVoiceTagsForUserRecorder() )
                        {
                            //recording not possible due to max. number of possible
                            //voice tags has been reached
                            _APP_SD_vInitFrameS116(pCtxCtrl->s117.pbIndex);
                        }
                        else
                        {
                            // trigger VCR to record voice tag
                            if(SUCCESS != VCR_sFHapticTrigger(VCR_HAPTIC_STORE_NAME,
                                                              pCtxCtrl->s117.pbIndex))
                            {
                                _APP_SD_vInitFrameS928();
                            }
                            else
                            {
                                gAppSdContext.pCurCtxCtrl->s117.lastSelMenue = APP_SD_S117_RECORD_TAG;
                            }
                        }
                        break;
                    case 3:
                        /* Zurücksetzen */
                        _APP_SD_vInitFrameS115(pCtxCtrl->s117.pbIndex);
                        gAppSdContext.pCurCtxCtrl->s117.lastSelMenue = APP_SD_S117_RESET_TAG;
                        break;
                    case 4:
                        /* Zurück */
                        _APP_SD_vCtxHistoryStepBack();
                        break;
                    default:
                        gAppSdContext.pCurCtxCtrl->s117.lastSelMenue = APP_SD_S117_UNKNOWN;

                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton117: enOK not handled for pos %d",
                                      selIdx);
                        break;
                }
            }
            else
            {
                switch(selIdx)
                {
                    case 1:
                        /* Wiedergeben */
                        // play voice tag and stay in this frame

                        // RT #4705
                        // request if VCR is in idle state or Haptic trigger was set bevor
                        if((VCR_eGetVoiceRecognitionStatus() != AT_SIVR_ENG_IDLE) || (VCR_eGetHapticTrigTypeStatus() != VCR_HAPTIC_NONE))
                        {
                            DEBUG_VALUE2( APP_SD_SWI_WNG, MOD_APP_SD, "HandleButtonS117 ignored play OK button, VCR state %d, Haptic trigger state %d", VCR_eGetVoiceRecognitionStatus(), VCR_eGetHapticTrigTypeStatus());
                            break;
                        }

                        if(SUCCESS != VCR_sFHapticTrigger(VCR_HAPTIC_PLAY_NAME,
                                                          pCtxCtrl->s117.pbIndex))
                        {
                            DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "HandleButtonS117 Haptic trigger failed");

                            _APP_SD_vInitFrameS928();
                        }
                        else
                        {
                            gAppSdContext.pCurCtxCtrl->s117.lastSelMenue = APP_SD_S117_PLAY_TAG;
                        }
                        break;
                    case 2:
                        /* Aufnehmen */
                        if( BT_TRUE == ERM_bMaxVoiceTagsForUserRecorder() )
                        {
                            //recording not possible due to max. number of possible
                            //voice tags has been reached
                            _APP_SD_vInitFrameS116(pCtxCtrl->s117.pbIndex);
                        }
                        else
                        {
                            // trigger VCR to record voice tag
                            if(SUCCESS != VCR_sFHapticTrigger(VCR_HAPTIC_STORE_NAME,
                                                              pCtxCtrl->s117.pbIndex))
                            {
                                _APP_SD_vInitFrameS928();
                            }
                            else
                            {
                                gAppSdContext.pCurCtxCtrl->s117.lastSelMenue = APP_SD_S117_RECORD_TAG;
                            }
                        }
                        break;
                    case 3:
                        /* Zurück */
                        _APP_SD_vCtxHistoryStepBack();
                        break;
                    default:
                        gAppSdContext.pCurCtxCtrl->s117.lastSelMenue = APP_SD_S117_UNKNOWN;

                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton117: enOK not handled for pos %d",
                                     selIdx);
                        break;
                }
            }

            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS201(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            if( selIdx < 4)
            {
                APP_PHONEBOOK_enSelectedPbType pbType = APP_PHONEBOOK_enPbUnknown;
                Uint16Type pbSize = 0;

                switch(selIdx)
                {
                    case 1:
                        /* MissedCalls */
                        pbType = APP_PHONEBOOK_enMissedCalls;
                        break;
                    case 2:
                        /* LastDialed */
                        pbType = APP_PHONEBOOK_enLastDialed;
                        break;
                    case 3:
                        /* ReceivedCalls */
                        pbType = APP_PHONEBOOK_enReceivedCalls;
                        break;
                    default:
                        break;
                }

                pbSize = APP_PHONEBOOK_u16GetCurrentPBSize(pbType);
                if(pbSize > 0)
                {
                    _APP_SD_vInitFrameS211(pbType, pbSize);
                }
                else
                {
                    /* no entries available */
                    _APP_SD_vInitFrameS103();
                }
            }
            else
            {
                switch(selIdx)
                {
                    /*
                    case 4:
                        // DeleteAllLists currently not supported
                        break;
                    case 5:
                    */
                    case 4:
                        /* Back */
                        _APP_SD_vCtxHistoryStepBack();
                        break;
                    default:
                        break;
                }
            }
            break;
        }
        case enLogiButManMflHook:
        {
            /* LastDialed */
            Uint16Type pbSize = APP_PHONEBOOK_u16GetCurrentPBSize(APP_PHONEBOOK_enLastDialed);
            if(pbSize > 0)
            {
                _APP_SD_vInitFrameS211(APP_PHONEBOOK_enLastDialed, pbSize);
            }
            else
            {
                /* no entries available */
                _APP_SD_vInitFrameS103();
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS211(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            if( selIdx == pCtxCtrl->s211.pbSize + 1 )
            {
                // go back to MMI screen (release context for phone)
                if(BT_FALSE == _APP_SD_bPhoneContextActive())
                {
                    _APP_SD_vReleasePhoneContext();
                }
                else
                {
                    _APP_SD_vCtxHistoryStepBack();
                }
            }
            else
            {
                _APP_SD_vInitFrameS212(pCtxCtrl->s211.pbType, selIdx);
            }
            break;
        }
        case enLogiButManMflHook:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            if( selIdx == pCtxCtrl->s211.pbSize + 1 )
            {   /* ignore */

                DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton211: ignoring Hook for back entry");
            }
            else
            {
                /* call the selected PB index */
                _APP_SD_vInitFrameS801_CallList(pCtxCtrl->s211.pbType, selIdx);
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS212(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            switch(selIdx)
            {
                case 1:
                    /* DIAL */
                    _APP_SD_vInitFrameS801_CallList(pCtxCtrl->s212.pbType, pCtxCtrl->s212.pbIndex);
                    break;
                default:
                    // go back to MMI screen (release context for phone)
                    if(BT_FALSE == _APP_SD_bPhoneContextActive())
                    {
                        _APP_SD_vReleasePhoneContext();
                    }
                    else
                    {
                        _APP_SD_vCtxHistoryStepBack();
                    }
                    break;
            }
            break;
        }
        case enLogiButManMflHook:
        {
            /* DIAL */
            _APP_SD_vInitFrameS801_CallList(pCtxCtrl->s212.pbType, pCtxCtrl->s212.pbIndex);
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS213(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            // one menü item only
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS301(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vInitFrameS305();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS305(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_SC_vButtonUpDown(&(pCtxCtrl->s305.spellerCtrl), pButton->id);

            _APP_SD_vRefreshFrame(pCtxCtrl);
            break;
        case enLogiButManMflOk:
        {
            switch( APP_SD_SC_vButtonOk(&(pCtxCtrl->s305.spellerCtrl)) )
            {
                case APP_SD_SC_CONTROL_DIAL:
                    APP_SD_SC_vReadSpelledText( &(pCtxCtrl->s305.spellerCtrl),
                                                &(pCtxCtrl->common.pFrameData->s305.spelledText));

                    _APP_SD_vInitFrameS801_PN( pCtxCtrl->common.pFrameData->s305.spelledText.data,
                                               pCtxCtrl->common.pFrameData->s305.spelledText.length,
                                               BT_TRUE);
                    break;
                case APP_SD_SC_CONTROL_ABORT:
                    _APP_SD_vCtxHistoryStepBack();
                    break;
                default:
                    _APP_SD_vRefreshFrame(pCtxCtrl);
                    break;
            }
            break;
        }
        case enLogiButManMflHook:
        {
            /* DIAL */
            APP_SD_SC_vReadSpelledText( &(pCtxCtrl->s305.spellerCtrl),
                                        &(pCtxCtrl->common.pFrameData->s305.spelledText));

            if(pCtxCtrl->common.pFrameData->s305.spelledText.length > 0)
            {
                _APP_SD_vInitFrameS801_PN( pCtxCtrl->common.pFrameData->s305.spelledText.data,
                                           pCtxCtrl->common.pFrameData->s305.spelledText.length,
                                           BT_TRUE);
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS306(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_SC_vButtonUpDown(&(pCtxCtrl->s306.spellerCtrl), pButton->id);

            _APP_SD_vRefreshFrame(pCtxCtrl);
            break;
        case enLogiButManMflOk:
        {
            switch( APP_SD_SC_vButtonOk(&(pCtxCtrl->s306.spellerCtrl)) )
            {
                case APP_SD_SC_CONTROL_DIAL:
                case APP_SD_SC_CONTROL_SAVE:
                {
                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->s306.subStateBtn   = APP_SD_S306_SAVE_MAILBOX_NUMBER_NOT_SENT;
                    pCtxCtrl->s306.buttonId      = pButton->id;
                    gAppSdContext.setMailboxCounter = 0;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(0),
                                                        0);
                    break;
                }
                case APP_SD_SC_CONTROL_ABORT:
                    _APP_SD_vCtxHistoryStepBack();
                    break;
                default:
                    _APP_SD_vRefreshFrame(pCtxCtrl);
                    break;
            }
            break;
        }
        case enLogiButManMflHook:
        {
            /* DIAL */
            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
            pCtxCtrl->s306.subStateBtn   = APP_SD_S306_SAVE_MAILBOX_NUMBER_NOT_SENT;
            pCtxCtrl->s306.buttonId      = pButton->id;
            gAppSdContext.setMailboxCounter = 0;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

/**************************************************/
// Sms
/**************************************************/
BooleanType _APP_SD_bHandleButtonS402(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS404(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            if(selIdx > pCtxCtrl->s404.numSms)
            {
                _APP_SD_vCtxHistoryStepBack();
            }
            else
            {
                _APP_SD_vInitFrameS405(selIdx);
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}
BooleanType _APP_SD_bHandleButtonS405(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            if(ERM_SIVR_FULL_SUPPORTED == ERM_enIsVcrSupported())                             /* RT 2429 */
            {
                switch( selIdx )
                {
                    case 1:
                        // darstellbar? 406 : 409
                        _APP_SD_vInitFrameS406(pCtxCtrl->s405.smsIndex);
                        break;
                    case 2:
                        // try to start voice recognition reading sms
                        // if it fails, stop this frame
                        if(SUCCESS != VCR_sFHapticTrigger(VCR_HAPTIC_READ_SMS,pCtxCtrl->s405.smsIndex))
                        {
                            _APP_SD_vInitFrameS928();
                        }
                        //_APP_SD_vInitFrameSC14(pCtxCtrl->s405.smsIndex);
                        break;
                    case 3:
                        _APP_SD_vInitFrameS213(pCtxCtrl->s405.smsIndex);
                        break;
                    case 4:
                        // Rückruf
                        _APP_SD_vInitFrameS801_PN(pCtxCtrl->s405.origin,
                                                  pCtxCtrl->s405.origin_len,
                                                  BT_TRUE);
                        break;
                    case 5:
                        // Löschen
                        _APP_SD_vInitFrameS413(pCtxCtrl->s405.smsIndex);
                        break;
                    case 6: // zurück
                        _APP_SD_vCtxHistoryStepBack();
                        break;
                    default:
                        break;
                }
            }
            else
            {
                switch( selIdx )
                {
                    case 1:
                        // darstellbar? 406 : 409
                        _APP_SD_vInitFrameS406(pCtxCtrl->s405.smsIndex);
                        break;
                    case 2:
                        _APP_SD_vInitFrameS213(pCtxCtrl->s405.smsIndex);
                        break;
                    case 3:
                        // Rückruf
                        _APP_SD_vInitFrameS801_PN(pCtxCtrl->s405.origin,
                                                  pCtxCtrl->s405.origin_len,
                                                  BT_TRUE);
                        break;
                    case 4:
                        // Löschen
                        _APP_SD_vInitFrameS413(pCtxCtrl->s405.smsIndex);
                        break;
                    case 5: // zurück
                        _APP_SD_vCtxHistoryStepBack();
                        break;
                    default:
                        break;
                }
            }
            break;
        }
        default:
            return BT_FALSE;

    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS406(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
            // zurück only

            if(BT_FALSE == _APP_SD_bPhoneContextActive())
            {
                DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "HandleButtonS406: release phone context");
                _APP_SD_vReleasePhoneContext();
            }
            else
            {
                DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "HandleButtonS406: historyStepBack");
                /* go back to context before voice reco was activated */
                _APP_SD_vCtxHistoryStepBack();
            }
            break;
        default:
            return BT_FALSE;

    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS407(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            if (gAppSdContext.searchStartedFromScreen == APP_SD_CONTEXT_INVALID)
            {
                _APP_SD_vInitIdleScreen(1);
            }
            else if (gAppSdContext.searchStartedFromScreen == APP_SD_CONTEXT_S502)
            {
                _APP_SD_vInitFrameS502(1);
            }
            else if (gAppSdContext.searchStartedFromScreen == APP_SD_CONTEXT_SC03)
            {
                _APP_SD_vInitFrameSC03(2);
            }

            gAppSdContext.searchStartedFromScreen = APP_SD_CONTEXT_INVALID;
            break;
        default:
            return BT_FALSE;

    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS409(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;

    }
    return BT_TRUE;
}



BooleanType _APP_SD_bHandleButtonS410(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;

    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS413(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;

        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            switch(selIdx)
            {
                case 1:
                    // trigger sms delete via pending button
                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->s413.subStateBtn   = APP_SD_S413_DELETE_SMS_NOT_SENT;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(0),
                                                        0);
                    // next frame S428 (error) or S425 (success) will be inited in
                    // ButtonPendingS413_Cb

                    break;
                case 2:
                    _APP_SD_vCtxHistoryStepBack();
                    break;
                default:

                    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton413: enOK not handled for pos %d",
                                  selIdx);
                    break;
            }
            break;
        }
        case enLogiButManMflBack:
            /* Zurück */
            _APP_SD_vCtxHistoryStepBack();
            break;

        default:
            return BT_FALSE;

    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS425(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    // sms was successfully deleted, now go back to sms menü depending on init
    // state and number of sms
    switch(pButton->id)
    {
        case enLogiButManMflOk:
        {
            /* SMS */
            APP_SMS_enSupportState smsSupport = APP_SMS_enGetSmsSupportState();
            switch( smsSupport)
            {
                case APP_SMS_NOT_INITIALIZED:
                    // wait for intialization to be finished
                    _APP_SD_vInitFrameS410();
                    break;
                case APP_SMS_INITIALIZED_AND_UNSUPPORTED:
                    /* no entries available */
                    _APP_SD_vInitFrameS402();
                    break;
                case APP_SMS_INITIALIZED_AND_SUPPORTED:
                {
                    Uint16Type numSms = APP_SMS_u16GetNumReadSms() +
                                        APP_SMS_u16GetNumUnreadSms();
                    if(numSms > 0)
                    {
                        _APP_SD_vInitFrameS404(numSms);
                    }
                    else
                    {
                        /* no entries available */
                        _APP_SD_vInitFrameS402();
                    }
                    break;
                }
                default:
                    /* no entries available */
                    _APP_SD_vInitFrameS402();
                    break;
            }
            break;
        }
        default:
            return BT_FALSE;

    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS428(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;

    }
    return BT_TRUE;
}

//****************************************************
// Bluetooth
//****************************************************
BooleanType _APP_SD_bHandleButtonS501(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
//              if((gAppSdContext.lastConnectionDevice.playerState == APP_SD_MDI_PLAY)&& \
//                 (APP_MDI_GetPlayStatus() != APP_MDI_ACT_STATE_PLAY))
//              {
//                  APP_MDI_sfSetPlayMode(APP_MDI_RESUME);
//              }
//              gAppSdContext.lastConnectionDevice.playerState = APP_SD_MDI_STOP;
            APP_MDI_bUnmutePlayer(APP_MDI_MUTE_DEVICE_SEARCH, UNMUTE_IMMEDIATELY);
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;

    }
    return BT_TRUE;
}



BooleanType _APP_SD_bHandleButtonS502(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));

            if((pCtxCtrl->s502.playerAvail == BT_FALSE) && selIdx >= 4)
            {
                /* offset 1 to use the list without MediaPlayer available */
                selIdx = selIdx + 1;
            }

            switch(selIdx)
            {
                case 1:
                    /* Benutzer */
                    _APP_SD_vInitFrameS541((Uint8Type)ERM_u16GetNumberOfUserProfiles());
                    break;
                case 2:
                    /* Neuer Benutzer */
                    gAppSdContext.searchStartedFromScreen = APP_SD_CONTEXT_S502;
                    if( APP_CAN_Speed_un16CurrentVehicleSpeed() < U16_SPEED_LIMIT_LOW )
                    {
                      // start inquiry as substate of frame init
                      if(BT_TRUE == APP_MDI_bMutePlayer(APP_MDI_MUTE_DEVICE_SEARCH))
                      {
                          _APP_SD_vInitFrameS522(APP_SD_MDI_MUTE_FOR_SEARCH, AT_INVALID_DEVICE_ID,
                                                 APP_DEVICE_enTYPE_UNKNOWN, BT_FALSE);
                      }
                      else
                      {
                        _APP_SD_vInitFrameS520();
                      }
                    }
                    else
                    {
                        _APP_SD_vInitFrameS407();
                    }
                    break;
                case 3:
                    /* Sichtbarkeit */
                    _APP_SD_vInitFrameS553();
                    break;
                case 4:
                    /* Media Player */
                    _APP_SD_vInitFrameSC03(0);
                    break;
#ifdef UHV_ACTIVATE_FEATURE_HEADSET
                case 5:
                    /* HeadSet */
                    _APP_SD_vInitFrameS562();
                    break;
                case 6:
                    /* Telefonname */
                    _APP_SD_vInitFrameS556();
                    break;
                case 7:
                    _APP_SD_vCtxHistoryStepBack();
                    break;
#else
                case 5:
                    /* Telefonname */
                    _APP_SD_vInitFrameS556();
                    break;
                case 6:
                    _APP_SD_vCtxHistoryStepBack();
                    break;
#endif
                default:

                    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton502: enOK not handled for pos %d",
                                  selIdx);
                    break;
            }
            break;
        }
        default:
            return BT_FALSE;

    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS511(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vInitFrameS512((Uint8Type)ERM_u16GetNumberOfUserProfiles(),gAppSdContext.pendingProfile.deviceId);
            break;
        default:
            return BT_FALSE;

    }
    return BT_TRUE;
}


BooleanType _APP_SD_bHandleButtonS512(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            if( (pCtxCtrl->s512.numDevs + 1 ) == selIdx )
            {
                /* zurück */
                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->s512.subStateBtn   = APP_SD_S512_DELETE_NOT_SENT;
                    gAppSdContext.deleteDeviceCounter = 0;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(0),
                                                        0);
//                _APP_SD_vInitIdleScreen(0);
            }
            else
            {
                /* user profiles are 0-based, selIdx is 1-based */
                const ERMUserProfileType * selectedProfile  = ERM_pGetUserProfile(selIdx-1);
                const ERMUserProfileType * activeProfile    = ERM_pGetActiveUserProfile();
                AT_DeviceId activeDeviceId                  = AT_INVALID_DEVICE_ID;
                AT_DeviceId deviceId                        = AT_INVALID_DEVICE_ID;

                if( NULL != activeProfile )
                {
                    activeDeviceId = activeProfile->deviceIndex;
                }
                //deviceId = ERM_GetDeviceIdOfUmpteenthPhone(selIdx);
                if( NULL != selectedProfile )
                {
                    deviceId = selectedProfile->deviceIndex;
                }

                if(deviceId != AT_INVALID_DEVICE_ID)
                {
                    // check if this device is currently active to decide about
                    // next frame
                    if( activeDeviceId == deviceId )
                    {
                        _APP_SD_vInitFrameS555(deviceId);
                    }
                    else
                    {
                        _APP_SD_vInitFrameS513(deviceId /* in ERM Table */);
                    }
                }
                else
                {
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "bHandleButton512: selIdx %d is not a phoneDev",
                                  selIdx);
                }
            }
            break;
        }
        case enLogiButManMflBack:
        {
            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
            pCtxCtrl->s512.subStateBtn   = APP_SD_S512_DELETE_NOT_SENT;
            pCtxCtrl->s512.deviceId      = ERM_GetLastPairedDeviceId();
            gAppSdContext.deleteDeviceCounter = 0;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS513(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    if(pCtxCtrl->s513.deletePressed == BT_TRUE)
    {

        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton513: del pressed, key ignored %x",
                      pButton->id);
        return BT_TRUE;
    }

    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            switch(selIdx)
            {
                case 1:
                    /* Ok (Löschen) */
                    // pending button, dann S514
                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->s513.subStateBtn   = APP_SD_S513_DELETE_NOT_SENT;
                    pCtxCtrl->s513.deletePressed = BT_TRUE;
                    gAppSdContext.deleteDeviceCounter = 0;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(0),
                                                        0);
                    break;
                case 2:
                    /* Zurück */
                    _APP_SD_vCtxHistoryStepBack();
                    break;
                default:
                    break;
            }
            break;
        }
        case enLogiButManMflBack:
            /* Zurück */
            _APP_SD_vCtxHistoryStepBack();
            break;

        default:
            return BT_FALSE;

    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS514(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            /* check if we needed to delete a user cause we want to create a new one */
            if( BT_TRUE == gAppSdContext.pendingProfile.bPending)
            {
                /* give the new user a name and create the profile */
                //_APP_SD_vInitFrameS535(gAppSdContext.pendingProfile.deviceId);
                _APP_SD_vInitFrameS534(gAppSdContext.pendingProfile.deviceId);
                (void)_APP_SD_vResetPendingProfile();
            }
            else
            {   /* go back to list of paired users */
                if( BT_TRUE == gAppSdContext.pCurCtxCtrl->s514.bIsActive )
                {   // deleted user was active
                    //RS: replaced because the handling is contained in InitIdleScreen
                    //_APP_SD_vInitFrameS002();
                    //if((gAppSdContext.lastConnectionDevice.playerState == APP_SD_MDI_PLAY)&& \
                    //   (APP_MDI_GetPlayStatus() != APP_MDI_ACT_STATE_PLAY))
                    //{
                    //    APP_MDI_sfSetPlayMode( /*NULL, */APP_MDI_RESUME);
                    //}
                    //gAppSdContext.lastConnectionDevice.playerState = APP_SD_MDI_STOP;
                    _APP_SD_vInitIdleScreen(0);
                }
                else
                {   // deleted user was not active
                    _APP_SD_vInitFrameS541((Uint8Type)ERM_u16GetNumberOfUserProfiles());
                }
            }
            break;
        default:
            return BT_FALSE;

    }
    return BT_TRUE;
}




BooleanType _APP_SD_bHandleButtonS515(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
        {
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        }
        case enLogiButManMflBack:
        {
            // Ticket #4502: We need to use HistoryStepBack if Phone Search was triggered from S002.
            // else we will have the wrong (first) menu entry being focussed instead of PhoneSearch menu entry
            Sint16Type s502HistIndex = _APP_SD_s16GetHistoryIndex(APP_SD_CONTEXT_S502);

            /* special handling for phone, since we can lose the active phone connection */
            if( (pCtxCtrl->s515.deviceType == APP_DEVICE_enTYPE_PHONE) &&
                (ERM_pGetActiveUserProfile() == NULL) &&
                (s502HistIndex != -1))
            {   /* --> Phone Search was triggered by BT main menu, but phone is now disconnected */
                _APP_SD_vInitIdleScreen(0);
            }
            else
            {   /* phone is still connected or phone search was triggered from S002, so we want to restore
                   the focussed menu item */
                _APP_SD_vCtxHistoryStepBack();
            }

            APP_MDI_bUnmutePlayer(APP_MDI_MUTE_DEVICE_CONNECT, UNMUTE_IMMEDIATELY);
            break;
        }
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));

            if( selIdx == (pCtxCtrl->s515.numDevs + 1))
            {
                // Ticket #4502: We need to use HistoryStepBack if Phone Search was triggered from S002.
                // else we will have the wrong (first) menu entry being focussed instead of PhoneSearch menu entry
                Sint16Type s502HistIndex = _APP_SD_s16GetHistoryIndex(APP_SD_CONTEXT_S502);

                /* special handling for phone, since we can lose the active phone connection */
                if( (pCtxCtrl->s515.deviceType == APP_DEVICE_enTYPE_PHONE) &&
                    (ERM_pGetActiveUserProfile() == NULL) &&
                    (s502HistIndex != -1) )
                {   /* --> Phone Search was triggered by BT main menu, but phone is now disconnected */
                    _APP_SD_vInitIdleScreen(0);
                }
                else
                {   /* phone is still connected or phone search was triggered from S002, so we want to restore
                       the focussed menu item */
                    _APP_SD_vCtxHistoryStepBack();
                }
            }
            else
            {
                // connect to device, disconnect active device ( if any )
                /* the device id was stored in handle list req */
                AT_DeviceId pairedDeviceId  = ERM_GetDeviceIdOfBtAddr(pCtxCtrl->s515.inqData.bt_addr);

                //switch A2DP and AVRCP service visibility of ck5050 off // reason: else no connection to some old nokia phones possible
                //e.g. Nokia N81/ N78 / N6210 E51
                _APP_SD_setPlayerVisibleIfEncoded(BT_FALSE);

                switch(pCtxCtrl->s515.deviceType)
                {
                    case APP_DEVICE_enTYPE_PLAYER:
                    case APP_DEVICE_enTYPE_HEADSET:
                    {
                        const ERMPlayerHeadsetProfileType *pActProfile = NULL;
                        if(pCtxCtrl->s515.deviceType == APP_DEVICE_enTYPE_PLAYER)
                        {
                            pActProfile = ERM_pGetActivePlayerProfile();
                        }
                        else
                        {
                            pActProfile = ERM_pGetActiveHeadsetProfile();
                        }

                        if(pActProfile == NULL)
                        {
                            // no actve player or headset
                            if(pairedDeviceId == AT_INVALID_DEVICE_ID)
                            { // selected inquiry device is unknown in our profile tabled
                                if(BT_TRUE == APP_MDI_bMutePlayer(APP_MDI_MUTE_DEVICE_CONNECT))
                                {
                                    _APP_SD_vInitFrameS522(APP_SD_MDI_MUTE_FOR_PAIRING, pCtxCtrl->s515.inqData.device_id,
                                                           pCtxCtrl->s515.deviceType, BT_FALSE);
                                }
                                else
                                {
                                    _APP_SD_vInitFrameS408_SSP(pCtxCtrl->s515.inqData.device_id,
                                                           pCtxCtrl->s515.deviceType);
                                }
                            }
                            else
                            {
                                /* this device is already in our device table, no pairing needed,
                                 * just connect */
                                if(BT_TRUE == APP_MDI_bMutePlayer(APP_MDI_MUTE_DEVICE_CONNECT))
                                {
                                    _APP_SD_vInitFrameS522(APP_SD_MDI_MUTE_FOR_CONNECT, pairedDeviceId,
                                                           pCtxCtrl->s515.deviceType, BT_TRUE);
                                }
                                else
                                {
                                    _APP_SD_vInitFrameS517( pairedDeviceId,
                                                          pCtxCtrl->s515.deviceType,
                                                          BT_TRUE);
                                }
                            }
                        }
                        else
                        {
                            if(pairedDeviceId == AT_INVALID_DEVICE_ID)
                            {
                                /* we have a connected player and a new device that needs pairing */
                                _APP_SD_vInitFrameS572( pCtxCtrl->s515.inqData.device_id,
                                                        pCtxCtrl->s515.deviceType,
                                                        BT_TRUE);
                            }
                            else if(pActProfile->deviceIndex == pairedDeviceId)
                            {
                                /* already connect to the same device */
                                _APP_SD_vInitFrameS573(pairedDeviceId);
                            }
                            else
                            {
                                /* we have a connected and known device that needs NO pairing */
                                _APP_SD_vInitFrameS572( pairedDeviceId,
                                                        pCtxCtrl->s515.deviceType,
                                                        BT_FALSE);
                            }
                            break;
                    }
                    case APP_DEVICE_enTYPE_PHONE:
                    {
                        AT_DeviceId activeId = ERM_u8GetActivePhone();
                        if( (activeId == AT_INVALID_DEVICE_ID) &&
                            (pairedDeviceId == AT_INVALID_DEVICE_ID))
                        {
                            /* no phone connected, device unknown */
                            if(BT_TRUE == APP_MDI_bMutePlayer(APP_MDI_MUTE_DEVICE_CONNECT))
                            {
                                _APP_SD_vInitFrameS522(APP_SD_MDI_MUTE_FOR_PAIRING, pCtxCtrl->s515.inqData.device_id,
                                                       pCtxCtrl->s515.deviceType, BT_FALSE);
                            }
                            else
                            {
                                _APP_SD_vInitFrameS408_SSP( pCtxCtrl->s515.inqData.device_id,pCtxCtrl->s515.deviceType);
                            }
                        }
                        else if(activeId == pairedDeviceId)
                        {
                            /* already connected to the same device */
                            _APP_SD_vInitFrameS543(activeId);
                        }
                        else
                        {
                            if(pairedDeviceId != AT_INVALID_DEVICE_ID)
                            {
                                /* this device is already in our device table, no pairing needed,
                                 * just connect */
                                if(BT_TRUE == APP_MDI_bMutePlayer(APP_MDI_MUTE_DEVICE_CONNECT))
                                {
                                    _APP_SD_vInitFrameS522(APP_SD_MDI_MUTE_FOR_CONNECT, pairedDeviceId,
                                                           pCtxCtrl->s515.deviceType, BT_TRUE);
                                }
                                else
                                {
                                  _APP_SD_vInitFrameS517( pairedDeviceId,pCtxCtrl->s515.deviceType,BT_TRUE);
                                }
                              }
                              else
                              {
                                if(BT_TRUE == APP_MDI_bMutePlayer(APP_MDI_MUTE_DEVICE_CONNECT))
                                {
                                    _APP_SD_vInitFrameS522(APP_SD_MDI_MUTE_FOR_PAIRING, pCtxCtrl->s515.inqData.device_id,
                                                           pCtxCtrl->s515.deviceType, BT_FALSE);
                                }
                                else
                                {
                                    _APP_SD_vInitFrameS408_SSP( pCtxCtrl->s515.inqData.device_id,pCtxCtrl->s515.deviceType);
                                }
                            }
                        }
                        break;
                    }
                }
            }
            break;
        }
        default:
            return BT_FALSE;

    }
    }
    return BT_TRUE;
}


BooleanType _APP_SD_bHandleButtonS518(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            APP_MDI_bUnmutePlayer(APP_MDI_MUTE_DEVICE_CONNECT, UNMUTE_IMMEDIATELY);
            _APP_SD_vCtxHistoryStepBack();
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS51D(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_SC_vButtonUpDown(&(pCtxCtrl->s51D.spellerCtrl), pButton->id);

            _APP_SD_vRefreshFrame(pCtxCtrl);
            break;
        case enLogiButManMflOk:
        {
            switch( APP_SD_SC_vButtonOk(&(pCtxCtrl->s51D.spellerCtrl)) )
            {
                case APP_SD_SC_CONTROL_OK:
                {
                    APP_SD_SC_vReadSpelledText( &(pCtxCtrl->s51D.spellerCtrl),
                                                &(pCtxCtrl->common.pFrameData->s51D.spelledText));
                    if(pCtxCtrl->common.pFrameData->s51D.spelledText.length > 0)
                    {
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s51D.subStateBtn   = APP_SD_S51D_PAIRING_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                    }
                    else
                    {

                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton51D: ignore OK press, len %x",
                                      pCtxCtrl->common.pFrameData->s51D.spelledText.length);
                    }
                    break;
                }
                case APP_SD_SC_CONTROL_ABORT:
//                      if((gAppSdContext.lastConnectionDevice.playerState == APP_SD_MDI_PLAY)&& \
//                         (APP_MDI_GetPlayStatus() != APP_MDI_ACT_STATE_PLAY))
//                      {
//                          APP_MDI_sfSetPlayMode(APP_MDI_RESUME);
//                      }
//                      gAppSdContext.lastConnectionDevice.playerState = APP_SD_MDI_STOP;
                    /* pairing is aborted, so unmute player */
                    APP_MDI_bUnmutePlayer(APP_MDI_MUTE_DEVICE_CONNECT, UNMUTE_IMMEDIATELY);
                    _APP_SD_vInitFrameS521();
                    break;
                default:
                    _APP_SD_vRefreshFrame(pCtxCtrl);
                    break;
            }
            break;
        }
        case enLogiButManMflBack:
        {
            APP_MDI_bUnmutePlayer(APP_MDI_MUTE_DEVICE_CONNECT, UNMUTE_IMMEDIATELY);
            _APP_SD_vInitFrameS521();
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS51D_ACCEPT(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_SC_vButtonUpDown(&(pCtxCtrl->s51D.spellerCtrl), pButton->id);

            _APP_SD_vRefreshFrame(pCtxCtrl);
            break;
        case enLogiButManMflOk:
        {
            switch( APP_SD_SC_vButtonOk(&(pCtxCtrl->s51D.spellerCtrl)) )
            {
                case APP_SD_SC_CONTROL_OK:
                {
                    APP_SD_SC_vReadSpelledText( &(pCtxCtrl->s51D.spellerCtrl),
                                                &(pCtxCtrl->common.pFrameData->s51D.spelledText));
                    if(pCtxCtrl->common.pFrameData->s51D.spelledText.length > 0)
                    {
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s51D.subStateBtn   = APP_SD_S51D_PAIRING_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                    }
                    else
                    {

                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton51D_ACCEPT: ignore OK press, len %x",
                                      pCtxCtrl->common.pFrameData->s51D.spelledText.length);
                    }
                    break;
                }
                case APP_SD_SC_CONTROL_ABORT:
                    /* Reject incoming pairing request */
                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->s51D.subStateBtn   = APP_SD_S51D_REJECT_NOT_SENT;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(0),
                                                        0);
                    break;
                default:
                    _APP_SD_vRefreshFrame(pCtxCtrl);
                    break;
            }
            break;
        }
        case enLogiButManMflBack:
            /* ignore back button */
            APP_MDI_bUnmutePlayer(APP_MDI_MUTE_DEVICE_CONNECT, UNMUTE_IMMEDIATELY);
            _APP_SD_vInitFrameS521();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS520(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflBack:
        case enLogiButManMflOk:
        {
//              if((gAppSdContext.lastConnectionDevice.playerState == APP_SD_MDI_PLAY)&& \
//                 (APP_MDI_GetPlayStatus() != APP_MDI_ACT_STATE_PLAY))
//              {
//                  APP_MDI_sfSetPlayMode(APP_MDI_RESUME);
//              }
//              gAppSdContext.lastConnectionDevice.playerState = APP_SD_MDI_STOP;
            /* search is aborted, restart player */
            APP_MDI_bUnmutePlayer(APP_MDI_MUTE_DEVICE_SEARCH, UNMUTE_IMMEDIATELY);

            if( pCtxCtrl->s520.subState == APP_SD_S520_START_INQUIRY_SENT)
            {
                pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                pCtxCtrl->s520.subStateBtn   = APP_SD_S520_CANCEL_INQUIRY_NOT_SENT;

                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                          MSEC(0),
                                                          0);
            }
            else
            {
                /* no cancel needed, since we have only a dummy frame visible */
                _APP_SD_vCtxHistoryStepBack();
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS521(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
        {
            _APP_SD_vCtxHistoryStepBack();
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS52C(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
    case enLogiButManMflUp:
    case enLogiButManMflDown:
        APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

        pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
        pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                            MSEC(0),
                                            0);
        break;
    case enLogiButManMflOk:
    {

        Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));

        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButtonS52C: enLogiButManMflOk %d", selIdx);
        switch(selIdx)
        {
            case 1:
            {

                pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                pCtxCtrl->s52C.subStateBtn   = APP_SD_S52C_SSP_CONFIRMED;
                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                        MSEC(0),
                        0);
                break;
            }
            case 2:
            {
                /* pairing is aborted, so unmute player */
                APP_MDI_bUnmutePlayer(APP_MDI_MUTE_DEVICE_CONNECT, UNMUTE_IMMEDIATELY);

                DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD,"_APP_SD_bHandleButtonS52C: Reject pairing.");
                pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                pCtxCtrl->s52C.subStateBtn   = APP_SD_S52C_SSP_NOT_CONFIRMED;
                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                        MSEC(0),
                        0);

                break;
            }
            default:
            {
                DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton933: OK not handled for pos %d",
                              selIdx);
                break;
            }
        }
        break;
    }
    case enLogiButManMflBack:
    {
        /* pairing is aborted, so unmute player */
        APP_MDI_bUnmutePlayer(APP_MDI_MUTE_DEVICE_CONNECT, UNMUTE_IMMEDIATELY);

        DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD,"_APP_SD_bHandleButtonS52C: Reject pairing.");
        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
        pCtxCtrl->s52C.subStateBtn   = APP_SD_S52C_SSP_NOT_CONFIRMED;
        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                MSEC(0),
                0);

        break;
    }
    default:
        return BT_FALSE;
    }
    return BT_TRUE;
}


BooleanType _APP_SD_bHandleButtonS533(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

//BooleanType _APP_SD_bHandleButtonS535(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
//{
//    const ERMBTDeviceTableType *pDevice = NULL;
//
//    switch(pButton->id)
//    {
//        case enLogiButManMflUp:
//        case enLogiButManMflDown:
//            APP_SD_SC_vButtonUpDown(&(pCtxCtrl->s535.spellerCtrl), pButton->id);
//            _APP_SD_vRefreshFrame(pCtxCtrl);
//            break;
//        case enLogiButManMflOk:
//        {
//            switch( APP_SD_SC_vButtonOk(&(pCtxCtrl->s535.spellerCtrl)) )
//            {
//                case APP_SD_SC_CONTROL_OK:
//                {
//                    AT_DeviceId i = 0;
//                    AppSdSpelledTextType spelledText;
//                    APP_SD_SC_vReadSpelledText( &(pCtxCtrl->s535.spellerCtrl),
//                                                &spelledText);
//                    if(spelledText.length>0)
//                    {
//                        for( i=0; i<=AT_MAX_DEVICE_ID; i++)
//                        {
//                            /* check if name already exists */
//
//                            if(pCtxCtrl->s535.deviceId == i)
//                            {
//                                continue;
//                            }
//                            pDevice = ERM_GetBTDevice(i);
//                            if( (spelledText.length == pDevice->device_name_len) &&
//                                (memcmp(pDevice->device_name, spelledText.data, spelledText.length) == 0) )
//                            {
//                                _APP_SD_vInitFrameS532();
//                                return BT_TRUE;
//                            }
//                        }
//                    }
//                    else
//                    {
//
//                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "HandleButtonS535: OK ignored with len %d",
//                                      spelledText.length);
//                        return BT_TRUE;
//                    }
//
//                    // trigger to save name of new profile
//                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
//                    pCtxCtrl->s535.subStateBtn   = APP_SD_S535_ADD_NEW_PROFILE_NOT_SENT;
//                    gAppSdContext.addProfileCounter = 0;
//
//                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
//                                                        MSEC(0),
//                                                        0);
//                    break;
//                }
//                case APP_SD_SC_CONTROL_ABORT:
//                {
//                    if(ERM_u8GetPlayerHeadsetProfileId(pCtxCtrl->s535.deviceId) == AT_INVALID_DEVICE_ID)
//                    {
//                        /* if the device is not use by player or headset remove it from the CK5050 */
//                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
//                        pCtxCtrl->s535.subStateBtn   = APP_SD_S535_DELETE_DEVICE_NOT_SENT;
//
//                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
//                                                            MSEC(0),
//                                                            0);
//                    }
//                    else
//                    {
//                        /* if the device is not use by player or headset remove it from the CK5050 */
//                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
//                        pCtxCtrl->s535.subStateBtn   = APP_SD_S535_DELETE_NOT_SENT;
//
//                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
//                                                            MSEC(0),
//                                                            0);
////                        _APP_SD_vInitFrameS539();
//                    }
//                    break;
//                }
//                default:
//                    _APP_SD_vRefreshFrame(pCtxCtrl);
//                    break;
//            }
//            break;
//        }
//        default:
//            return BT_FALSE;
//    }
//    return BT_TRUE;
//}



BooleanType _APP_SD_bHandleButtonS536(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_SC_vButtonUpDown(&(pCtxCtrl->s536.spellerCtrl), pButton->id);

            _APP_SD_vRefreshFrame(pCtxCtrl);
            break;
        case enLogiButManMflOk:
        {
            switch( APP_SD_SC_vButtonOk(&(pCtxCtrl->s536.spellerCtrl)) )
            {
                case APP_SD_SC_CONTROL_OK:
                {
                    //AT_DeviceId i = 0;
                    //AppSdSpelledTextType spelledText;
                    //APP_SD_SC_vReadSpelledText( &(pCtxCtrl->s536.spellerCtrl),
                    //                            &spelledText);

                    //for( i=0; i<=AT_MAX_DEVICE_ID; i++)
                    //{
                    //    /* check if name already exists */
                    //    const ERMBTDeviceTableType *pDevice = NULL;
                    //    if(pCtxCtrl->s536.deviceId == i)
                    //    {
                    //        continue;
                    //    }
                    //    pDevice = ERM_GetBTDevice(i);
                    //    if( (spelledText.length == pDevice->device_name_len) &&
                    //        (memcmp(pDevice->device_name, spelledText.data, spelledText.length) == 0) )
                    //    {
                    //        _APP_SD_vInitFrameS532();
                    //        return BT_TRUE;
                    //    }
                    //}

                    // TODO: call ERM function to save Name persistently, this
                    // should copy name to BTDeviceTable, too!!!!!!
                    //if(ERM_bSetDeviceName(  pCtxCtrl->s536.deviceId,
                    //                        spelledText.data,
                    //                        spelledText.length) != BT_TRUE)
                    //{


                    //}
                    //_APP_SD_vInitFrameS533();

                    // trigger to save new name of profile

                    /*RT13152*/
                    AppSdSpelledTextType spelledText;
                    APP_SD_SC_vReadSpelledText( &(pCtxCtrl->s536.spellerCtrl),
                                                &spelledText);

                    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "13152: Before OK splledText length = %d",spelledText.length);

                    if(0 == spelledText.length)
                    {
                        DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "13152: NULL String is not a valid name");
                        _APP_SD_vRefreshFrame(pCtxCtrl);
                    }
                    else
                    {
                        // trigger to save new name of profile
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s536.subStateBtn   = APP_SD_S536_CHANGE_PROFILE_NOT_SEND;

                       (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                 MSEC(0),
                                                                 0);
                    }
                    break;
                }
                case APP_SD_SC_CONTROL_ABORT:
                    _APP_SD_vCtxHistoryStepBack();
                    break;
                default:
                    _APP_SD_vRefreshFrame(pCtxCtrl);
                    break;
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS541(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            if( (pCtxCtrl->s541.numDevs + 1 ) == selIdx )
            {
                /* zurück */
                _APP_SD_vCtxHistoryStepBack();
            }
            else
            {
                // get deviceId in ERM Table for selected Index ( -1 cause
                // profiles are 0-based )
                const ERMUserProfileType * activeProfile    = ERM_pGetActiveUserProfile();
                BooleanType bIsActive                       = BT_FALSE;
                AT_DeviceId activeDeviceId                  = AT_INVALID_DEVICE_ID;
                AT_DeviceId deviceId                        = ERM_GetDeviceIdOfUmpteenthPhone(selIdx);

                if( NULL != activeProfile )
                {
                    activeDeviceId = activeProfile->deviceIndex;
                }

                if(deviceId != AT_INVALID_DEVICE_ID)
                {
                    // check if this device is currently active ( needed for number
                    // of menue entries in S542 )
                    if( activeDeviceId == deviceId )
                    {
                        bIsActive = BT_TRUE;
                    }
                    _APP_SD_vInitFrameS542(deviceId /* in ERM Table */,
                                           bIsActive);
                }
                else
                {

                    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton541: selIdx %d is not a phoneDev",
                                  selIdx);
                }
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}
BooleanType _APP_SD_bHandleButtonS541_2(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            if( (pCtxCtrl->s541.numDevs + 1 ) == selIdx )
            {
                /* zurück */
                _APP_SD_vCtxHistoryStepBack();
            }
            else
            {
                // get deviceId in ERM Table for selected Index ( -1 cause
                // profiles are 0-based )
                const ERMUserProfileType * activeProfile    = ERM_pGetActiveUserProfile();
                AT_DeviceId activeDeviceId                  = AT_INVALID_DEVICE_ID;
                AT_DeviceId deviceId                        = ERM_GetDeviceIdOfUmpteenthPhone(selIdx);

                if( NULL != activeProfile )
                {
                    activeDeviceId = activeProfile->deviceIndex;
                }

                if(deviceId != AT_INVALID_DEVICE_ID)
                {
                    // check if this device is currently active ( needed for number
                    // of menue entries in S542 )
                    if( activeDeviceId == deviceId )
                    {
                        _APP_SD_vInitFrameS543(deviceId);
                        return BT_TRUE;
                    }
                }

                /* Verbinden */

                //switch A2DP and AVRCP service visibility of ck5050 off // reason: else no connection to some old nokia phones possible
                //e.g. Nokia N81/ N78 / N6210 E51
                _APP_SD_setPlayerVisibleIfEncoded(BT_FALSE);
                if(BT_TRUE == APP_MDI_bMutePlayer(APP_MDI_MUTE_DEVICE_CONNECT))
                {
                    _APP_SD_vInitFrameS522(APP_SD_MDI_MUTE_FOR_CONNECT, ERM_GetDeviceIdOfUmpteenthPhone(selIdx),
                                           APP_DEVICE_enTYPE_PHONE, BT_TRUE);
                }
                else
                {
                    _APP_SD_vInitFrameS517(ERM_GetDeviceIdOfUmpteenthPhone(selIdx),
                                           APP_DEVICE_enTYPE_PHONE,
                                           BT_TRUE);
                }
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS542(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));

            // menue depends on active state of deviceId
            if( BT_TRUE == pCtxCtrl->s542.bIsActive )
            {
                switch(selIdx)
                {
                    case 1:
                        /* Verbinden ( but already active )*/
                        _APP_SD_vInitFrameS543(pCtxCtrl->s542.deviceId);
                        break;
                    case 2:
                        /* Trennen */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s542.subStateBtn   = APP_SD_S542_DISCONNECT_NOT_SENT;
                        gAppSdContext.disconnectPlayerCounter = 0;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 3:
                        /* Umbenennen */
                        _APP_SD_vInitFrameS536(pCtxCtrl->s542.deviceId);
                        break;
                    case 4:
                        /* Löschen */
                        _APP_SD_vInitFrameS555(pCtxCtrl->s542.deviceId);
                        break;
                    case 5:
                        /* Zurück */
                        _APP_SD_vCtxHistoryStepBack();
                        break;
                    default:
                        break;
                }
            }
            else
            {
                switch(selIdx)
                {
                    case 1:
                        /* Verbinden */

                        //switch A2DP and AVRCP service visibility of ck5050 off // reason: else no connection to some old nokia phones possible
                        //e.g. Nokia N81/ N78 / N6210 E51
                        _APP_SD_setPlayerVisibleIfEncoded(BT_FALSE);
                        if(BT_TRUE == APP_MDI_bMutePlayer(APP_MDI_MUTE_DEVICE_CONNECT))
                        {
                            _APP_SD_vInitFrameS522(APP_SD_MDI_MUTE_FOR_CONNECT, pCtxCtrl->s542.deviceId,
                                                   APP_DEVICE_enTYPE_PHONE, BT_TRUE);
                        }
                        else
                        {
                            _APP_SD_vInitFrameS517(pCtxCtrl->s542.deviceId,
                                                   APP_DEVICE_enTYPE_PHONE,
                                                   BT_TRUE);
                        }
                        break;
                    case 2:
                        /* Umbenennen */
                        _APP_SD_vInitFrameS536(pCtxCtrl->s542.deviceId);
                        break;
                    case 3:
                        /* Löschen */
                        _APP_SD_vInitFrameS513(pCtxCtrl->s542.deviceId);
                        break;
                    case 4:
                        /* Zurück */
                        _APP_SD_vCtxHistoryStepBack();
                        break;
                    default:
                        break;
                }
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS543(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            /* don't do InitFrameS541 to go back, since we step into S543 from APP_SD_CONTEXT_S515 too */
            //_APP_SD_vInitFrameS541(ERM_u16GetNumberOfUserProfiles());
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}


BooleanType _APP_SD_bHandleButtonS553(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            switch(selIdx)
            {
                case 1:
                    /* set visibilty on */
                    ERM_vCb3BM_BTVisibility();
                    break;
                case 2:
                    _APP_SD_vCtxHistoryStepBack();
                    break;

                default:

                    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton553: enOK not handled for pos %d",
                                  selIdx);
                    break;
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS554(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS555(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    if(pCtxCtrl->s555.deletePressed == BT_TRUE)
    {

        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton555: del pres, key ignored %x",
                      pButton->id);
        return BT_TRUE;
    }


    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            switch(selIdx)
            {
                case 1:
                    /* Ok (Löschen) */
                    // pending button, dann S514
                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->s555.subStateBtn   = APP_SD_S555_DELETE_NOT_SENT;
                    pCtxCtrl->s555.deletePressed = BT_TRUE;
                    gAppSdContext.deleteDeviceCounter = 0;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(0),
                                                        0);
                    break;
                case 2:
                    /* Zurück */
                    _APP_SD_vCtxHistoryStepBack();
                    break;
                default:
                    break;
            }
            break;
        }

        case enLogiButManMflBack:
            /* Zurück */
            _APP_SD_vCtxHistoryStepBack();
            break;

        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}



BooleanType _APP_SD_bHandleButtonS556(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_SC_vButtonUpDown(&(pCtxCtrl->s556.spellerCtrl), pButton->id);
            _APP_SD_vRefreshFrame(pCtxCtrl);
            break;
        case enLogiButManMflOk:
        {
            switch( APP_SD_SC_vButtonOk(&(pCtxCtrl->s804.spellerCtrl)) )
            {
                case APP_SD_SC_CONTROL_ABORT:
                    _APP_SD_vCtxHistoryStepBack();
                    break;
                case APP_SD_SC_CONTROL_OK:

                    /*RT15575: UHV name should not be null string*/
                    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "15575: Before OK splledText length = %d",pCtxCtrl->s556.spellerCtrl.common.spellBuffer.pos);

                    if(pCtxCtrl->s556.spellerCtrl.common.spellBuffer.pos != 0)
                    {
                        /* Set BT-DeviceName */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s556.subStateBtn   = APP_SD_S556_DEVICE_NAME_NOT_SENT;
                        gAppSdContext.saveBtNameCounter = 0;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                    }
                    else
                    {
                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "15575: NullString is Not valid splledText length = %d",pCtxCtrl->s556.spellerCtrl.common.spellBuffer.pos);
                        _APP_SD_vRefreshFrame(pCtxCtrl);
                    }
                    break;
                default:
                    _APP_SD_vRefreshFrame(pCtxCtrl);
                    break;
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS562(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            switch(selIdx)
            {
                case 1:
                {
                    /* Aktives Gerät */
                    const ERMPlayerHeadsetProfileType * profile = ERM_pGetActiveHeadsetProfile();
                    if( NULL != profile && APP_DEVICE_enTYPE_HEADSET == profile->deviceType /* HeadSet connected*/ )
                    {
                        _APP_SD_vInitFrameS563(profile->deviceIndex, APP_DEVICE_enTYPE_HEADSET);
                    }
                    else
                    {
                        _APP_SD_vInitFrameS566();
                    }
                    break;
                }
                case 2:
                {
                    /* Gekoppelte Geräte */
                    Uint16Type numHeadSetProfiles = ERM_u16GetNumberOfHeadsetProfiles();
                    if( 0 < numHeadSetProfiles /* number of paired headsets */ )
                    {
                        _APP_SD_vInitFrameS567((Uint8Type)numHeadSetProfiles);
                    }
                    else
                    {
                        _APP_SD_vInitFrameS568();
                    }
                    break;
                }
                case 3:
                {
                    /* Suche */
                    /*start search only if v < 6 km/h */
                    if( APP_CAN_Speed_un16CurrentVehicleSpeed() < U16_SPEED_LIMIT_LOW )
                    {
                        if(BT_TRUE == APP_MDI_bMutePlayer(APP_MDI_MUTE_DEVICE_SEARCH))
                        {
                            _APP_SD_vInitFrameS522(APP_SD_MDI_MUTE_FOR_SEARCH, AT_INVALID_DEVICE_ID,
                                    APP_DEVICE_enTYPE_UNKNOWN, BT_FALSE);
                        }
                        else
                        {
                            _APP_SD_vInitFrameS581();
                        }
                    }
                    else
                    {
                        _APP_SD_vInitFrameS407();
                    }
                    break;
                }
                case 4:
                    _APP_SD_vCtxHistoryStepBack();
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton562: enOK not handled for pos %d",
                                  selIdx);
                    break;
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}


BooleanType _APP_SD_bHandleButtonS563(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            switch(selIdx)
            {
                case 1:
                    /* Trennen */
                    gAppSdContext.disconnectPlayerCounter  = 0;
                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->s563.subStateBtn   = APP_SD_S563_DISCONNECT_NOT_SENT;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(0),
                                                        0);
                    break;
                case 2:
                    /* Zurück */
                    _APP_SD_vCtxHistoryStepBack();
                    break;
                default:
                    break;
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS565(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS566(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS567(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            if( (pCtxCtrl->s567.numDevs + 1 ) == selIdx )
            {
                /* zurück */
                _APP_SD_vCtxHistoryStepBack();
            }
            else
            {
                // get deviceId in ERM Table for selected Index
                Uint16Type deviceId         = AT_INVALID_DEVICE_ID;
                deviceId = ERM_GetDeviceIdOfUmpteenthHeadset(selIdx);

                _APP_SD_vInitFrameS571(deviceId /* in ERM Table */,
                                       APP_DEVICE_enTYPE_HEADSET );
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS5B2(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            if( (pCtxCtrl->s5B2.numDevs + 1 ) == selIdx )
            {
                /* zurück */
                _APP_SD_vCtxHistoryStepBack();
            }
            else
            {
                // get deviceId in ERM Table for selected Index
                Uint16Type deviceId         = AT_INVALID_DEVICE_ID;
                deviceId = ERM_GetDeviceIdOfUmpteenthPlayer(selIdx);

                _APP_SD_vInitFrameS571(deviceId /* in ERM Table */,
                                       APP_DEVICE_enTYPE_PLAYER );
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}



BooleanType _APP_SD_bHandleButtonS568(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}


BooleanType _APP_SD_bHandleButtonS571(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));

            AT_DeviceId activeDevId = AT_INVALID_DEVICE_ID;
            if(APP_DEVICE_enTYPE_PLAYER == pCtxCtrl->s571.deviceType )
            {
                activeDevId = ERM_u8GetActivePlayer();
            }
            else if( APP_DEVICE_enTYPE_HEADSET == pCtxCtrl->s571.deviceType )
            {
                activeDevId = ERM_u8GetActiveHeadSet();
            }

            switch(selIdx)
            {
                case 1:
                {
                    /* Verbinden */
                    if( activeDevId == pCtxCtrl->s571.deviceId )
                    {   /* already connected */
                        _APP_SD_vInitFrameS573(pCtxCtrl->s571.deviceId);
                    }
                    else if( activeDevId == AT_INVALID_DEVICE_ID )
                    {   /* no to device type connection */
                        if( ERM_bIsStartupDone() )
                        {
                            if(BT_TRUE == APP_MDI_bMutePlayer(APP_MDI_MUTE_DEVICE_CONNECT))
                            {
                                _APP_SD_vInitFrameS522(APP_SD_MDI_MUTE_FOR_CONNECT, pCtxCtrl->s571.deviceId,
                                        pCtxCtrl->s571.deviceType, BT_TRUE);
                            }
                            else
                            {
                                _APP_SD_vInitFrameS517(pCtxCtrl->s571.deviceId, pCtxCtrl->s571.deviceType, BT_TRUE);
                            }
                        }
                        else
                        {
                            /* do not connect, just show the frame and wait for ERM_NOTIFY_STARTUP_DONE event */
                            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HaButtonS571: just show and wait for ERM startUp");
                            if(BT_TRUE == APP_MDI_bMutePlayer(APP_MDI_MUTE_DEVICE_CONNECT))
                            {
                                _APP_SD_vInitFrameS522(APP_SD_MDI_MUTE_FOR_CONNECT, pCtxCtrl->s571.deviceId,
                                        pCtxCtrl->s571.deviceType, BT_FALSE);
                            }
                            else
                            {
                                _APP_SD_vInitFrameS517(pCtxCtrl->s571.deviceId,
                                        pCtxCtrl->s571.deviceType,
                                        BT_FALSE);
                            }
                        }
                    }
                    else
                    {   /* connected to another device with deviceType */
                        _APP_SD_vInitFrameS572(pCtxCtrl->s571.deviceId,
                                pCtxCtrl->s571.deviceType,
                                BT_FALSE);
                    }
                    break;
                }
                case 2:
                    /* Umbenennen */
                    _APP_SD_vInitFrameS575(pCtxCtrl->s571.deviceId,
                                           pCtxCtrl->s571.deviceType);
                    break;
                case 3:
                {
                    /* Löschen */
                    // For device type player, check if device is also a
                    // phone used in a profile, then show SC04
                    if( APP_DEVICE_enTYPE_PLAYER == pCtxCtrl->s571.deviceType &&
                        BT_TRUE == ERM_bDeviceInUserProfiles(pCtxCtrl->s571.deviceId))
                    {
                        _APP_SD_vInitFrameSC04();
                    }
                    /* deviceType is Headset or Player is not used in user profile table */
                    else if( activeDevId == pCtxCtrl->s571.deviceId )
                    {
                        _APP_SD_vInitFrameS579(pCtxCtrl->s571.deviceId, pCtxCtrl->s571.deviceType);
                    }
                    else
                    {
                        _APP_SD_vInitFrameS576(pCtxCtrl->s571.deviceId, pCtxCtrl->s571.deviceType);
                    }
                    break;
                }
                case 4:
                    /* Zurück */
                    _APP_SD_vCtxHistoryStepBack();
                    break;
                default:
                    break;
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS572(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(0), 0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            switch(selIdx)
            {
                case 1:
                    /* Ok */
                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->s572.subStateBtn   = APP_SD_S572_DISCONNECT_NOT_SENT;

                    gAppSdContext.disconnectPlayerCounter = 0;
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(0), 0);
                    break;
                case 2:
                    /* Zurück */
                    _APP_SD_vCtxHistoryStepBack();
                    break;
                default:
                    break;
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS573(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            /* Zurück */
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS574(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vInitIdleScreen(0);
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS575(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_SC_vButtonUpDown(&(pCtxCtrl->s575.spellerCtrl), pButton->id);

            _APP_SD_vRefreshFrame(pCtxCtrl);
            break;
        case enLogiButManMflOk:
        {
            switch( APP_SD_SC_vButtonOk(&(pCtxCtrl->s575.spellerCtrl)) )
            {
                case APP_SD_SC_CONTROL_OK:
                {
                    if( ERM_bIsStartupDone() )
                    {
                        //AT_DeviceId i = 0;
                        //AppSdSpelledTextType spelledText;
                        //APP_SD_SC_vReadSpelledText( &(pCtxCtrl->s575.spellerCtrl),
                        //                            &spelledText);

                        //for( i=0; i<=AT_MAX_DEVICE_ID; i++)
                        //{
                        //    const ERMBTDeviceTableType *pDevice = NULL;
                        //    if(pCtxCtrl->s575.deviceId == i)
                        //    {
                        //        continue;
                        //    }
                        //    pDevice = ERM_GetBTDevice(i);

                        //    /* first check if name already exists */
                        //    if( (spelledText.length == pDevice->device_name_len) &&
                        //        (memcmp(pDevice->device_name, spelledText.data, spelledText.length) == 0) )
                        //    {
                        //        _APP_SD_vInitFrameS532();
                        //        return BT_TRUE;
                        //    }
                        //}

                        // Name is not yet used, try to save it via changing of
                        // existing profile
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s575.subStateBtn   = APP_SD_S575_CHANGE_PROFILE_NOT_SEND;
                        gAppSdContext.renameCounter  = 0;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                    }
                    else
                    {
                      // ignore the button press, since we need BTDeviceTable available
                        DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HandleButtonS575: OK ignored, wait for ERM_bIsStartupDone");
                    }
                    break;
                }
                case APP_SD_SC_CONTROL_ABORT:
                    _APP_SD_vCtxHistoryStepBack();
                    break;
                default:
                    _APP_SD_vRefreshFrame(pCtxCtrl);
                    break;
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}



BooleanType _APP_SD_bHandleButtonS576(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    if(pCtxCtrl->s576.deletePressed == BT_TRUE)
    {

            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton576: del pressed, key ignored %x",
                          pButton->id);
        return BT_TRUE;
    }

    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(0), 0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            switch(selIdx)
            {
                case 1:
                    if( ERM_bIsStartupDone() )
                    {
                      /* Ok (Löschen) */
                      // pending button, dann S578
                      pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                      pCtxCtrl->s576.subStateBtn   = APP_SD_S576_DELETE_NOT_SENT;
                      pCtxCtrl->s576.deletePressed = BT_TRUE;
                      gAppSdContext.deleteDeviceCounter = 0;

                      (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                          MSEC(0),
                                                          0);
                    }
                    //else: ignore the button, since we need the CK5050 up to delete

                    break;
                case 2:
                    /* Zurück */
                    _APP_SD_vCtxHistoryStepBack();
                    break;
                default:
                    break;
            }
            break;
        }

        case enLogiButManMflBack:
            /* Zurück */
            _APP_SD_vCtxHistoryStepBack();
            break;

        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS578(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
        {
            // depending on device type and if the last device of
            // device type was deleted, go to next context
            Uint16Type numProfiles = 0;
            switch( gAppSdContext.pCurCtxCtrl->s578.deviceType )
            {
                case APP_DEVICE_enTYPE_HEADSET:
                    numProfiles = ERM_u16GetNumberOfHeadsetProfiles();
                    if( 0 < numProfiles )
                    {
                        _APP_SD_vInitFrameS567((Uint8Type)numProfiles);
                    }
                    else
                    {
                        _APP_SD_vInitFrameS562();
                    }
                    break;
                case APP_DEVICE_enTYPE_PLAYER:
                    numProfiles = ERM_u16GetNumberOfPlayerProfiles();
                    if( 0 < numProfiles )
                    {
                        _APP_SD_vInitFrameS5B2((Uint8Type)numProfiles);
                    }
                    else
                    {
                        _APP_SD_vInitFrameSC03(0);
                    }
                    break;
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS579(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    if(pCtxCtrl->s579.deletePressed == BT_TRUE)
    {

        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton579: del pressed, key ignored %x",
                      pButton->id);
        return BT_TRUE;
    }

    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            switch(selIdx)
            {
                case 1:
                    /* Ok (Löschen) */
                    // pending button, dann S578
                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->s579.subStateBtn   = APP_SD_S579_DELETE_NOT_SENT;
                    pCtxCtrl->s579.deletePressed = BT_TRUE;
                    gAppSdContext.deleteDeviceCounter = 0;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(0), 0);
                    break;
                case 2:
                    /* Zurück */
                    _APP_SD_vCtxHistoryStepBack();
                    break;
                default:
                    break;
            }
            break;
        }

        case enLogiButManMflBack:
            /* Zurück */
            _APP_SD_vCtxHistoryStepBack();
            break;

        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

//BooleanType _APP_SD_bHandleButtonS580(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
//{
//    const ERMBTDeviceTableType *ermBTDeviceTabletemp = NULL;
//    switch(pButton->id)
//    {
//        case enLogiButManMflUp:
//        case enLogiButManMflDown:
//            APP_SD_SC_vButtonUpDown(&(pCtxCtrl->s580.spellerCtrl), pButton->id);
//
//            _APP_SD_vRefreshFrame(pCtxCtrl);
//            break;
//        case enLogiButManMflOk:
//        {
//            switch( APP_SD_SC_vButtonOk(&(pCtxCtrl->s580.spellerCtrl)) )
//            {
//                case APP_SD_SC_CONTROL_OK:
//                {
//                    DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButtonS580: push control ok");
//                    //AT_DeviceId i = 0;
//                    //AppSdSpelledTextType spelledText;
//                    //DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButtonS580: push control ok");
//                    //APP_SD_SC_vReadSpelledText( &(pCtxCtrl->s580.spellerCtrl),
//                    //                            &spelledText);
//                    ///* check if name is already used */
//                    //for( i=0; i<=AT_MAX_DEVICE_ID; i++)
//                    //{
//                    //    const ERMBTDeviceTableType *pDevice = NULL;
//                    //    if(pCtxCtrl->s580.deviceId == i)
//                    //    {
//                    //        continue;
//                    //    }
//                    //    pDevice = ERM_GetBTDevice(i);
//                    //    /* check if name already exists */
//                    //    if( (spelledText.length == pDevice->device_name_len) &&
//                    //        (memcmp(pDevice->device_name, spelledText.data, spelledText.length) == 0) )
//                    //    {   /* name already used */
//                    //        _APP_SD_vInitFrameS532();
//                    //        return BT_TRUE;
//                    //    }
//                    //}
//
//                    ermBTDeviceTabletemp = ERM_GetBTDevice(pCtxCtrl->s580.deviceId);
//                    // Name is not yet used, try to save it via creation of a new profile
//                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
//
//                    switch( pCtxCtrl->s580.deviceType )
//                    {
//                        case APP_DEVICE_enTYPE_PLAYER:
//                            /* Ticket 8480: we check for a mixed device (phone and mediaplayer combined)
//                             * if such device is detected we handle it like a phone device via user profiles.
//                             */
//                            if( AT_SUPPORTED == ermBTDeviceTabletemp[0].phone_supported)
//                            {
//                                if ( BT_FALSE == ERM_bMaxNumberOfUserProfilesReached()) {
//
//                                    pCtxCtrl->s580.subStateBtn = APP_SD_S580_ADD_NEW_USER_PROFILE_NOT_SEND;
//                                }
//                                else {
//                                    /* same behavior like with new phones, see S007 */
//                                    gAppSdContext.pendingProfile.bPending       = BT_TRUE;
//                                    gAppSdContext.pendingProfile.profileType    = APP_DEVICE_enTYPE_PHONE;
//                                    gAppSdContext.pendingProfile.deviceId       = pCtxCtrl->s580.deviceId;
//                                    _APP_SD_vInitFrameS511();
//                                    //pCtxCtrl->s580.subStateBtn = APP_SD_S580_DELETE_OLDEST_USER_PROFILE_NOT_SENT;
//                                }
//
//                            }
//                            else
//                            {
//                                if( BT_FALSE == ERM_bMaxNumberOfPlayerProfilesReached())
//                                    pCtxCtrl->s580.subStateBtn   = APP_SD_S580_ADD_NEW_PLAYER_PROFILE_NOT_SEND;
//                                else
//                                    pCtxCtrl->s580.subStateBtn   = APP_SD_S580_DELETE_OLDEST_PLAYER_PROFILE_NOT_SENT;
//
//                            }
//
//
//// old code before ticket 8480 was fixed:
////                            /* check if max number of player profiles has been
////                             * reached or profile table is full so we need to delete a profile from player / headset table */
////                            if(( BT_TRUE == ERM_bMaxNumberOfUserProfilesReached() ) && \
////                               ( AT_SUPPORTED == ermBTDeviceTabletemp[0].phone_supported) )
////                            {
////                                pCtxCtrl->s580.subStateBtn = APP_SD_S580_DELETE_OLDEST_PROFILE_NOT_SENT;
////                            }
////                            else if( BT_TRUE == ERM_bMaxNumberOfPlayerProfilesReached() ||
////                                BT_TRUE == ERM_bMaxNumberOfPlayerHeadsetProfilesReached())
////                            {
////                                pCtxCtrl->s580.subStateBtn = APP_SD_S580_DELETE_OLDEST_PROFILE_NOT_SENT_2;
////                            }
//                            break;
//                        case APP_DEVICE_enTYPE_HEADSET:
//                            /* check if max number of headset profiles has been
//                             * reached or profile table is full so we need to delete a profile from player / headset table */
//                            if( BT_TRUE == ERM_bMaxNumberOfHeadsetProfilesReached() ||
//                                BT_TRUE == ERM_bMaxNumberOfPlayerHeadsetProfilesReached())
//                            {
//                                pCtxCtrl->s580.subStateBtn = APP_SD_S580_DELETE_OLDEST_PLAYER_PROFILE_NOT_SENT;
//                            }
//                            break;
//                    }
//                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
//                                                        MSEC(0), 0);
//                    break;
//                }
//                case APP_SD_SC_CONTROL_ABORT:
//                {
//                    DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButtonS580: push control abort");
//                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
//                    pCtxCtrl->s580.subStateBtn   = APP_SD_S580_DELETE_CURRENT_PROFILE_NOT_SENT;
//                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
//                                                        MSEC(0), 0);
////                    _APP_SD_vCtxHistoryStepBack();
//                    break;
//                }
//                default:
//                    _APP_SD_vRefreshFrame(pCtxCtrl);
//                    break;
//            }
//            break;
//        }
//        default:
//            return BT_FALSE;
//    }
//    return BT_TRUE;
//}

BooleanType _APP_SD_bHandleButtonS581(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflBack:
        case enLogiButManMflOk:
        {
            APP_MDI_bUnmutePlayer(APP_MDI_MUTE_DEVICE_SEARCH, UNMUTE_IMMEDIATELY);
//              if((gAppSdContext.lastConnectionDevice.playerState == APP_SD_MDI_PLAY)&& \
//                 (APP_MDI_GetPlayStatus() != APP_MDI_ACT_STATE_PLAY))
//              {
//                  APP_MDI_sfSetPlayMode(APP_MDI_RESUME);
//              }
//              gAppSdContext.lastConnectionDevice.playerState = APP_SD_MDI_STOP;

            // cancel inquiry and go back to history
            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
            pCtxCtrl->s581.subStateBtn   = APP_SD_S581_CANCEL_INQUIRY_NOT_SENT;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS582(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS599(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}



//******************************************
//
//******************************************
BooleanType _APP_SD_bHandleButtonS601(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            switch(selIdx)
            {
                case 1:
                    // context for telefonbuch settings
                    _APP_SD_vInitFrameS661();
                    break;
                case 2:
#ifdef UHV_ACTIVATE_FEATURE_S641
                    /* Signaleinstellungen */
                    _APP_SD_vInitFrameS641();
#else
                    /* Rufton */
                    _APP_SD_vInitFrameS642(ERM_u16GetNumberOfRingtones());
#endif
                    break;
#ifndef UHV_ACTIVATE_FEATURE_SET_AUDIO_MODE
                case 3:
                    if(pCtxCtrl->s601.bVersion)
                    {
                        /* Version */
                        _APP_SD_vInitFrameSB34();
                    }
                    else
                    {
                        _APP_SD_vCtxHistoryStepBack();
                    }
                    break;
                case 4:
                    _APP_SD_vCtxHistoryStepBack();
                    break;
#else
                case 3:
                    /* Audio Mode */
                    _APP_SD_vInitFrameS602();
                    break;
                case 4:
                    if(pCtxCtrl->s601.bVersion)
                    {
                        /* Version */
                        _APP_SD_vInitFrameSB34();
                    }
                    else
                    {
                        _APP_SD_vCtxHistoryStepBack();
                    }
                    break;
                case 5:
                    _APP_SD_vCtxHistoryStepBack();
                    break;
#endif
                default:

                    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton601: enOK not handled for pos %d",
                                  selIdx);
                    break;
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS602(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            switch(selIdx)
            {
                case 1:
                case 2:
                {
                    pCtxCtrl->s602.audioMode = (selIdx == 1) ?
                                    ERM_AUDIO_MODE_CALLS_ONLY : ERM_AUDIO_MODE_ALL_AUDIO;
                    // set audio mode
                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->s602.subStateBtn   = APP_SD_S602_SET_AUDIO_MODE_NOT_SENT;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(0),
                                                        0);
                    break;
                }
                case 3:
                    _APP_SD_vCtxHistoryStepBack();
                    break;

                default:

                    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton602: enOK not handled for pos %d",
                                  selIdx);
                    break;
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}



BooleanType _APP_SD_bHandleButtonS641(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            if(ERM_SIVR_FULL_SUPPORTED == ERM_enIsVcrSupported())             /* RT 2429 */
            {
                switch(selIdx)
                {
                    case 1:
                    {   /* Rufton */
                        _APP_SD_vInitFrameS642(ERM_u16GetNumberOfRingtones());
                        break;
                    }
                    case 2:
#ifdef UHV_ACTIVATE_FEATURE_PLAY_CALLER_NAME
                    {   /* Anrufername */
                        _APP_SD_vInitFrameSC16();
                        break;
                    }
                    case 3:
#endif
                        _APP_SD_vCtxHistoryStepBack();
                        break;

                    default:

                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton641: enOK not handled for pos %d",
                                      selIdx);
                        break;
                  }
              }
              else
              {
                switch(selIdx)
                {
                    case 1:
                    {   /* Rufton */
                        _APP_SD_vInitFrameS642(ERM_u16GetNumberOfRingtones());
                        break;
                    }
                    case 2:
                        _APP_SD_vCtxHistoryStepBack();
                        break;

                    default:

                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton641: enOK not handled for pos %d",
                                      selIdx);
                        break;
                  }
              }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS642(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
        {
            AppSdFrameDataListCommon *pListCtrl = &(pCtxCtrl->common.listData);
            Uint16Type preSelIdx = APP_SD_LC_u16GetSelectedIndex(pListCtrl);
            Uint16Type postSelIdx = 0;
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);
            postSelIdx = APP_SD_LC_u16GetSelectedIndex(pListCtrl);

            if (preSelIdx != postSelIdx)
            {
                if (postSelIdx == pCtxCtrl->common.listData.numListElems)
                {
                    (void)APP_DEVICE_rcStopRingtoneNonBlock();
                    gAppSdContext.blastRingtoneindication = BT_TRUE;//RT14853
                }
                _APP_SD_vRefreshFrame(pCtxCtrl);
            }
            break;
        }
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            /* get ringtone for selected index */
            DEBUG_TEXT( APP_SD_SWI_DBG, MOD_APP_SD, "Ring tone play from SD");
            if(ERM_eGetUmpteenthRingtone(selIdx) != AT_RTMODE_INVALID)
            {
                pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                gAppSdContext.setRingtoneCounter = 0;
                pCtxCtrl->s642.ringtone = ERM_eGetUmpteenthRingtone(selIdx);
                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                      MSEC(0),
                                                      0);
                gAppSdContext.blastRingtoneindication = BT_FALSE;//RT14853
            }
            else
            {
                /* we do not need to safe the selected ringtone, just stop the current ringtone
                   and step back in history */
                /* release mute and stop play ringtone */
                (void)APP_DEVICE_rcStopRingtoneNonBlock();
                _APP_SD_vCtxHistoryStepBack();
            }
            break;
        }
        case enLogiButManMflBack:
            /* release mute and stop play ringtone */
        	gAppSdContext.blastRingtoneindication = BT_FALSE;//RT14853
            (void)APP_DEVICE_rcStopRingtoneNonBlock();
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}


BooleanType _APP_SD_bHandleButtonS661(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            switch(selIdx)
            {
                case 1:
                {
                    // Handle Pending button, cause we need to trigger pb
                    // syncro in ck5050 module
                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->s661.subStateBtn   = APP_SD_S661_START_SYNCHRO_NOT_SENT;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                    MSEC(0),
                                                    0);
                    // next frame S663 will be inited in ButtonPendingS661_Cb
                    break;
                }
                case 2:
                {
                    // Sortierung
                    _APP_SD_vInitFrameS669();
                    break;
                }
                case 3:
                    _APP_SD_vCtxHistoryStepBack();
                    break;

                default:

                    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton661: enOK not handled for pos %d",
                                  selIdx);
                    break;
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}


BooleanType _APP_SD_bHandleButtonS663(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
        {
            // SUSANNE: 02.10.2009 Do not step back in history, show pb download frame !!
            // #3059
            _APP_SD_vInitFrameS102();
            //_APP_SD_vCtxHistoryStepBack();

            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS664(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}




BooleanType _APP_SD_bHandleButtonS669(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            switch(selIdx)
            {
                case 1:
                case 2:
                {
                    // SUSANNE: 14.11.2009
                    // selIdx = 1 -> Nachname
                    // selIdx = 2 -> Vorname
                    // when vorname was selected ( 2 ) the old comparison would never match, cause of different
                    // value AT_PB_SORTORDER_FIRSTLAST == 0
                    // first check if the selection changed:
                    Uint16Type newSortOrder = (1 == selIdx) ? AT_PB_SORTORDER_LASTFIRST : AT_PB_SORTORDER_FIRSTLAST;

                    if( newSortOrder == pCtxCtrl->s669.sortOrder)
                    {
                        _APP_SD_vCtxHistoryStepBack();
                        return BT_TRUE;
                    }
                    // else: new sorting
                    pCtxCtrl->s669.sortOrder = newSortOrder;

                    // set name order with last name first
                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->s669.subStateBtn   = APP_SD_S669_SORTORDER_SELECT_NOT_SENT;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(0),
                                                        0);
                    break;
                }
                case 3:
                    _APP_SD_vCtxHistoryStepBack();
                    break;

                default:

                    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton669: enOK not handled for pos %d",
                                  selIdx);
                    break;
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}


BooleanType _APP_SD_bHandleButtonS801(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            if( NULL != ERM_pGetActiveHeadsetProfile())
            {
                switch(selIdx)
                {
                    case 1:
                        /* HangUp */
                        if (BT_TRUE == gAppSdContext.callStateIsActive)
                        {
                            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                            pCtxCtrl->s801.subStateBtn   = APP_SD_S801_HANGUP_NOT_SENT;

                            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                MSEC(0), 0);
                        }
                        else
                        {
                            _APP_SD_vInitFrameS408_PRECALL();
                        }
                        break;
                    case 2:
                        /* Headset / Freisprechen */
                        pCtxCtrl->common.pendingType    = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s801.subStateBtn      = APP_SD_S801_HEADSET_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                  MSEC(0), 0);
                        break;
                    case 3:
                        /* Privatgespräch */
                        // SUSANNE 01.09.2009 RT #2580: This is possible only, if PATR:1 has been received already.
                        // Also, SC20 needs the PLCC index to be able to show the name/number of the called party.
                        // So we need to wait here for a plcc representing the outgoing call, before Private mode is evaluated.
                        if( BT_FALSE == APP_PHONE_bIsHandsFreeOff() )       // PATR:1 is needed
                        {
                            ATCallIndexEnum idx = APP_PHONE_AT_PNCC_GetOutgoingCallIndex();
                            if(AT_CALL_INDEX_NONE != idx )
                            {
                                // found one. save it and trigger private mode
                                pCtxCtrl->common.pendingType    = APP_SD_PENDING_BUTTON;
                                pCtxCtrl->s801.plccIndex        = idx;
                                pCtxCtrl->s801.subStateBtn      = APP_SD_S801_PRIVATE_MODE_NOT_SENT;

                                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                             MSEC(0), 0);
                            }
                            else
                            {

                                DEBUG_TEXT( APP_SD_SWI_DBG, MOD_APP_SD, "HdlBtnS801: Ign. PrivMode Req. No outg. call");
                            }
                        }
                        else
                        {

                            DEBUG_TEXT( APP_SD_SWI_DBG, MOD_APP_SD, "HdlBtnS801: Ign. PrivMode Req. Hfp Mode curr. off");
                        }
                        break;
                    default:
                        break;
                }
            }
            else
            {
                switch(selIdx)
                {
                    case 1:
                        /* HangUp */
                        if (BT_TRUE == gAppSdContext.callStateIsActive)
                        {
                            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                            pCtxCtrl->s801.subStateBtn   = APP_SD_S801_HANGUP_NOT_SENT;

                            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                MSEC(0), 0);
                        }
                        else
                        {
                            _APP_SD_vInitFrameS408_PRECALL();
                        }
                        break;
                    case 2:
                        /* Privatgespräch */
                        // SUSANNE 01.09.2009 RT #2580: This is possible only, if PATR:1 has been received already.
                        // Also, SC20 needs the PLCC index to be able to show the name/number of the called party.
                        // So we need to wait here for a plcc representing the outgoing call, before Private mode is evaluated.
                        if( BT_FALSE == APP_PHONE_bIsHandsFreeOff() )       // PATR:1 is needed
                        {
                            ATCallIndexEnum idx = APP_PHONE_AT_PNCC_GetOutgoingCallIndex();
                            if(AT_CALL_INDEX_NONE != idx )
                            {
                                const ATRspCallStatValType * pCall = APP_PHONE_AT_PNCC_pGetPlccContext(idx);
                                if(NULL != pCall)
                                {
                                      // found one. save it and trigger private mode
                                      pCtxCtrl->common.pendingType    = APP_SD_PENDING_BUTTON;
                                      pCtxCtrl->s801.plccIndex        = idx;
                                      pCtxCtrl->s801.subStateBtn      = APP_SD_S801_PRIVATE_MODE_NOT_SENT;

                                      (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                                MSEC(0), 0);
                                }
                            }
                            else
                            {

                                DEBUG_TEXT( APP_SD_SWI_DBG, MOD_APP_SD, "HdlBtnS801: Ign. PrivMode Req. No outg. call");
                            }
                        }
                        else
                        {

                            DEBUG_TEXT( APP_SD_SWI_DBG, MOD_APP_SD, "HdlBtnS801: Ign. PrivMode Req. Hfp Mode curr. off ");
                        }
                        break;
                    default:
                        break;
                }
            }
            break;
        }
        case enLogiButManMflHook:
        {
            if(pButton->pressType == enLogiButManLongPress)
            {
                /* Privatgespräch */
                pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                pCtxCtrl->s801.subStateBtn   = APP_SD_S801_PRIVATE_MODE_NOT_SENT;

                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                    MSEC(0),
                                                    0);
            }
            else
            {
                /* HangUp */
                if (BT_TRUE == gAppSdContext.callStateIsActive)
                {
                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->s801.subStateBtn   = APP_SD_S801_HANGUP_NOT_SENT;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                    MSEC(0),
                                                    0);
                }
                else
                {
                    _APP_SD_vInitFrameS408_PRECALL();
                }
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS802(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
        {
            //  check that we didn't miss a call indication during connect
            if( (BT_FALSE == APP_PHONE_AT_PNCC_bAllCallStatesIdle()) && (BT_TRUE == _APP_SD_bIsKl15On()))
            {
                _APP_SD_vHandleCallStateChanged();
            }
            else
            {
                _APP_SD_vCtxHistoryStepBack();
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}


BooleanType _APP_SD_bHandleButtonS803(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));

            if( BT_TRUE == pCtxCtrl->s803.bholdSupported )
            {
              if( NULL != ERM_pGetActiveHeadsetProfile())
              {
                switch(selIdx)
                {
                    case 1:
                        /* HangUp */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s803.subStateBtn   = APP_SD_S803_HANGUP_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 2:
                        /* Hold Call */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s803.subStateBtn   = APP_SD_S803_HOLD_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 3:
                        /* Headset */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s803.subStateBtn   = APP_SD_S803_HEADSET_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 4:
                        /* HandsFree ON/OFF */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s803.subStateBtn   = APP_SD_S803_HANDSFREE_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 5:
                        /* MicroMute */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s803.subStateBtn   = APP_SD_S803_MICROMUTE_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 6:
                        /* DTMF */
                        _APP_SD_vInitFrameS804();
                        break;
                    default:

                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton803: enLogiButManMflOk ignored for pos %d",
                                      selIdx);
                        break;
                }
              }
              else
              {
                switch(selIdx)
                {
                    case 1:
                        /* HangUp */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s803.subStateBtn   = APP_SD_S803_HANGUP_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 2:
                        /* Hold Call */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s803.subStateBtn   = APP_SD_S803_HOLD_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 3:
                        /* HandsFree ON/OFF */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s803.subStateBtn   = APP_SD_S803_HANDSFREE_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 4:
                        /* MicroMute */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s803.subStateBtn   = APP_SD_S803_MICROMUTE_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 5:
                        /* DTMF */
                        _APP_SD_vInitFrameS804();
                        break;
                    default:

                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton803: enLogiButManMflOk ignored for pos %d",
                                      selIdx);
                        break;
                }
              }
            }
            else
            {
              if( NULL != ERM_pGetActiveHeadsetProfile())
              {
                switch(selIdx)
                {
                    case 1:
                        /* HangUp */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s803.subStateBtn   = APP_SD_S803_HANGUP_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 2:
                        /* Headset */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s803.subStateBtn   = APP_SD_S803_HEADSET_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 3:
                        /* HandsFree ON/OFF */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s803.subStateBtn   = APP_SD_S803_HANDSFREE_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 4:
                        /* MicroMute */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s803.subStateBtn   = APP_SD_S803_MICROMUTE_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 5:
                        /* DTMF */
                        _APP_SD_vInitFrameS804();
                        break;
                    default:

                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton803: enLogiButManMflOk ignored for pos %d",
                                      selIdx);
                        break;
                }
              }
              else
              {
                switch(selIdx)
                {
                    case 1:
                        /* HangUp */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s803.subStateBtn   = APP_SD_S803_HANGUP_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 2:
                        /* HandsFree ON/OFF */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s803.subStateBtn   = APP_SD_S803_HANDSFREE_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 3:
                        /* MicroMute */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s803.subStateBtn   = APP_SD_S803_MICROMUTE_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 4:
                        /* DTMF */
                        _APP_SD_vInitFrameS804();
                        break;
                    default:

                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton803: enLogiButManMflOk ignored for pos %d",
                                      selIdx);
                        break;
                }
              }
            }
            break;
        }
        case enLogiButManMflHook:
        {
          if(pButton->pressType == enLogiButManLongPress)
          {
            /* HandsFree ON/OFF */
            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
            pCtxCtrl->s803.subStateBtn   = APP_SD_S803_HANDSFREE_NOT_SENT;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
          }
          else
          {
            /* HangUp */
            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
            pCtxCtrl->s803.subStateBtn   = APP_SD_S803_HANGUP_NOT_SENT;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
          }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS804(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_SC_vButtonUpDown(&(pCtxCtrl->s804.spellerCtrl), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            switch( APP_SD_SC_vButtonOk(&(pCtxCtrl->s804.spellerCtrl)) )
            {
                case APP_SD_SC_CONTROL_BACK:
                    _APP_SD_vCtxHistoryStepBack();
                    break;
                default:
                    /* Send DTMF */
                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->s804.subStateBtn   = APP_SD_S804_DTMF_NOT_SENT;
                    pCtxCtrl->common.timeout     = APP_SD_MS_TIMEOUT_20000; //RT13344
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FRAME_TIMEOUT,
                                                               MSEC(pCtxCtrl->common.timeout),
                                                               0);
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(0),
                                                        0);
                    break;
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS806(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}



BooleanType _APP_SD_bHandleButtonS807(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}


BooleanType _APP_SD_bHandleButtonS811(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            if (AT_CALL_INDEX_CONFERENCE == pCtxCtrl->s811.plccIndex)
            {
                switch(selIdx)
                {
                    case 1:
                        /* Resume held call */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s811.subStateBtn   = APP_SD_S811_RESUME_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 2:
                        /* HangUp */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s811.subStateBtn   = APP_SD_S811_HANGUP_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    default:

                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton811: enLogiButManMflOk ignored for pos %d",
                                      selIdx);
                        break;
                }
            }
            else
            {
                switch(selIdx)
                {
                    case 1:
                        /* Resume held call */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s811.subStateBtn   = APP_SD_S811_RESUME_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 2:
                    {
                        /* PHONEBOOK */
                        Uint16Type pbSize = APP_PHONEBOOK_u16GetCurrentPBSize(APP_PHONEBOOK_enUsersPB);
                        if(pbSize > 0)
                        {
                            _APP_SD_vInitFrameS104(pbSize);
                        }
                        else
                        {
                            /* no entries available */
                            _APP_SD_vInitFrameS103();
                        }
                        break;
                    }
                    case 3:
                        /* CallLists */
                        _APP_SD_vInitFrameS201();
                        break;
                    case 4:
                        /* Digit Call */
                        _APP_SD_vInitFrameS301();
                        break;
                    case 5:
                        /* HangUp */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s811.subStateBtn   = APP_SD_S811_HANGUP_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    default:

                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton811: enLogiButManMflOk ignored for pos %d",
                                      selIdx);
                        break;
                }
            }
            break;
        }
        case enLogiButManMflHook:
        {
            /* AcceptCall */
            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
            pCtxCtrl->s811.subStateBtn   = APP_SD_S811_HANGUP_NOT_SENT;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS812(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));

            if( (APP_PHONE_enGetHfpVersion() == AT_CODPROF_HANDSFREE_1_00) ||
                (APP_PHONE_enGetHfpVersion() == AT_CODPROF_HANDSFREE_0_96)  ||
                (BT_TRUE == ERM_bIsCDMAPhone()) )
            {
                if( NULL != ERM_pGetActiveHeadsetProfile())
                {
                    switch(selIdx)
                    {
                        case 1:
                            /* HangUp */
                            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                            pCtxCtrl->s812.subStateBtn   = APP_SD_S812_HANGUP_NOT_SENT;

                            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                MSEC(0),
                                                                0);
                            break;
                        case 2:
                                /* Headset */
                                pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                                pCtxCtrl->s812.subStateBtn   = APP_SD_S812_HEADSET_NOT_SENT;

                                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                    MSEC(0),
                                                                    0);
                            break;
                        case 3:
                            /* MicroMute On/Off */
                            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                            pCtxCtrl->s812.subStateBtn   = APP_SD_S812_MICROMUTE_NOT_SENT;

                            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                MSEC(0),
                                                                0);
                            break;
                        case 4:
                            /* Send DTMF */
                            _APP_SD_vInitFrameS804();
                            break;
                        case 5:
                            /* Hangup All */
                            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                            pCtxCtrl->s812.subStateBtn   = APP_SD_S812_HANGUP_BOTH_NOT_SENT;

                            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                MSEC(0),
                                                                0);
                            break;
                        default:

                            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton812: enLogiButManMflOk ignored for pos %d",
                                          selIdx);
                            break;
                    }
                }
                else
                {
                    switch(selIdx)
                        {
                            case 1:
                                /* HangUp */
                                pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                                pCtxCtrl->s812.subStateBtn   = APP_SD_S812_HANGUP_NOT_SENT;

                                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                    MSEC(0),
                                                                    0);
                                break;
                            case 2:
                                /* MicroMute On/Off */
                                pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                                pCtxCtrl->s812.subStateBtn   = APP_SD_S812_MICROMUTE_NOT_SENT;

                                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                    MSEC(0),
                                                                    0);
                                break;
                            case 3:
                                /* Send DTMF */
                                _APP_SD_vInitFrameS804();
                                break;
                            case 4:
                                /* Hangup All */
                                pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                                pCtxCtrl->s812.subStateBtn   = APP_SD_S812_HANGUP_BOTH_NOT_SENT;

                                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                    MSEC(0),
                                                                    0);
                                break;
                            default:
                                DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton812: enLogiButManMflOk ignored for pos %d",
                                              selIdx);
                                break;
                        }
                }
            }
            else
            {
                if( NULL != ERM_pGetActiveHeadsetProfile())
                {
                    switch(selIdx)
                    {
                        case 1:
                            /* HangUp */
                            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                            pCtxCtrl->s812.subStateBtn   = APP_SD_S812_HANGUP_NOT_SENT;

                            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                MSEC(0),
                                                                0);
                        break;
                        case 2:
                            /* SwitchCalls */
                            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                            pCtxCtrl->s812.subStateBtn   = APP_SD_S812_SWITCH_NOT_SENT;

                            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                MSEC(0),
                                                                0);
                            break;
                        case 3:
                            /* Conference */
                            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                            pCtxCtrl->s812.subStateBtn   = APP_SD_S812_CONFERENCE_NOT_SENT;

                            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                MSEC(0),
                                                                0);
                            break;
                    case 4:
                            /* Headset */
                            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                            pCtxCtrl->s812.subStateBtn   = APP_SD_S812_HEADSET_NOT_SENT;

                            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                MSEC(0),
                                                                0);
                        break;
                    case 5:
                        /* MicroMute On/Off */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s812.subStateBtn   = APP_SD_S812_MICROMUTE_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 6:
                        /* Send DTMF */
                        _APP_SD_vInitFrameS804();
                        break;
                    case 7:
                        /* Hangup All */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s812.subStateBtn   = APP_SD_S812_HANGUP_BOTH_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    default:

                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton812: enLogiButManMflOk ignored for pos %d",
                                      selIdx);
                        break;
                }
            }
            else
            {
                switch(selIdx)
                {
                    case 1:
                        /* HangUp */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s812.subStateBtn   = APP_SD_S812_HANGUP_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 2:
                        /* SwitchCalls */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s812.subStateBtn   = APP_SD_S812_SWITCH_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 3:
                        /* Conference */
                            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                            pCtxCtrl->s812.subStateBtn   = APP_SD_S812_CONFERENCE_NOT_SENT;

                            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                MSEC(0),
                                                                0);
                        break;
                    case 4:
                        /* MicroMute On/Off */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s812.subStateBtn   = APP_SD_S812_MICROMUTE_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 5:
                        /* Send DTMF */
                        _APP_SD_vInitFrameS804();
                        break;
                    case 6:
                        /* Hangup All */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s812.subStateBtn   = APP_SD_S812_HANGUP_BOTH_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    default:

                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton812: enLogiButManMflOk ignored for pos %d",
                                      selIdx);
                        break;
                }
            }
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS814(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}



BooleanType _APP_SD_bHandleButtonS815(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));

            if( (APP_PHONE_enGetHfpVersion() == AT_CODPROF_HANDSFREE_1_00) ||
                (APP_PHONE_enGetHfpVersion() == AT_CODPROF_HANDSFREE_0_96)  ||
                (BT_TRUE == ERM_bIsCDMAPhone()) )
            {
            if( NULL != ERM_pGetActiveHeadsetProfile())
            {
                switch(selIdx)
                {
                    case 1:
                        /* HangUp Conference */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s815.subStateBtn   = APP_SD_S815_HANGUP_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 2:
                            /* Headset */
                            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                            pCtxCtrl->s815.subStateBtn   = APP_SD_S815_HEADSET_NOT_SENT;

                            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                MSEC(0),
                                                                0);
                            break;
                        case 3:
                            /* MicroMute On/Off */
                            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                            pCtxCtrl->s815.subStateBtn   = APP_SD_S815_MICROMUTE_NOT_SENT;

                            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                MSEC(0),
                                                                0);
                            break;
                        default:

                            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton815: enLogiButManMflOk ignored for pos %d",
                                          selIdx);
                            break;
                    }
                    break;
                }
                else
                {
                    switch(selIdx)
                    {
                        case 1:
                            /* HangUp Conference */
                            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                            pCtxCtrl->s815.subStateBtn   = APP_SD_S815_HANGUP_NOT_SENT;

                            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                MSEC(0),
                                                                0);
                            break;
                        case 2:
                            /* MicroMute On/Off */
                            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                            pCtxCtrl->s815.subStateBtn   = APP_SD_S815_MICROMUTE_NOT_SENT;

                            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                MSEC(0),
                                                                0);
                            break;
                        default:

                            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton815: enLogiButManMflOk ignored for pos %d",
                                          selIdx);
                            break;
                    }
                    break;
                }
            }
            else
            {
                if( NULL != ERM_pGetActiveHeadsetProfile())
                {
                    switch(selIdx)
                    {
                        case 1:
                            /* HangUp Conference */
                            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                            pCtxCtrl->s815.subStateBtn   = APP_SD_S815_HANGUP_NOT_SENT;

                            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                MSEC(0),
                                                                0);
                            break;
                        case 2:
                        /* Hold conference */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s815.subStateBtn   = APP_SD_S815_HOLD_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 3:
                        /* Headset */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s815.subStateBtn   = APP_SD_S815_HEADSET_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 4:
                        /* MicroMute On/Off */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s815.subStateBtn   = APP_SD_S815_MICROMUTE_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    default:

                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton815: enLogiButManMflOk ignored for pos %d",
                                      selIdx);
                        break;
                }
                break;
            }
            else
            {
                switch(selIdx)
                {
                    case 1:
                        /* HangUp Conference */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s815.subStateBtn   = APP_SD_S815_HANGUP_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 2:
                        /* Hold conference */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s815.subStateBtn   = APP_SD_S815_HOLD_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case 3:
                        /* MicroMute On/Off */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s815.subStateBtn   = APP_SD_S815_MICROMUTE_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    default:

                        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton815: enLogiButManMflOk ignored for pos %d",
                                      selIdx);
                        break;
                }
                break;
            }
        }
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS901(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            if(pCtxCtrl->s901.muteActivated == BT_FALSE)
            {
                if( NULL != ERM_pGetActiveHeadsetProfile())
                {
                  switch(selIdx)
                  {
                      case 1:
                          /* AcceptCall */
                          pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                          pCtxCtrl->s901.subStateBtn   = APP_SD_S901_ACCEPT_NOT_SENT;

                          (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                              MSEC(0),
                                                              0);
                          break;
                      case 2:
                          /* HangupCall */
                          pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                          pCtxCtrl->s901.subStateBtn   = APP_SD_S901_HANGUP_NOT_SENT;

                          (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                              MSEC(0),
                                                              0);
                          break;
                      case 3:       // RT #3129, #3200
                          /* mute */
                          pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                          pCtxCtrl->s901.subStateBtn   = APP_SD_S901_MUTE_NOT_SENT;

                          (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                              MSEC(0),
                                                              0);
                          break;
                      case 4:
                            /* Headset */
                            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                            pCtxCtrl->s901.subStateBtn   = APP_SD_S901_HEADSET_NOT_SENT;

                            gAppSdContext.bHeadSetActivated = BT_TRUE;
                            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                MSEC(0),
                                                                0);
                            break;
                      default:
                          break;
                  }
                }
                else
                {
                  switch(selIdx)
                  {
                      case 1:
                          /* AcceptCall */
                          pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                          pCtxCtrl->s901.subStateBtn   = APP_SD_S901_ACCEPT_NOT_SENT;

                          (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                              MSEC(0),
                                                              0);
                          break;
                      case 2:
                          /* HangupCall */
                          pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                          pCtxCtrl->s901.subStateBtn   = APP_SD_S901_HANGUP_NOT_SENT;

                          (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                              MSEC(0),
                                                              0);
                          break;
                      case 3:       // RT #3129, #3200
                          /* mute */
                          pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                          pCtxCtrl->s901.subStateBtn   = APP_SD_S901_MUTE_NOT_SENT;

                          (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                              MSEC(0),
                                                              0);
                          break;
                      default:
                          break;
                  }
                }
            }
            else
            {
                if( NULL != ERM_pGetActiveHeadsetProfile())
                {
                  switch(selIdx)
                  {
                      case 1:
                          /* AcceptCall */
                          pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                          pCtxCtrl->s901.subStateBtn   = APP_SD_S901_ACCEPT_NOT_SENT;

                          (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                              MSEC(0),
                                                              0);
                          break;
                      case 2:
                          /* HangupCall */
                          pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                          pCtxCtrl->s901.subStateBtn   = APP_SD_S901_HANGUP_NOT_SENT;

                          (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                              MSEC(0),
                                                              0);
                          break;
                      case 3:
                            /* Headset */
                            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                            pCtxCtrl->s901.subStateBtn   = APP_SD_S901_HEADSET_NOT_SENT;

                            gAppSdContext.bHeadSetActivated = BT_TRUE;
                            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                MSEC(0),
                                                                0);
                            break;
                      default:
                          break;
                  }
                }
                else
                {
                  switch(selIdx)
                  {
                      case 1:
                          /* AcceptCall */
                          pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                          pCtxCtrl->s901.subStateBtn   = APP_SD_S901_ACCEPT_NOT_SENT;

                          (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                              MSEC(0),
                                                              0);
                          break;
                      case 2:
                          /* HangupCall */
                          pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                          pCtxCtrl->s901.subStateBtn   = APP_SD_S901_HANGUP_NOT_SENT;

                          (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                              MSEC(0),
                                                              0);
                          break;
                      default:
                          break;
                  }
                }
            }
            break;
        }
        case enLogiButManMflHook:
        {
            /* AcceptCall */
            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
            pCtxCtrl->s901.subStateBtn   = APP_SD_S901_ACCEPT_NOT_SENT;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS902(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            if( (APP_PHONE_enGetHfpVersion() == AT_CODPROF_HANDSFREE_1_00) ||
                (APP_PHONE_enGetHfpVersion() == AT_CODPROF_HANDSFREE_0_96)  ||
                (BT_TRUE == ERM_bIsCDMAPhone()) )
            {
            switch(selIdx)
            {
                case 1:
                    {
                        /* Reject waiting call */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s902.subStateBtn   = APP_SD_S902_HANGUP_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    }
                case 2:
                    {
                        /* Release active call accept waiting call */
                        pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        pCtxCtrl->s902.subStateBtn   = APP_SD_S902_RELEASE_ACCEPT_NOT_SENT;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    }
                    default:
                        break;
                }
            }
            else
            {
                switch(selIdx)
                {
                    case 1:
                    /* Accept call */
                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->s902.subStateBtn   = APP_SD_S902_ACCEPT_NOT_SENT;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(0),
                                                        0);
                    break;
                case 2:
                    /* Reject waiting call */
                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->s902.subStateBtn   = APP_SD_S902_HANGUP_NOT_SENT;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(0),
                                                        0);
                    break;
                case 3:
                    /* Release active call accept waiting call */
                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->s902.subStateBtn   = APP_SD_S902_RELEASE_ACCEPT_NOT_SENT;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(0),
                                                        0);
                    break;
               default:
                    break;
            }
            }
            break;
        }
        case enLogiButManMflHook:
        {
            /* AcceptCall */
            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
            pCtxCtrl->s901.subStateBtn   = APP_SD_S901_ACCEPT_NOT_SENT;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS903(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            if(ERM_SIVR_FULL_SUPPORTED == ERM_enIsVcrSupported())                /* RT 2429 */
            {
                switch(selIdx)
                {
                    case 1:
                        /* show sms text of index 1 ( always the newest )*/
                        _APP_SD_vInitFrameS406(1);
                        break;
                    case 2:
                        /* Read all new sms */
                        if(SUCCESS != VCR_sFHapticTrigger(VCR_HAPTIC_READ_NEW_SMS,1/* index is not used here */))
                        {
                            _APP_SD_vInitFrameS928();
                        }
                        break;
                    case 3:
                        /* Beenden */

                        if(BT_FALSE == _APP_SD_bPhoneContextActive())
                        {
                            DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "HandleButtonS903: release phone context");
                            _APP_SD_vReleasePhoneContext();
                        }
                        else
                        {
                            DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "HandleButtonS903: historyStepBack");
                            /* go back to context before voice reco was activated */
                            _APP_SD_vCtxHistoryStepBack();
                        }
                        break;
                    default:
                        break;
                }
            }
            else
            {
                switch(selIdx)
                {
                    case 1:
                        /* show sms text of index 1 ( always the newest )*/
                        _APP_SD_vInitFrameS406(1);
                        break;
                    case 2:
                        /* Beenden */

                        if(BT_FALSE == _APP_SD_bPhoneContextActive())
                        {
                            DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "HandleButtonS903: release phone context");
                            _APP_SD_vReleasePhoneContext();
                        }
                        else
                        {
                            DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "HandleButtonS903: historyStepBack");
                            /* go back to context before voice reco was activated */
                            _APP_SD_vCtxHistoryStepBack();
                        }
                        break;
                    default:
                        break;
                }
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS904(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            switch(selIdx)
            {
                case 1:
                {
                    /* go to missed calls S211*/
                    Uint16Type pbSize = APP_PHONEBOOK_u16GetCurrentPBSize(APP_PHONEBOOK_enMissedCalls);
                    _APP_SD_vInitFrameS211(APP_PHONEBOOK_enMissedCalls, pbSize);
                    break;
                }
                case 2:
                    /* Beenden */
                    // go back to MMI screen (release context for phone)
                    if(BT_FALSE == _APP_SD_bPhoneContextActive())
                    {
                        _APP_SD_vReleasePhoneContext();
                    }
                    else
                    {
                        _APP_SD_vCtxHistoryStepBack();
                    }
                    DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HaBtnS904: reset new missed call");
                    // remove showing
                    APP_PHONEBOOK_vResetMissedCallsByHMI();     // RT #5132
                    break;
                default:
                    break;
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}



BooleanType _APP_SD_bHandleButtonS913(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            //RS: replaced because the handling is contained in InitIdleScreen
            //_APP_SD_vInitFrameS002();
            //if((gAppSdContext.lastConnectionDevice.playerState == APP_SD_MDI_PLAY)&& \
           (//APP_MDI_GetPlayStatus() != APP_MDI_ACT_STATE_PLAY))
            //{
            //    APP_MDI_sfSetPlayMode( /*NULL, */APP_MDI_RESUME);
            //}
            //gAppSdContext.lastConnectionDevice.playerState = APP_SD_MDI_STOP;
            _APP_SD_vInitIdleScreen(0);
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS914(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS917(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS923(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS925(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS927(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS928(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS930(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS933(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            switch(selIdx)
            {
                case 1:
                {
                    /* Accept incoming pairing request */
                    if(ERM_pGetPairRequest()->remote_id == ERM_pGetSspRequest()->remote_id)
                    {
                        /* PPRQ and PSPR device id are the same, so we expect a SSP request */
                        _APP_SD_vInitFrameS52C(ERM_pGetSspRequest()->remote_id, ERM_pGetSspRequest()->device_type, APP_DEVICE_enTYPE_UNKNOWN);
                    }
                    else
                    {
                        _APP_SD_vInitFrameS51D_ACCEPT(ERM_pGetPairRequest()->remote_id, ERM_pGetPairRequest()->device_type);
                    }
                    break;
                }
                case 2:
                    /* Reject incoming pairing request */
                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->s933.subStateBtn   = APP_SD_S933_REJECT_NOT_SENT;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(0),
                                                        0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButton933: OK not handled for pos %d",
                                  selIdx);
                    break;
            }
            break;
        }
        case enLogiButManMflBack:
        {
            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
            pCtxCtrl->s933.subStateBtn   = APP_SD_S933_REJECT_NOT_SENT;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS935(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}


BooleanType _APP_SD_bHandleButtonS941(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflHook:
        {
            /* AcceptCall */
            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
            pCtxCtrl->s941.subStateBtn   = APP_SD_S941_ACCEPT_NOT_SENT;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS942(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflHook:
        {
            /* HangUp */
            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
            pCtxCtrl->s942.subStateBtn   = APP_SD_S942_HANGUP_NOT_SENT;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonS945(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflHook:
        {
            /* HangUp */
            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
            pCtxCtrl->s945.subStateBtn   = APP_SD_S945_HANGUP_NOT_SENT;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}




BooleanType _APP_SD_bHandleButtonSC01(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));

            /* make the selIdx 0 based */
            selIdx--;

            if(selIdx < pCtxCtrl->sc01.contactAmb.num_ids)
            {
                _APP_SD_vInitFrameS105(pCtxCtrl->sc01.contactAmb.item_id[selIdx]);
            }
            else
            {   /* Abbruch */
                // go back to MMI screen (release context for phone)
                if(BT_FALSE == _APP_SD_bPhoneContextActive())
                {
                    _APP_SD_vReleasePhoneContext();
                }
                else
                {
                    _APP_SD_vCtxHistoryStepBack();
                }

            }
            break;
        }
        case enLogiButManMflHook:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));

            /* make the selIdx 0 based */
            selIdx--;

            if(selIdx < pCtxCtrl->sc01.contactAmb.num_ids)
            {
                /* call the selected PB index with the PN index 0 (default number) */
                _APP_SD_vInitFrameS801_PB(pCtxCtrl->sc01.contactAmb.item_id[selIdx], 0);
            }
            else
            {

                DEBUG_VALUE2( APP_SD_SWI_TRC, MOD_APP_SD, "HandleButtonSC01: Hook ignored, %d => %d",
                              selIdx,
                              pCtxCtrl->sc01.contactAmb.num_ids);
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonSC03(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            switch(selIdx)
            {
                case 1:
                {
                    /* Aktives Gerät */
                    const ERMPlayerHeadsetProfileType * profile = ERM_pGetActivePlayerProfile();
                    if( NULL != profile && APP_DEVICE_enTYPE_PLAYER == profile->deviceType /* Player connected*/ )
                    {
                        _APP_SD_vInitFrameS563(profile->deviceIndex, APP_DEVICE_enTYPE_PLAYER);
                    }
                    else
                    {
                        _APP_SD_vInitFrameS566();
                    }
                    break;
                }
                case 2:
                {
                    /* Gekoppelte Geräte */
                    Uint16Type numPlayerProfiles = ERM_u16GetNumberOfPlayerProfiles();
                    if( 0 < numPlayerProfiles )
                    {
                        _APP_SD_vInitFrameS5B2((Uint8Type)numPlayerProfiles);
                    }
                    else
                    {
                        _APP_SD_vInitFrameS568();
                    }
                    break;
                }
                case 3:
                    /* Media player suche */
                    gAppSdContext.searchStartedFromScreen = APP_SD_CONTEXT_SC03;
                    if( APP_CAN_Speed_un16CurrentVehicleSpeed() < U16_SPEED_LIMIT_LOW )
                    {
                        if(BT_TRUE == APP_MDI_bMutePlayer(APP_MDI_MUTE_DEVICE_SEARCH))
                        {
                            _APP_SD_vInitFrameS522(APP_SD_MDI_MUTE_FOR_SEARCH, AT_INVALID_DEVICE_ID,
                                                   APP_DEVICE_enTYPE_UNKNOWN, BT_FALSE);
                        }
                        else
                        {
                            _APP_SD_vInitFrameSC13();
                        }
                    }
                    else
                    {
                      _APP_SD_vInitFrameS407();
                    }
                    break;
                case 4:
                {
                    /* zurück */
                    // Ticket #4502 if we step back from SC03 and we came from S502 we need to check if the
                    // phone is still connected. If not, we need to step into S002, else the user will have the complete
                    // BT main menue although no phone is connected
                    Sint16Type s502HistIndex = _APP_SD_s16GetHistoryIndex(APP_SD_CONTEXT_S502);

                    if((s502HistIndex != -1) &&
                        (AT_INVALID_DEVICE_ID == ERM_u8GetActivePhone()))
                    {   /* we came from BT main menue but phone is now disconnected -> S002 */
                        _APP_SD_vInitFrameS002(0);
                    }
                    else
                    {
                        _APP_SD_vCtxHistoryStepBack();
                    }
                    break;
                }
                default:

                    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButtonC03: enOK not handled for pos %d",
                                  selIdx);
                    break;
            }
            break;
        }
        case enLogiButManMflBack:
        {
            /* same as OK and *zurück* */
            // Ticket #4502 if we step back from SC03 and we came from S502 we need to check if the
            // phone is still connected. If not, we need to step into S002, else the user will have the complete
            // BT main menue although no phone is connected
            Sint16Type s502HistIndex = _APP_SD_s16GetHistoryIndex(APP_SD_CONTEXT_S502);

            if((s502HistIndex != -1) &&
                (AT_INVALID_DEVICE_ID == ERM_u8GetActivePhone()))
            {   /* we came from BT main menue but phone is now disconnected -> S002 */
                _APP_SD_vInitFrameS002(0);
            }
            else
            {
                _APP_SD_vCtxHistoryStepBack();
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}


BooleanType _APP_SD_bHandleButtonSC04(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}



BooleanType _APP_SD_bHandleButtonSC07(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}


BooleanType _APP_SD_bHandleButtonSC12(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{


    switch(pButton->id)
    {
        case enLogiButManMflOk:
        {
            gAppSdContext.disconnectPlayerWillFollow = BT_TRUE;
            _APP_SD_vInitFrameS408_PLAYER(gAppSdContext.sc12DeviceId,APP_DEVICE_enTYPE_PLAYER);
            break;
        }

        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonSC13(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflBack:
        case enLogiButManMflOk:
        {
            APP_MDI_bUnmutePlayer(APP_MDI_MUTE_DEVICE_SEARCH, UNMUTE_IMMEDIATELY);
//            if((gAppSdContext.lastConnectionDevice.playerState == APP_SD_MDI_PLAY)&& \
//               (APP_MDI_GetPlayStatus() != APP_MDI_ACT_STATE_PLAY))
//            {
//                APP_MDI_sfSetPlayMode(APP_MDI_RESUME);
//            }
//            gAppSdContext.lastConnectionDevice.playerState = APP_SD_MDI_STOP;
            if( pCtxCtrl->sc13.subState == APP_SD_SC13_START_INQUIRY_SENT )
            {
                // cancel inquiry and go back to history
                pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                pCtxCtrl->sc13.subStateBtn   = APP_SD_SC13_CANCEL_INQUIRY_NOT_SENT;

                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                    MSEC(0),
                                                    0);
            }
            else
            {
                _APP_SD_vCtxHistoryStepBack();
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}






BooleanType _APP_SD_bHandleButtonSC16(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            switch(selIdx)
            {
                case 1:
                case 2:
                {
                    pCtxCtrl->sc16.bPlayCallerName = (selIdx == 1) ?
                                    BT_TRUE : BT_FALSE;
                    // set name order with last name first
                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->sc16.subStateBtn   = APP_SD_SC16_SET_PLAY_CALLER_NAME_SELECT_NOT_SENT;
                    gAppSdContext.setRingtoneCounter = 0;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(0),
                                                        0);
                    break;
                }
                case 3:
                    _APP_SD_vCtxHistoryStepBack();
                    break;

                default:

                    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButtonC16: enOK not handled for pos %d",
                                  selIdx);
                    break;
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}




//BooleanType _APP_SD_bHandleButtonSC17(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
//{
//    switch(pButton->id)
//    {
//        case enLogiButManMflOk:
//            _APP_SD_vInitFrameS007(pCtxCtrl->sc17.deviceId);
//            break;
//        default:
//            return BT_FALSE;
//    }
//    return BT_TRUE;
//}

BooleanType _APP_SD_bHandleButtonSC22(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
        {
            //SUSANNE: 19.10.2009 Due to new popup handling step back and do not show PB
            _APP_SD_vCtxHistoryStepBack();
            //Uint16Type pbSize = APP_PHONEBOOK_u16GetCurrentPBSize(APP_PHONEBOOK_enUsersPB);
            //_APP_SD_vInitFrameS104(pbSize);
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonSC23(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}


BooleanType _APP_SD_bHandleButtonSC24(AppSdCtxCtrlType *pCtxCtrl,const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflUp:
        case enLogiButManMflDown:
            APP_SD_LC_vButtonUpDown(&(pCtxCtrl->common.listData), pButton->id);

            pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
            pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case enLogiButManMflOk:
        {
            Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(&(pCtxCtrl->common.listData));
            switch(selIdx)
            {
                case 1:
                    /* HangUp */
                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->sc24.subStateBtn   = APP_SD_SC24_HANGUP_NOT_SENT;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(0),
                                                        0);
                    break;
                case 2:
                    /* SwitchCalls */
                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->sc24.subStateBtn   = APP_SD_SC24_SWITCH_NOT_SENT;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(0),
                                                        0);
                    break;
                case 3:
                    /* Conference */
                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->sc24.subStateBtn   = APP_SD_SC24_CONFERENCE_NOT_SENT;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(0),
                                                        0);
                    break;
                case 4:
                    /* MicroMute On/Off */
                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->sc24.subStateBtn   = APP_SD_SC24_MICROMUTE_NOT_SENT;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(0),
                                                        0);
                    break;
                case 5:
                    /* Send DTMF */
                    _APP_SD_vInitFrameS804();
                    break;
                default:

                    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "bHandleButtonC24: enLogiButManMflOk ignored for pos %d",
                                  selIdx);
                    break;
            }
            break;
        }
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}

BooleanType _APP_SD_bHandleButtonSB34(AppSdCtxCtrlType *pCtxCtrl, const AppSdBtnEventType *pButton)
{
    switch(pButton->id)
    {
        case enLogiButManMflOk:
            _APP_SD_vCtxHistoryStepBack();
            break;
        default:
            return BT_FALSE;
    }
    return BT_TRUE;
}


//*******************************************************************************
// Init frames
//*******************************************************************************

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_vInitFrame                                            */
/**
  \brief        Handles the initialization steps that are common to all frames

  \brief        Description:\n
                This function is called after a context specific init is done. The
                main responsible is to manage the correct history handling for the
                new frame.

  \param        pCtxCtrl
                Current context control

  \param        action
                Specifies how the new frame should be added to the context history

  \return       void

 */
/*----------------------------------------------------------------------------*/
void _APP_SD_vInitFrame(AppSdCtxCtrlType *pCtxCtrl, APP_SD_enHistoryAction action)
{

    DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "vInitFr: $APP_SD_enContextId$ = %d",pCtxCtrl->common.ctxId);

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        case APP_SD_CONTEXT_S010:
            /* we accept only the transition from S010 -> S001 AND S010 -> S010 */
            if( pCtxCtrl->common.ctxId != APP_SD_CONTEXT_S001 &&
                pCtxCtrl->common.ctxId != APP_SD_CONTEXT_S010 )
            {

                DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "vInitFr: S010 act, dropped ctx %d",
                              gAppSdContext.pCurCtxCtrl->common.ctxId);
                return;
            }
            break;
        default:
            /* no other context that needs a frame leave handling */
            break;
    }


    (void)memset(&gFrameData, 0, sizeof(gFrameData));
    /* set the frameData pointer, that shall exclusivly be used by the new context */
    pCtxCtrl->common.pFrameData = &gFrameData;
    pCtxCtrl->common.pFrameData->common.ctxId = pCtxCtrl->common.ctxId;

    switch(action)
    {
        case APP_SD_HISTORY_RESET:
            _APP_SD_vCtxHistoryReset(pCtxCtrl);
            break;
        case APP_SD_HISTORY_APPEND:
        {
            Sint16Type pos = _APP_SD_s16GetHistoryIndex(pCtxCtrl->common.ctxId);

            if( pos > -1 )
            {

                DEBUG_VALUE4( APP_SD_SWI_TRC, MOD_APP_SD, "vInitFr: loop ctx %d pos %d action %d",
                              pCtxCtrl->common.ctxId,
                              pos,
                              action,
                              0);

                _APP_SD_vCtxHistoryReplaceIndex(pCtxCtrl, (Uint16Type)pos);
            }
            else if( _APP_SD_sfCtxHistoryAppend(pCtxCtrl) != SUCCESS)
            {
                DEBUG_STATE1( APP_SD_SWI_ERR, MOD_APP_SD, "!!!!!!!! vInitFrame: unable to add ctx $APP_SD_enContextId$ = %d -> reset history !!!!!!!!",
                              pCtxCtrl->common.ctxId);
                //RT: 5146
                _APP_SD_vCtxHistoryReset(pCtxCtrl);
            }
            break;
        }
        case APP_SD_HISTORY_REPLACE:
        {
            Sint16Type pos = _APP_SD_s16GetHistoryIndex(pCtxCtrl->common.ctxId);

            if( pos > -1 )
            {

                DEBUG_VALUE4( APP_SD_SWI_TRC, MOD_APP_SD, "vInitFrame: loop ctx %d pos %d action %d",
                              pCtxCtrl->common.ctxId,
                              pos,
                              action,
                              0);
                _APP_SD_vCtxHistoryReplaceIndex(pCtxCtrl, (Uint16Type)pos);
            }
            else
            {
                _APP_SD_vCtxHistoryReplaceCurrent(pCtxCtrl);
            }
            break;
        }
        default:

           DEBUG_STATE2( APP_SD_SWI_ERR, MOD_APP_SD, "vInitFrame: ctx $APP_SD_enContextId$ = %d invalid action $APP_SD_enHistoryAction$ = %d",
                         pCtxCtrl->common.ctxId,
                         action);
           return;
    }

    /* print number of currently used History Slots */
    DEBUG_VALUE2(APP_SD_SWI_TRC, MOD_APP_SD, "******** SD History Slots: ********: used: %d, max: %d",
                 gAppSdContext.curCtxCtrlId+1, APP_SD_MAX_CTX_DEPTH);



    /* set screen always active for prepared Ctx, e.g popups */
    if(pCtxCtrl->common.bActivation == BT_TRUE)
    {

        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "vInitFrame: act ctx %d",
                      pCtxCtrl->common.ctxId);

        _APP_SD_vActivateFrame(BT_TRUE, __LINE__);
    }

    if(pCtxCtrl->common.timeout > 0)
    {
        (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FRAME_TIMEOUT,
                                           MSEC(pCtxCtrl->common.timeout),
                                           0);

        gAppSdContext.ctxTimedOut = APP_SD_CONTEXT_INVALID;
    }
    else
    {
        (void)APP_COMMON_UTILS_stCancelOsekRelAlarm( CTA_APP_SD_FRAME_TIMEOUT );
    }

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                              MSEC(0),
                                              0);
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_vInitFrameS001                                        */
/**
  \brief        This function handle the initialization of frame S001

  \param        connAttempt
                This value specifies the number of connected devices

  \return       void

 */
/*----------------------------------------------------------------------------*/
void _APP_SD_vInitFrameS001(Uint16Type connAttempt)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S001;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_4;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 1;    // menue entries
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    ERM_vSetDisconnectWillFollow(BT_FALSE);
    gAppSdContext.connectCounter = 0;

    if( gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_S001 )
    {
        ctxCtrl.s001.abort = gAppSdContext.pCurCtxCtrl->s001.abort;
    }

    if( ERM_bIsStartupDone() && (ctxCtrl.s001.abort == BT_TRUE) )
    {
        ctxCtrl.common.timeout = APP_SD_MS_TIMEOUT_60000;
        ctxCtrl.s001.abort = BT_FALSE;
        ctxCtrl.s001.subState = APP_SD_S001_CONNECT_NOT_SENT;
        ctxCtrl.common.listData.numListElems    = 1;    // menue entries

        DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "InitFrS001: ERM Starup done");
    }
    else if(ERM_bIsStartupDone() == BT_FALSE)
    {

        DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "InitFrS001: ERM not up, state: SHOW_ONLY");
        ctxCtrl.s001.subState = APP_SD_S001_SHOW_ONLY;
        ctxCtrl.s001.abort = BT_TRUE;
    }
    else
    {   //set this timeout very short, it is necessary to trigger reconnect of next device
        ctxCtrl.common.timeout = APP_SD_MS_TIMEOUT_300;
        ctxCtrl.s001.abort = BT_TRUE;
        ctxCtrl.s001.subState = APP_SD_S001_SHOW_ONLY;

        DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "InitFrS001: S001 timeout started");
    }

    ctxCtrl.s001.connectAttempt = connAttempt;

    if( gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_S001 )
    {
        gAppSdContext.pCurCtxCtrl->s001.abort = ctxCtrl.s001.abort;
    }


    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "InitS001 %d",
                  connAttempt);
    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_RESET);
}

void _APP_SD_vInitFrameS002(Uint8Type focusedElement)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));
    EEPROM_LAYOUT_vGetPlayerEnabled(&ctxCtrl.s002.playerAvail);
    if( SUCCESS != SUCCESS )
    {

        DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "InitFrS002: DIAG_GetPlayEnab failed");

        ctxCtrl.s002.playerAvail = BT_TRUE;
    }


    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "InitFrS002: playerEnabled: %d",
                  ctxCtrl.s002.playerAvail);


    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S002;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = focusedElement;    // first list elem

    if( ctxCtrl.s002.playerAvail == BT_TRUE )
    {
        ctxCtrl.common.listData.numListElems = 3;    // menue entries
    }
    else
    {
        ctxCtrl.common.listData.numListElems = 2;    // menue entries (without player)
    }

    ctxCtrl.common.listData.listOperation = KPB_NO_LIST_OPERATION;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_RESET);

    //make sure that A2DP and AVRCP service visibility of ck5050 is on
    //we switch of this servie visibility if we conenct a phone to avoid connection issues with some old nokia phones
    //e.g N78 / N81 / N6210 / E51
    _APP_SD_setPlayerVisibleIfEncoded(BT_TRUE);
}

//void _APP_SD_vInitFrameS007(AT_DeviceId deviceId)
//{
//    AppSdCtxCtrlType ctxCtrl;
//    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));
//
//    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S007;
//    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
//
//    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
//    /* set frame date information */
//    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_4;
//    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
//    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
//    ctxCtrl.common.listData.numListElems    = 1;    // menue entries
//    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;
//
//    ctxCtrl.s007.deviceId = deviceId;
//
//    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_RESET);
//}

void _APP_SD_vInitFrameS008()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S008;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_5;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 1;    // menue entries
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS010()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S010;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.state        = APP_SD_CTX_FRAME_REQ_DATA;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_RESET);
}


void _APP_SD_vInitFrameS_18()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    if(KPB_enGetKpbVersionNumber() == KPB_VERSION_1_0)
    {
        ctxCtrl.common.ctxId = APP_SD_CONTEXT_S018;
    }
    else
    {
        ctxCtrl.common.ctxId = APP_SD_CONTEXT_SP18;
    }

    ctxCtrl.common.state        = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_RESET);

    //make sure that A2DP and AVRCP service visibility of ck5050 is on
    //we switch of this servie visibility if we conenct a phone to avoid connection issues with some old nokia phones
    //e.g N78 / N81 / N6210 / E51
    _APP_SD_setPlayerVisibleIfEncoded(BT_TRUE);
}

void _APP_SD_vInitFrameSC20(ATCallConfTypeEnum confInProgress, ATCallIndexEnum plccIdx)         // RT #3554
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_SC20;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_4;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 1;
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    ctxCtrl.sc20.plccIndex = plccIdx;
    ctxCtrl.sc20.confState = confInProgress;         // RT #3554

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
}


void _APP_SD_vInitFrameS101()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S101;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_2;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 7;    // menue entries (without messages)
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;
    ctxCtrl.s101.messagesAvail = BT_FALSE;

    if(APP_SMS_enGetSmsSupportState() == APP_SMS_INITIALIZED_AND_SUPPORTED)
    {
        ctxCtrl.s101.messagesAvail = BT_TRUE;
        ctxCtrl.common.listData.numListElems++;
    }

    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )           //RT 2376
    {
        case APP_SD_CONTEXT_S103:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        case APP_SD_CONTEXT_S104:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_RESET);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}

void _APP_SD_vInitFrameS102()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S102;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_4;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 1;    // menue entries
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;


    // #2599: Replace history only, when S663 is active
    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )           //RT 2376
    {
        case APP_SD_CONTEXT_S663:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}

void _APP_SD_vInitFrameS102_last(void)          //RT #908
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S102;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_2000;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_4;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 1;    // menue entries
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    // #2599: Replace history only, when S663 is active
    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )           //RT 2376
    {
        case APP_SD_CONTEXT_S663:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}

void _APP_SD_vInitFrameS103()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S103;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state    = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    ctxCtrl.common.timeout  = APP_SD_MS_TIMEOUT_5000;

    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
    {
        case APP_SD_CONTEXT_S102:
        case APP_SD_CONTEXT_S211:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}


void _APP_SD_vInitFrameS104(Uint16Type pbSize)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S104;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_2;
    ctxCtrl.common.listData.listElemOnTop   = pbSize + 1;
    ctxCtrl.common.listData.focusedListElemOffset = 1;
    ctxCtrl.common.listData.numListElems    = pbSize + 1;    // menue entries
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;
    ctxCtrl.common.listData.scrollType      = APP_SD_LIST_SCROLL_TYPE_ENDLESS;

    ctxCtrl.s104.initiator  = gAppSdContext.pCurCtxCtrl->common.ctxId;
    ctxCtrl.s104.pbSize     = pbSize;

    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
    {
        case APP_SD_CONTEXT_SC22:
        case APP_SD_CONTEXT_S102:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}

void _APP_SD_vInitFrameS105(Uint16Type pbIndex)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S105;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_2;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem


    //TODO: Decrease number of list entries if VCR is deactivated via Diagnose
    ctxCtrl.common.listData.numListElems    = 2;    // 2 static and x dynamic list entries
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    /* there is no VCR menue, if not coded or UltraLow */                 /* RT 2429 */
    if(ERM_SIVR_FULL_SUPPORTED != ERM_enIsVcrSupported())
    {
        ctxCtrl.common.listData.numListElems    = ctxCtrl.common.listData.numListElems - 1;
    }

    ctxCtrl.s105.pbIndex  = pbIndex;

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        /* replace voice recognition active frame */
        case APP_SD_CONTEXT_S924:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}

//void _APP_SD_vInitFrameS111(Uint16Type pbIndex, Uint16Type pnIndex)
//{
//    AppSdCtxCtrlType ctxCtrl;
//    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));
//
//    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S111;
//    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
//
//    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
//    /* set frame date information */
//    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
//    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
//    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
//    ctxCtrl.common.listData.numListElems    = 2;
//    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;
//
//    ctxCtrl.s111.pbIndex  = pbIndex;
//    ctxCtrl.s111.pnIndex  = pnIndex;
//
//    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
//}

void _APP_SD_vInitFrameS114(Uint16Type pbIndex)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S114;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_4000;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_DATA;
    /* set frame date information */

    ctxCtrl.s114.pbIndex  = pbIndex;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
}


void _APP_SD_vInitFrameS115(Uint16Type pbIndex)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S115;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 2;    // unknown number elements
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    ctxCtrl.s115.pbIndex        = pbIndex;
    ctxCtrl.s115.deletePressed  = BT_FALSE;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS116(Uint16Type pbIndex)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S116;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_5000;

    // copy params
    ctxCtrl.s116.pbIndex        = pbIndex;

    ctxCtrl.common.state                = APP_SD_CTX_FRAME_REQ_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId     = KPB_FRAME_ID_1;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}



void _APP_SD_vInitFrameS117(Uint16Type pbIndex)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S117;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 3;    // assume no voice tag available
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    ctxCtrl.s117.pbIndex            = pbIndex;
    ctxCtrl.s117.bVoiceTagAvailable = BT_FALSE;
    ctxCtrl.s117.lastSelMenue       = APP_SD_S117_UNKNOWN;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}



void _APP_SD_vInitFrameS201()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S201;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_2;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    //ctxCtrl.common.listData.numListElems    = 5;
    // deleting call stacks is not possible if managed by the phone itself
    ctxCtrl.common.listData.numListElems    = 4;
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )           // RT #1905
    {
        case APP_SD_CONTEXT_S103:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}

void _APP_SD_vInitFrameS211(APP_PHONEBOOK_enSelectedPbType pbType, Uint16Type pbSize)
{
    AppSdCtxCtrlType ctxCtrl;
//    Uint8Type *pbTypeName = NULL;

    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S211;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_2;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = pbSize + 1; // number of pb entries + back
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    ctxCtrl.s211.pbType = pbType;
    ctxCtrl.s211.pbSize = pbSize;

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        case APP_SD_CONTEXT_S904:
        case APP_SD_CONTEXT_S211:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
    // if pb type is missed calls, reset missed calls
    if(APP_PHONEBOOK_enMissedCalls == pbType)
    {
        // assume showing S211 was successful
        APP_PHONEBOOK_vResetMissedCallsByHMI();
    }
}

void _APP_SD_vInitFrameS212(APP_PHONEBOOK_enSelectedPbType pbType, Uint16Type pbIndex)
{
    AppSdCtxCtrlType ctxCtrl;

    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S212;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 2;
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    ctxCtrl.s212.pbType   = pbType;
    ctxCtrl.s212.pbIndex  = pbIndex;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS213(Uint16Type smsIndex)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S213;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame data information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_4;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 1;    // unknown number elements
    ctxCtrl.common.listData.listOperation   = KPB_MENU_CHANGE;

    ctxCtrl.s213.smsIndex = smsIndex;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS301()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S301;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state    = APP_SD_CTX_FRAME_REQ_DATA;
    ctxCtrl.common.timeout  = APP_SD_MS_TIMEOUT_5000;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}



void _APP_SD_vInitFrameS305()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S305;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;

    APP_SD_SC_vInitSpeller(&ctxCtrl.s305.spellerCtrl, APP_SD_SC_DIGIT_DIALING);

    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
    {
        case APP_SD_CONTEXT_S301:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}

void _APP_SD_vInitFrameS306()
{
    AppSdCtxCtrlType ctxCtrl;
    const ERMUserProfileType * userProfile;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S306;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.state        = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;

    APP_SD_SC_vInitSpeller(&ctxCtrl.s306.spellerCtrl, APP_SD_SC_VOICE_MAIL);

    // per default: immediately show the frame
    ctxCtrl.s306.subState = APP_SD_S306_SHOW_FRAME;

    /* get profile of active user */
    userProfile = ERM_pGetActiveUserProfile();
    if( NULL != userProfile )
    {   // we have an active profile, check if there is already a mailbox number
        // saved in eeprom. If yes, show this, if not, search phonebook
        if( 0 < userProfile->voicemailbox_len )
        {
            // there is a voicemailbox number already, so show this one
            APP_SD_SC_vSetSpelledText(  &ctxCtrl.s306.spellerCtrl,
                                        userProfile->voicemailbox,
                                        userProfile->voicemailbox_len);
            APP_SD_SC_vSetDefaultCtrlSelection(&ctxCtrl.s306.spellerCtrl);
        }
        else
        {
            // search phonebook
            // always start with first keyword
            ctxCtrl.s306.curKeywordIdx  = 0;
            switch(gAppSdContext.curLang )
            {   // choose the right keyword array depending on current language
                case APP_SD_enLANG_German:
                case APP_SD_enLANG_English:
                case APP_SD_enLANG_USEnglish:
                case APP_SD_enLANG_Spanish:
                case APP_SD_enLANG_USSpanish:
                case APP_SD_enLANG_French:
                case APP_SD_enLANG_CanadianFrench:
                case APP_SD_enLANG_Portugese:
                case APP_SD_enLANG_Czech:
                case APP_SD_enLANG_Russian:
                case APP_SD_enLANG_Italian:
                case APP_SD_enLANG_Dutch:
                    // for valid languages use keyword array
                    ctxCtrl.s306.curKeywordArray = APP_SD_aStaticMailboxKeywords[gAppSdContext.curLang];
                    // search for keywords and therefore a different subState is
                    // needed
                    ctxCtrl.s306.subState = APP_SD_S306_SEARCH_MAILBOX_NUMBER_NOT_SENT;
                    break;
                default:
                    // do not search phonebook due to an unexpected language
                    ctxCtrl.s306.curKeywordArray = NULL;
                    // speller will show no voicemail box number and visible
                    // selectable character should be '0'
                    break;
            }
        }
    }

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}


/************************************/
// Sms
/************************************/
void _APP_SD_vInitFrameS402()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S402;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state    = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    ctxCtrl.common.timeout  = APP_SD_MS_TIMEOUT_5000;
    /* set frame data information */

    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
    {
        case APP_SD_CONTEXT_S410:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}

void _APP_SD_vInitFrameS404(Uint16Type numSms)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S404;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_2;
    ctxCtrl.common.listData.listElemOnTop   = numSms + 1; // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 1; // first list elem
    ctxCtrl.common.listData.numListElems    = numSms + 1;  // sms list
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;
    ctxCtrl.common.listData.scrollType      = APP_SD_LIST_SCROLL_TYPE_ENDLESS;

    ctxCtrl.s404.numSms = numSms;

    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
    {
        //case APP_SD_CONTEXT_S406:
        //    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_RESET);
        //    break;
        case APP_SD_CONTEXT_S410:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}

void _APP_SD_vInitFrameS405(Uint16Type smsIndex)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S405;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 6;    // unknown number elements
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    /* there is no VCR menue, if not coded or UltraLow */                     /* RT 2429 */
    if(ERM_SIVR_FULL_SUPPORTED != ERM_enIsVcrSupported())
    {
        ctxCtrl.common.listData.numListElems    = ctxCtrl.common.listData.numListElems - 1;
    }

    ctxCtrl.s405.smsIndex = smsIndex;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS406(Uint16Type smsIndex)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S406;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_5;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 1;    // unknown number elements
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    ctxCtrl.s406.smsIndex = smsIndex;


    if(ctxCtrl.s406.smsIndex <= APP_SMS_u16GetNumUnreadSms())
    {
        ctxCtrl.s406.smsType = AT_SMS_TYPE_UNREAD;
    }
    else if(ctxCtrl.s406.smsIndex <= (APP_SMS_u16GetNumUnreadSms() + APP_SMS_u16GetNumReadSms()))
    {
        ctxCtrl.s406.smsType = AT_SMS_TYPE_READ;
    }
    else
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitFrameS406: invalid smsIndex (%d)",
                      ctxCtrl.s406.smsIndex);
        ctxCtrl.s406.smsType = AT_SMS_TYPE_INVALID;

        /* Go to default screen in error case */
        _APP_SD_vInitIdleScreen(0);
    }

    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
    {
        case APP_SD_CONTEXT_S903:   // new sms
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}

void _APP_SD_vInitFrameS407()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S407;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    /* set frame data information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_4;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 1;    // unknown number elements
    ctxCtrl.common.listData.listOperation   = KPB_MENU_CHANGE;

    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
    {
        case APP_SD_CONTEXT_S520:
        case APP_SD_CONTEXT_S581:
        case APP_SD_CONTEXT_SC13:
            // we need to cancel the inquiry, so set substate
            ctxCtrl.common.state    = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
            ctxCtrl.s407.subState   = APP_SD_S407_STOP_BT_SEARCH_NOT_SENT;
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            // no need to cancel inquiry, show frame directly
            ctxCtrl.common.state    = APP_SD_CTX_FRAME_REQ_DATA;
            ctxCtrl.s407.subState   = APP_SD_S407_STOP_BT_SEARCH_SKIPPED;
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}

void _APP_SD_vInitFrameS408(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S408;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_60000;
    ctxCtrl.common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;
    //ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;

    ctxCtrl.s408.deviceId   = deviceId;
    ctxCtrl.s408.deviceType = deviceType;
    ctxCtrl.s408.retryCounter = 0x00u;
    ctxCtrl.s408.subState   = APP_SD_S408_WAIT_FOR_SERVICE_SUPPORT_CHANGED;
    //ctxCtrl.s408.subState   = APP_SD_S408_NOT_SEND_SSP_SUPPORT;

    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
    {
        case APP_SD_CONTEXT_S515:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
    }
}
void _APP_SD_vInitFrameS408_SSP(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S408;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_60000;
    //ctxCtrl.common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;
    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;

    ctxCtrl.s408.deviceId   = deviceId;
    ctxCtrl.s408.deviceType = deviceType;
    ctxCtrl.s408.retryCounter = 0x00u;
    //ctxCtrl.s408.subState   = APP_SD_S408_WAIT_FOR_SERVICE_SUPPORT_CHANGED;
    ctxCtrl.s408.subState   = APP_SD_S408_NOT_SEND_SSP_SUPPORT;

    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
    {
        case APP_SD_CONTEXT_S515:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
    }
}

void _APP_SD_vInitFrameS663_PB()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S663_PB;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    // SUSANNE 14.11.2009: Ck5050 does not always sent event within 30 seconds
    // make this 60 seconds cause APP_PHONEBOOK already has 30 seconds
    // as timeout. This one here is for fallback only
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_60000;  // this is just for safety so we will not hang forever
                                                            // frame should be canceled by Ck5050 sort end notification
    ctxCtrl.common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;

    // replaces S669 if change of sorting was triggered and command was accepted by Ck5050
    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
}


void _APP_SD_vInitFrameS408_USERLIST()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S408_USERLIST;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_10000;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS408_ABR(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S408_ABR;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;

    // use also s408 data structure  it is not critical because we are in reconnect here
    ctxCtrl.s408.deviceId   = deviceId;
    ctxCtrl.s408.deviceType = deviceType;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_30000; //APP_SD_MS_TIMEOUT_60000;
    ERM_vSetDisconnectWillFollow(BT_TRUE);
    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS408_DEL()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S408_DEL;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;

    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_60000;
    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS408_PLAYER(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S408_PLAYER;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;

    // use also s408 data structure  it is not critical because we are in reconnect here, too
    ctxCtrl.s408.deviceId   = deviceId;
    ctxCtrl.s408.deviceType = deviceType;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_30000;
    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS408_PRECALL()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));
    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S408_PRECALL;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;

    ctxCtrl.common.timeout  = APP_SD_MS_TIMEOUT_15000;

    gAppSdContext.preCallStateIsActive = BT_TRUE;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
}

void _APP_SD_vInitFrameS409(Uint16Type smsIndex)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S409;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_4;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 1;    // unknown number elements
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    //ctxCtrl.s409.smsIndex = smsIndex;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}


void _APP_SD_vInitFrameS410()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S410;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame data information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_4;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 1;    // unknown number elements
    ctxCtrl.common.listData.listOperation   = KPB_MENU_CHANGE;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS413(Uint16Type smsIndex)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S413;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame data information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 2;    // unknown number elements
    ctxCtrl.common.listData.listOperation   = KPB_MENU_CHANGE;

    ctxCtrl.s413.smsIndex = smsIndex;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}


void _APP_SD_vInitFrameSC14(Uint16Type smsIndex)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_SC14;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state        = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId = KPB_FRAME_ID_1;

    ctxCtrl.sc14.smsIndex = smsIndex;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}


void _APP_SD_vInitFrameS425()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S425;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_2000;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame data information */

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
}


void _APP_SD_vInitFrameS428()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S428;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_5000;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame data information */

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
}

/************************************/
// Bluetooth
/************************************/
void _APP_SD_vInitFrameS501()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S501;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state    = APP_SD_CTX_FRAME_REQ_DATA;
    ctxCtrl.common.timeout  = APP_SD_MS_TIMEOUT_2000;


    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
    {
        case APP_SD_CONTEXT_S520:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}

void _APP_SD_vInitFrameS502(Uint8Type focusedElement)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));
    EEPROM_LAYOUT_vGetPlayerEnabled(&ctxCtrl.s502.playerAvail);
    if( SUCCESS != SUCCESS )
    {

        DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "InitFrS502: DIAG_GetPlayEnab failed");

        ctxCtrl.s502.playerAvail = BT_TRUE;
    }


    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "InitFrS502: playerEnabled: %d",
                  ctxCtrl.s502.playerAvail);


    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S502;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_2;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = focusedElement;//0;    // first list elem
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    if(ctxCtrl.s502.playerAvail == BT_TRUE)
    {
        ctxCtrl.common.listData.numListElems = 7;    // menue entries
    }
    else
    {
        ctxCtrl.common.listData.numListElems = 6;    // menue entries (without player)
    }

#ifndef UHV_ACTIVATE_FEATURE_HEADSET
    ctxCtrl.common.listData.numListElems--;
#endif

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS511()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S511;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state    = APP_SD_CTX_FRAME_REQ_DATA;
    ctxCtrl.common.timeout  = APP_SD_MS_TIMEOUT_2000;

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
//        case APP_SD_CONTEXT_S007:
//            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
//            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}

void _APP_SD_vInitFrameS512(Uint8Type numDevs, AT_DeviceId deviceId)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S512;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    // copy params
    ctxCtrl.s512.deviceId       = deviceId;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = numDevs + 1; // <x> dynamic + 1 static entries
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    // copy param
    ctxCtrl.s512.numDevs = numDevs;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
}


void _APP_SD_vInitFrameS513(AT_DeviceId deviceId)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S513;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    // copy params
    ctxCtrl.s513.deviceId       = deviceId;
    gAppSdContext.s408DelDeviceId = deviceId;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 2;
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS514(AT_DeviceId deviceId, BooleanType bIsActive, AT_BTDeviceName btName, Uint16Type btName_len)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S514;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    // copy params
    ctxCtrl.s514.deviceId   = deviceId;
    ctxCtrl.s514.bIsActive  = bIsActive;

    ctxCtrl.s514.btName_len = (AT_BT_DEVICE_NAME_MAX_LEN < btName_len) ? AT_BT_DEVICE_NAME_MAX_LEN : btName_len;
    (void)memcpy( ctxCtrl.s514.btName,
            btName,
            ctxCtrl.s514.btName_len);

    ctxCtrl.common.state    = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    ctxCtrl.common.timeout  = APP_SD_MS_TIMEOUT_2000;

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        case APP_SD_CONTEXT_S555:
        case APP_SD_CONTEXT_S513:
        case APP_SD_CONTEXT_S408_DEL:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}



void _APP_SD_vInitFrameS515(Uint8Type numDevs, APP_DEVICE_DeviceType deviceType)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S515;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_2;
    ctxCtrl.common.listData.listElemOnTop   = 1;            // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;            // first list elem
    ctxCtrl.common.listData.numListElems    = numDevs + 1;  // menue entries
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    ctxCtrl.s515.numDevs    = numDevs;
    ctxCtrl.s515.deviceType = deviceType;

    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
    {
        case APP_SD_CONTEXT_S520:
        case APP_SD_CONTEXT_S581:
        case APP_SD_CONTEXT_SC13:
        case APP_SD_CONTEXT_S522:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}

void _APP_SD_vInitFrameS517(AT_DeviceId deviceId,
                            APP_DEVICE_DeviceType deviceType,
                            BooleanType connect)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S517;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    // copy params
    ctxCtrl.s517.deviceId       = deviceId;
    ctxCtrl.s517.deviceType     = deviceType;

    gAppSdContext.connectCounter  = 0;
    gAppSdContext.connectCounter2 = 0;
    gAppSdContext.disconnectPlayerWillFollow = BT_FALSE;

    if(connect == BT_TRUE)
    {
        ctxCtrl.s517.subState = APP_SD_S517_START_SERIVCE_NOT_SENT;
    }
    else
    {
        ctxCtrl.s517.subState = APP_SD_S517_START_SERIVCE_SENT;
    }

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;

    /* set frame timeout */
    ctxCtrl.common.timeout = APP_SD_MS_TIMEOUT_60000;

    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
    {
        case APP_SD_CONTEXT_S542:
            if(deviceType == APP_DEVICE_enTYPE_PHONE)
            {
                _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_RESET);
            }
            else
            {
                _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            }
            break;
        case APP_SD_CONTEXT_S408:
        case APP_SD_CONTEXT_S572:
        case APP_SD_CONTEXT_S515:   // RT:6375
        case APP_SD_CONTEXT_S541_2: // RT:6375
        case APP_SD_CONTEXT_S52C:
        case APP_SD_CONTEXT_S52D:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        case APP_SD_CONTEXT_S522:
            if(deviceType == APP_DEVICE_enTYPE_PHONE)
            {
                _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_RESET);
            }
            else
            {
                _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            }
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }


    DEBUG_VALUE4( APP_SD_SWI_TRC, MOD_APP_SD, "InitS517: devId: %d, devType: %d, bConn: %d, state: %d",
                  deviceId, deviceType, connect, ctxCtrl.s517.subState);
}

void _APP_SD_vInitFrameS517_PASSIVE( )
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S517_PASSIVE;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.state        = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_60000;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
}


void _APP_SD_vInitFrameS518()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S518;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_5000;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_DATA;
    /* set frame date information */

    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
    {
        case APP_SD_CONTEXT_S408:
        case APP_SD_CONTEXT_S51D:
        case APP_SD_CONTEXT_S52C:
        case APP_SD_CONTEXT_S52D:
        case APP_SD_CONTEXT_S517_PASSIVE:
        case APP_SD_CONTEXT_S517:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        case APP_SD_CONTEXT_SC12:
        case APP_SD_CONTEXT_SC12_2:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_RESET);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}


void _APP_SD_vInitFrameS51D(Uint8Type deviceId,
                            APP_DEVICE_DeviceType deviceType )
{
    ATPinCodeType pinCode;

    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S51D;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    ctxCtrl.s51D.deviceId   = deviceId;
    ctxCtrl.s51D.deviceType = deviceType;

    APP_SD_SC_vInitSpeller(&ctxCtrl.s51D.spellerCtrl, APP_SD_SC_BLUETOOTH_PASSKEY);

    // init with default pin saved in ERM
    ERM_GetBTPinCodeAsChar(&pinCode);
    //ERM_vSetDeviceTypeForPairing(deviceType);
    APP_SD_SC_vSetSpelledText(&ctxCtrl.s51D.spellerCtrl,
                              pinCode.pin,
                              pinCode.pin_len);

    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
    {
        case APP_SD_CONTEXT_S572:
        case APP_SD_CONTEXT_S522:
        case APP_SD_CONTEXT_S408:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}

void _APP_SD_vInitFrameS51D_ACCEPT(Uint8Type deviceId, ATPairingDeviceType remoteDeviceType)
{
    ATPinCodeType pinCode;

    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S51D_ACCEPT;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    ctxCtrl.s51D.deviceId           = deviceId;
    ctxCtrl.s51D.remoteDeviceType   = remoteDeviceType;

    APP_SD_SC_vInitSpeller(&ctxCtrl.s51D.spellerCtrl, APP_SD_SC_BLUETOOTH_PASSKEY);

    // init with default pin saved in ERM
    ERM_GetBTPinCodeAsChar(&pinCode);
    APP_SD_SC_vSetSpelledText(&ctxCtrl.s51D.spellerCtrl,
                              pinCode.pin,
                              pinCode.pin_len);

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
}

void _APP_SD_vInitFrameS520()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S520;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_4;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 1;    // menue entries
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    if( ERM_bIsStartupDone() )
    {
        ctxCtrl.s520.subState = APP_SD_S520_START_INQUIRY_NOT_SENT;
    }
    else
    {
        ctxCtrl.s520.subState = APP_SD_S520_SHOW_ONLY;
    }

    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
    {
        case APP_SD_CONTEXT_S522:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }

}

void _APP_SD_vInitFrameS521()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S521;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;
    /* set frame timeout */
    ctxCtrl.common.timeout = APP_SD_MS_TIMEOUT_5000;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
}

void _APP_SD_vInitFrameS522(APP_SD_enMdiMuteReason muteReason, AT_DeviceId devId, APP_DEVICE_DeviceType devType, BooleanType bConnect)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.s522.lastCtxId      = gAppSdContext.pCurCtxCtrl->common.ctxId;
    ctxCtrl.s522.enMuteReason   = muteReason;
    ctxCtrl.s522.deviceId       = devId;
    ctxCtrl.s522.deviceType     = devType;
    ctxCtrl.s522.bConnect       = bConnect;

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S522;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    // SUSANNE: no handleinit needed, player is stopped through APP_MDI if necessary
    ctxCtrl.common.state        = APP_SD_CTX_FRAME_REQ_DATA;
    //// added the pending handling to process the busy response from MDI
    //ctxCtrl.common.state  = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    //ctxCtrl.s522.subState = APP_SD_S522_PAUSE_STATE_NOT_SENT;

    /* set frame timeout */
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_2000;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS52C(Uint8Type inqId, ATPairingDeviceType pairingDevice, APP_DEVICE_DeviceType appDevice )
{
     AppSdCtxCtrlType ctxCtrl;

    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S52C;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    ctxCtrl.s52C.deviceId      = inqId;
    ctxCtrl.s52C.pairingDeviceType = pairingDevice;
    ctxCtrl.s52C.appDeviceType = appDevice;

    /* Ticket 12510: change from speller control to list item menu */
    //APP_SD_SC_vInitSpeller(&ctxCtrl.s52C.spellerCtrl, APP_SD_SC_BLUETOOTH_SSPKEY);
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_6;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem

    ctxCtrl.common.listData.numListElems    = 2;
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
    {
        case APP_SD_CONTEXT_S408:
        case APP_SD_CONTEXT_S517:
        case APP_SD_CONTEXT_S572:
        case APP_SD_CONTEXT_S522:
        case APP_SD_CONTEXT_S933:
        case APP_SD_CONTEXT_S001:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
    return;
}

void _APP_SD_vInitFrameS52D(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType )
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S52D;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_1000;
    ctxCtrl.common.state    = APP_SD_CTX_FRAME_REQ_DATA;

    ctxCtrl.s52D.deviceId = deviceId;
    ctxCtrl.s52D.appDeviceType = deviceType;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
}

//void _APP_SD_vInitFrameS532()
//{
//    AppSdCtxCtrlType ctxCtrl;
//    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));
//
//    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S532;
//    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
//
//    ctxCtrl.common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;
//    /* set frame date information */
//    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_1;
//    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;
//
//    /* set frame timeout */
//    ctxCtrl.common.timeout = APP_SD_MS_TIMEOUT_5000;
//
//    // RT 2557
//    //_APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
//    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
//}

void _APP_SD_vInitFrameS533()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
    {
        case APP_SD_CONTEXT_S575:
//        case APP_SD_CONTEXT_S580:
            ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S533_2;
            break;
        default:
            ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S533;
            break;
    }


    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_1;
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    /* set frame timeout */
    ctxCtrl.common.timeout = APP_SD_MS_TIMEOUT_5000;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
}

void _APP_SD_vInitFrameS534(AT_DeviceId deviceId)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));


    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S534;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.s534.deviceId       = deviceId;

    gAppSdContext.addProfileCounter = 0;

    if( gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S534 )
    {
        /* 1.)
         * set a timeout before starting to add profile, to
         * avoid flickering if we are to fast */
        ctxCtrl.common.timeout = APP_SD_MS_TIMEOUT_2000;
        ctxCtrl.common.state  = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
        /* just show the screen as first step, after timeout
         * we get active and create the profile */
        ctxCtrl.s534.subState = APP_SD_S534_WAIT_FOR_TIMEOUT;
    }
    else
    {
        /* 2.)
         * now we try to create the profile */
        ctxCtrl.common.timeout = APP_SD_MS_TIMEOUT_60000;   // -> emergency timeout if something went wrong
        ctxCtrl.common.state  = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
        ctxCtrl.s534.subState = APP_SD_S534_ADD_NEW_PROFILE_NOT_SENT;
    }

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}




//void _APP_SD_vInitFrameS535(AT_DeviceId deviceId)
//{
//    AppSdCtxCtrlType ctxCtrl;
//    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));
//
//    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S535;
//    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
//
//    ctxCtrl.common.state    = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
//    ctxCtrl.s535.deviceId   = deviceId;
//
//    APP_SD_SC_vInitSpeller(&ctxCtrl.s535.spellerCtrl, APP_SD_SC_ALPHA_NUMERIC);
//    APP_SD_SC_vSetSpellLimit(&ctxCtrl.s535.spellerCtrl, AT_DEVICE_NAME_MAX_LEN);
//    APP_SD_SC_vSetDefaultCtrlSelection(&ctxCtrl.s535.spellerCtrl);
//
//    if(ERM_GetBTDevice(ctxCtrl.s535.deviceId) != NULL)
//    {
//        const ERMBTDeviceTableType *devInfo = ERM_GetBTDevice(ctxCtrl.s535.deviceId);
//        APP_SD_SC_vSetSpelledText(  &ctxCtrl.s535.spellerCtrl,
//                                    devInfo->device_name,
//                                    devInfo->device_name_len );
//    }
//
//    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
//    {
//        case APP_SD_CONTEXT_S514:
////        case APP_SD_CONTEXT_S007:
//            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
//            break;
//        default:
//            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
//            break;
//    }
//}



void _APP_SD_vInitFrameS536(AT_DeviceId deviceId)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S536;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;

    ctxCtrl.s536.deviceId = deviceId;

    APP_SD_SC_vInitSpeller(&ctxCtrl.s536.spellerCtrl, APP_SD_SC_ALPHA_NUMERIC);
    APP_SD_SC_vSetSpellLimit( &ctxCtrl.s536.spellerCtrl, AT_DEVICE_NAME_MAX_LEN );
    APP_SD_SC_vSetDefaultCtrlSelection(&ctxCtrl.s536.spellerCtrl);

    if(ERM_GetBTDevice(ctxCtrl.s536.deviceId) != NULL)
    {
        const ERMBTDeviceTableType *devInfo = ERM_GetBTDevice(ctxCtrl.s536.deviceId);
        APP_SD_SC_vSetSpelledText(  &ctxCtrl.s536.spellerCtrl,
                                    devInfo->device_name,
                                    devInfo->device_name_len );
    }

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS539()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S539;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_5000;
    ctxCtrl.common.state        = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_RESET);
}

void _APP_SD_vInitFrameS541(Uint8Type numDevs)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S541;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_2;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = numDevs + 1; // <x> dynamic + 1 static entries
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    // copy param
    ctxCtrl.s541.numDevs = numDevs;

    gAppSdContext.disconnectPlayerWillFollow = BT_FALSE;

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        case APP_SD_CONTEXT_S514:
        case APP_SD_CONTEXT_S408_USERLIST:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}
void _APP_SD_vInitFrameS541_2(Uint8Type numDevs)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S541_2;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_2;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = numDevs + 1; // <x> dynamic + 1 static entries
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    // copy param
    ctxCtrl.s541.numDevs = numDevs;

    gAppSdContext.disconnectPlayerWillFollow = BT_FALSE;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS542(AT_DeviceId deviceId, BooleanType bIsActive)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S542;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    // copy params
    ctxCtrl.s542.bIsActive      = bIsActive;
    ctxCtrl.s542.deviceId       = deviceId;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem

    if( BT_TRUE == bIsActive )
    {   /* disconnect available */
        ctxCtrl.common.listData.numListElems    = 5;
    }
    else
    {   /* disconnect not available */
        ctxCtrl.common.listData.numListElems    = 4;
    }
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}


void _APP_SD_vInitFrameS543(AT_DeviceId deviceId)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S543;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    // copy params
    ctxCtrl.s543.deviceId   = deviceId;

    ctxCtrl.common.state    = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    ctxCtrl.common.timeout  = APP_SD_MS_TIMEOUT_5000;

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        case APP_SD_CONTEXT_S542:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}



void _APP_SD_vInitFrameS553()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S553;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 2;    // menue entries
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS554()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    // event Screen always activated
    //_APP_SD_vActivateFrame(BT_TRUE, __LINE__);

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S554;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.bActivation  = BT_TRUE;

    ctxCtrl.common.state    = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    ctxCtrl.common.timeout  = APP_SD_MS_TIMEOUT_2000;

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        case APP_SD_CONTEXT_S553:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}

void _APP_SD_vInitFrameS555(AT_DeviceId deviceId)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S555;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    // copy params
    ctxCtrl.s555.deviceId       = deviceId;
    gAppSdContext.s408DelDeviceId = deviceId;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 2;
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}




void _APP_SD_vInitFrameS556()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S556;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_1;
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    APP_SD_SC_vInitSpeller( &ctxCtrl.s556.spellerCtrl, APP_SD_SC_ALPHA_NUMERIC );
    APP_SD_SC_vSetSpellLimit( &ctxCtrl.s556.spellerCtrl, ERM_BT_DEVICE_NAME_MAXLEN );
    APP_SD_SC_vSetSpelledText(  &ctxCtrl.s556.spellerCtrl,
                                ERM_GetBTDeviceName(),
                                strlen((const char*)ERM_GetBTDeviceName()) );

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS562()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S562;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_2;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 4;    // menue entries
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS563(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S563;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    // copy params
    ctxCtrl.s563.deviceType     = deviceType;
    ctxCtrl.s563.deviceId       = deviceId;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem

    /* disconnect not available */
    ctxCtrl.common.listData.numListElems    = 2;
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS565(APP_DEVICE_DeviceType deviceType)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S565;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_DATA;

    /* set frame timeout */
    ctxCtrl.common.timeout  = APP_SD_MS_TIMEOUT_2000;
    ctxCtrl.s565.deviceType = deviceType;

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        case APP_SD_CONTEXT_S563:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}


void _APP_SD_vInitFrameS567(Uint8Type numDevs)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S567;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_2;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = numDevs + 1; // <x> dynamic + 1 static entries
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    // copy param
    ctxCtrl.s567.numDevs = numDevs;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS5B2(Uint8Type numDevs)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S5B2;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_2;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = numDevs + 1; // <x> dynamic + 1 static entries
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    // copy param
    ctxCtrl.s5B2.numDevs = numDevs;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}




void _APP_SD_vInitFrameS566()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S566;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_5000;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_DATA;
    /* set frame date information */

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS568()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S568;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_5000;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_DATA;
    /* set frame date information */

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS571(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S571;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    // copy params
    ctxCtrl.s571.deviceId       = deviceId;
    ctxCtrl.s571.deviceType     = deviceType;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 4;    //5; authorization feature S577 cancelled
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS572(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType, BooleanType isInquiryId)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S572;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    // copy params
    ctxCtrl.s572.deviceType      = deviceType;
    ctxCtrl.s572.deviceId        = deviceId;
    ctxCtrl.s572.isInquiryId     = isInquiryId;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem

    /* disconnect not available */
    ctxCtrl.common.listData.numListElems    = 2;
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS573(AT_DeviceId deviceId)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S573;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    // copy params
    ctxCtrl.s573.deviceId       = deviceId;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_5000;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS574(AT_DeviceId deviceId)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S574;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    // copy params
    ctxCtrl.s574.deviceId       = deviceId;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_2000;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;


    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "InitS574: devId %d", deviceId);

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
}



void _APP_SD_vInitFrameS575(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S575;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;

    ctxCtrl.s575.deviceId   = deviceId;
    ctxCtrl.s575.deviceType = deviceType;

    APP_SD_SC_vInitSpeller(&ctxCtrl.s575.spellerCtrl, APP_SD_SC_ALPHA_NUMERIC);
    APP_SD_SC_vSetSpellLimit( &ctxCtrl.s575.spellerCtrl, AT_DEVICE_NAME_MAX_LEN );

    APP_SD_SC_vSetDefaultCtrlSelection( &ctxCtrl.s575.spellerCtrl );

    if(ERM_GetBTDevice(ctxCtrl.s575.deviceId) != NULL)
    {
        const ERMBTDeviceTableType *devInfo = ERM_GetBTDevice(ctxCtrl.s575.deviceId);
        APP_SD_SC_vSetSpelledText(  &ctxCtrl.s575.spellerCtrl,
                                    devInfo->device_name,
                                    devInfo->device_name_len );
    }
    else if( ERM_pGetPhyDevice(ctxCtrl.s575.deviceId) != NULL )
    {
        const ERMPhysicalBTDeviceType *phyDevInfo = ERM_pGetPhyDevice(ctxCtrl.s575.deviceId);
        APP_SD_SC_vSetSpelledText(  &ctxCtrl.s575.spellerCtrl,
                                    phyDevInfo->name,
                                    phyDevInfo->name_len );
    }

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}



void _APP_SD_vInitFrameS576(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S576;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    // copy params
    ctxCtrl.s576.deviceId       = deviceId;
    ctxCtrl.s576.deviceType     = deviceType;

    gAppSdContext.s408DelDeviceId = deviceId;


    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 2;
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS578(AT_DeviceId deviceId,
                            APP_DEVICE_DeviceType deviceType,
                            AT_BTDeviceName btName,
                            Uint16Type btName_len)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S578;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    // copy params
    ctxCtrl.s578.deviceId   = deviceId;
    ctxCtrl.s578.deviceType = deviceType;

    ctxCtrl.s578.btName_len = (AT_BT_DEVICE_NAME_MAX_LEN < btName_len) ? AT_BT_DEVICE_NAME_MAX_LEN : btName_len ;
    (void)memcpy( ctxCtrl.s578.btName,
            btName,
            ctxCtrl.s578.btName_len);

    ctxCtrl.common.state    = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    ctxCtrl.common.timeout  = APP_SD_MS_TIMEOUT_2000;

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        case APP_SD_CONTEXT_S576:
        case APP_SD_CONTEXT_S579:
        case APP_SD_CONTEXT_S408_DEL:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}

void _APP_SD_vInitFrameS579(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S579;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    // copy params
    ctxCtrl.s579.deviceId       = deviceId;
    ctxCtrl.s579.deviceType     = deviceType;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 2;
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

//void _APP_SD_vInitFrameS580(AT_DeviceId deviceId, APP_DEVICE_DeviceType deviceType)
//{
//    AppSdCtxCtrlType ctxCtrl;
//    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));
//
//    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S580;
//    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
//
//    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
//
//    ctxCtrl.s580.deviceId   = deviceId;
//    ctxCtrl.s580.deviceType = deviceType;
//
//    APP_SD_SC_vInitSpeller(&ctxCtrl.s580.spellerCtrl, APP_SD_SC_ALPHA_NUMERIC);
//    APP_SD_SC_vSetSpellLimit( &ctxCtrl.s580.spellerCtrl, AT_DEVICE_NAME_MAX_LEN );
//
//    APP_SD_SC_vSetDefaultCtrlSelection(&ctxCtrl.s580.spellerCtrl);
//
//    if(ERM_GetBTDevice(ctxCtrl.s580.deviceId) != NULL)
//    {
//        const ERMBTDeviceTableType *devInfo = ERM_GetBTDevice(ctxCtrl.s580.deviceId);
//        APP_SD_SC_vSetSpelledText(  &ctxCtrl.s580.spellerCtrl,
//                                    devInfo->device_name,
//                                    devInfo->device_name_len );
//    }
//    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
//    {
//        case APP_SD_CONTEXT_S517:
//            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
//            break;
//        default:
//            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
//            break;
//    }
//}

void _APP_SD_vInitFrameS581()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S581;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_4;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 1;    // menue entries
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
    {
        case APP_SD_CONTEXT_S522:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}

void _APP_SD_vInitFrameS582()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S582;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_2000;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_DATA;
    /* set frame date information */

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        case APP_SD_CONTEXT_S581:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}



void _APP_SD_vInitFrameS597(AT_DeviceId deviceId)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S597;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.s597.deviceId       = deviceId;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */

    /* set frame timeout */
    ctxCtrl.common.timeout  = APP_SD_MS_TIMEOUT_5000;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}


void _APP_SD_vInitFrameS599()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S599;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state        = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_5000;

    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
    {
        case APP_SD_CONTEXT_S408:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}


/************************************/
// Settings
/************************************/

void _APP_SD_vInitFrameS601()
{   // Telefonbuch Einstellungen Menü
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S601;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_2;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
#ifdef UHV_ACTIVATE_FEATURE_SET_AUDIO_MODE
    ctxCtrl.common.listData.numListElems    = 5;    // menue entries
#else
    ctxCtrl.common.listData.numListElems    = 4;    // menue entries
#endif
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}



/************************************/
// Audio Mode
/************************************/
void _APP_SD_vInitFrameS602()
{   // Sortierung Telefonbuch auswählen
    const ERMUserProfileType * profile = ERM_pGetActiveUserProfile();

    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S602;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state  = APP_SD_CTX_FRAME_REQ_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_2;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 3;    // menue entries
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    /* set default */
    ctxCtrl.s602.audioMode = ERM_AUDIO_MODE_CALLS_ONLY;
    if( profile != NULL)
    {   /* overwrite with profile specific */
        ctxCtrl.s602.audioMode = profile->audio_mode;
    }


    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}



/************************************/
// Signaleinstellungen
/************************************/


void _APP_SD_vInitFrameS641()
{   // Telefonbuch Einstellungen Menü
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S641;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_2;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
#ifdef UHV_ACTIVATE_FEATURE_PLAY_CALLER_NAME
    ctxCtrl.common.listData.numListElems    = 3;    // menue entries
#else
    ctxCtrl.common.listData.numListElems    = 2;    // menue entries
#endif
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    /* there is no VCR menue, if not coded or UltraLow */                   /* RT 2429 */
    if(ERM_SIVR_FULL_SUPPORTED != ERM_enIsVcrSupported())
    {
        //SUSANNE: 02.09.2009 Do not just decrase number, but set it to 2: Cause the number could
        // be already set to 2 due to the deactivation of the Play Caller Name Feature. In this case we would get
        // only one list element here, which would be not ok!!!
        ctxCtrl.common.listData.numListElems    = 2;    // menue entries
        //ctxCtrl.common.listData.numListElems    = ctxCtrl.common.listData.numListElems - 1;
    }

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}



/************************************/
// Telefonbuch settings
/************************************/
void _APP_SD_vInitFrameS661()
{   // Telefonbuch Einstellungen Menü
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S661;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId            = KPB_FRAME_ID_2;
    ctxCtrl.common.listData.listElemOnTop      = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems       = 3;    // menue entries
    ctxCtrl.common.listData.listOperation      = KPB_NO_LIST_OPERATION;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS663()
{   // Telefonbuch wird geladen
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S663;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;

    /* set frame timeout */
    ctxCtrl.common.timeout = APP_SD_MS_TIMEOUT_2000;

    gAppSdContext.bManualPbUpdateFinished = BT_TRUE; // RT #5847

    // SUSANNE: 31.08.2009 Ticket #2599
    // we need to take care about the history if we step out of the phonebook
    // but with a reset we have no chance to show correct history if the phonebook
    // list was entered via an update of the phonebook
    //SUSANNE 14.11.2009, see new handling below
    // _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
    //END SUSANNE 14.11.2009, see new handling below

    //_APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_RESET);
    // END: #2599

    // SUSANNE 14.11.2009
    // we need to override S669
    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        case APP_SD_CONTEXT_S669:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}


void _APP_SD_vInitFrameS664()
{   // Telefonbuch kann nicht geladen werden
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S664;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;

    /* set frame timeout */
    ctxCtrl.common.timeout = APP_SD_MS_TIMEOUT_5000;

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        case APP_SD_CONTEXT_S669:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}


void _APP_SD_vInitFrameS642(Uint16Type numRingtones)
{
    const ERMUserProfileType *pActProfile = ERM_pGetActiveUserProfile();
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S642;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state  = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_2;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = numRingtones + 1;    // menue entries
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;
    if( pActProfile != NULL )
    {
        ctxCtrl.s642.ringtone = pActProfile->ringtone;
//        (void)APP_SD_LC_sfSetSelectedIndex( &(ctxCtrl.common.listData),
//                                            ERM_GetIndexForRingtone(ctxCtrl.s642.ringtone));		// always first entry must be shown of entry in select ringtone menu
    }

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS669()
{   // Sortierung Telefonbuch auswählen
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S669;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state  = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_2;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 3;    // menue entries
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}



/************************************/
// call handling
/************************************/

void _APP_SD_vInitFrameS801_CallList(APP_PHONEBOOK_enSelectedPbType pbType, Uint16Type pbIndex)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    // event Screen always activated
    //_APP_SD_vActivateFrame(BT_TRUE, __LINE__);

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S801;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.bActivation  = BT_TRUE;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem

    /* there is no headset menue, if no headset is connected */
    if( NULL == ERM_pGetActiveHeadsetProfile())
    {
        ctxCtrl.common.listData.numListElems    = 2;
    }
    else
    {
        ctxCtrl.common.listData.numListElems    = 3;
    }

    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    ctxCtrl.s801.plccIndex  = AT_CALL_INDEX_NONE;
    ctxCtrl.s801.subState   = APP_SD_S801_NUMBER_NOT_REQUESTED;
    ctxCtrl.s801.pbType     = pbType;
    ctxCtrl.s801.pbIndex    = pbIndex;
    ctxCtrl.s801.pnIndex    = 0;
    ctxCtrl.s801.number_len = 0;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_RESET);
}

void _APP_SD_vInitFrameS801_PB(Uint16Type pbIndex, Uint16Type pnIndex)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    // event Screen always activated
    //_APP_SD_vActivateFrame(BT_TRUE, __LINE__);

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S801;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.bActivation  = BT_TRUE;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem

    /* there is no headset menue, if no headset is connected */
    if( NULL == ERM_pGetActiveHeadsetProfile())
    {
        ctxCtrl.common.listData.numListElems    = 2;
    }
    else
    {
        ctxCtrl.common.listData.numListElems    = 3;
    }

    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    ctxCtrl.s801.plccIndex  = AT_CALL_INDEX_NONE;
    ctxCtrl.s801.subState   = APP_SD_S801_NUMBER_NOT_REQUESTED;
    ctxCtrl.s801.pbType     = APP_PHONEBOOK_enUsersPB;
    ctxCtrl.s801.pbIndex    = pbIndex;
    ctxCtrl.s801.pnIndex    = pnIndex;
    ctxCtrl.s801.number_len = 0;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_RESET);
}


void _APP_SD_vInitFrameS801_PN(const Uint8Type *pPhoneNumber, Uint8Type phoneNumberLen, BooleanType dial)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    // event Screen always activated
    //_APP_SD_vActivateFrame(BT_TRUE, __LINE__);

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S801;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.bActivation  = BT_TRUE;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem

    /* there is no headset menue, if no headset is connected */
    if( NULL == ERM_pGetActiveHeadsetProfile())
    {
        ctxCtrl.common.listData.numListElems    = 2;
    }
    else
    {
        ctxCtrl.common.listData.numListElems    = 3;
    }

    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    if(dial == BT_TRUE)
    {
        /* check if number is valid */
        if( BT_FALSE == APP_PHONE_bIsValidPhoneNumber(pPhoneNumber, phoneNumberLen))
        {
            _APP_SD_vInitFrameS806();
            return;
        }
        ctxCtrl.s801.subState   = APP_SD_S801_NUMBER_REQUESTED;
    }
    else
    {
        ctxCtrl.s801.subState   = APP_SD_S801_NUMBER_DIALED;
    }
    ctxCtrl.s801.plccIndex  = AT_CALL_INDEX_NONE;
    ctxCtrl.s801.pbType     = APP_PHONEBOOK_enPbUnknown;
    ctxCtrl.s801.pbIndex    = 0;
    ctxCtrl.s801.pnIndex    = 0;
    ctxCtrl.s801.number_len = (sizeof(ctxCtrl.s801.number) < phoneNumberLen) ? sizeof(ctxCtrl.s801.number) : phoneNumberLen;
    (void)memcpy( ctxCtrl.s801.number, pPhoneNumber, ctxCtrl.s801.number_len);

    if( dial == BT_TRUE || ERM_pGetActiveUserProfile() == NULL )
    {
        _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_RESET);
    }
    else
    {
        switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
        {
            case APP_SD_CONTEXT_S811:
            //case APP_SD_CONTEXT_S305:
            //case APP_SD_CONTEXT_S306:
            //case APP_SD_CONTEXT_S929:
            //case APP_SD_CONTEXT_S924:
            case APP_SD_CONTEXT_SC14:
            case APP_SD_CONTEXT_SC20:
            // bt sdevice search frames, Ck5050 will cancel inquiry during an outg. call
            case APP_SD_CONTEXT_S520:
            case APP_SD_CONTEXT_S581:
            case APP_SD_CONTEXT_SC13:
                /* call held */
                _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
                break;
            default:
                _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_RESET);
                break;
        }
    }
}

void _APP_SD_vInitFrameS802(APP_SD_S802_ErrorType error)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S802;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    // RT #3188, the handling of the different error state was postponed to SOP2
    // to SOP1 only the screen "Rufaufbau fehlgeschlagen" was showen for every error
    // and a timeout for 5 sec. was added.
//    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_4;
//    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
//    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
//    ctxCtrl.common.listData.numListElems    = 1;
//    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_1;
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;
    ctxCtrl.common.timeout  = APP_SD_MS_TIMEOUT_5000;

    ctxCtrl.s802.error = error;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
}


void _APP_SD_vInitFrameS803(ATCallIndexEnum plccIdx)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S803;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.bActivation  = BT_TRUE;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    if( gAppSdContext.bHeadSetActivated == BT_TRUE)		// RT 2276
    {
        ctxCtrl.common.listData.listElemOnTop   = 2;    // show listelement Headset
        ctxCtrl.common.listData.focusedListElemOffset = 1;    // show listelement Headset
        gAppSdContext.bHeadSetActivated = BT_FALSE;
    }
    else
    {
        ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
        ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    }
    /* check hfp version */
    if( (APP_PHONE_enGetHfpVersion() == AT_CODPROF_HANDSFREE_1_00) ||
        (APP_PHONE_enGetHfpVersion() == AT_CODPROF_HANDSFREE_0_96) ||
        (BT_TRUE == ERM_bIsCDMAPhone()) )
    {
            ctxCtrl.common.listData.numListElems    = 5;
            ctxCtrl.s803.bholdSupported             = BT_FALSE;
    }
     else
     {
        ctxCtrl.common.listData.numListElems    = 6;
        ctxCtrl.s803.bholdSupported             = BT_TRUE;
     }

    /* there is no headset menue, if no headset is connected */
    if( NULL == ERM_pGetActiveHeadsetProfile())
    {
        ctxCtrl.common.listData.numListElems    = ctxCtrl.common.listData.numListElems - 1;
    }

    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    ctxCtrl.s803.plccIndex = plccIdx;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
}

void _APP_SD_vInitFrameS804()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S804;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.timeout		= APP_SD_MS_TIMEOUT_20000;	//RT12883


    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_1;
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    APP_SD_SC_vInitSpeller(&ctxCtrl.s804.spellerCtrl, APP_SD_SC_DTMF);

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS806()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S806;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_5000;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        // there might be a check for a valid number failed in S801 after requesting number
        // in this case we don't want to step back to S801
        case APP_SD_CONTEXT_S801:
        case APP_SD_CONTEXT_S945:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }

}


void _APP_SD_vInitFrameS807()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S807;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_5000;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)         //RT #4278
    {
        // there might be a check for a valid number failed in S212 after requesting number
        case APP_SD_CONTEXT_S212:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}



void _APP_SD_vInitFrameS811(ATCallIndexEnum plccIdx)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S811;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    if (plccIdx == AT_CALL_INDEX_CONFERENCE)
    {
        ctxCtrl.common.listData.numListElems    = 2;
    }
    else
    {
        ctxCtrl.common.listData.numListElems    = 5;
    }
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    ctxCtrl.s811.plccIndex = plccIdx;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
}

void _APP_SD_vInitFrameS812(ATCallIndexEnum activePlccIdx, ATCallIndexEnum heldPlccIdx)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S812;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    ctxCtrl.s812.activePlccIdx  = activePlccIdx;
    ctxCtrl.s812.heldPlccIdx    = heldPlccIdx;

    if( (APP_PHONE_enGetHfpVersion() == AT_CODPROF_HANDSFREE_1_00) ||
        (APP_PHONE_enGetHfpVersion() == AT_CODPROF_HANDSFREE_0_96)  ||
        (BT_TRUE == ERM_bIsCDMAPhone()) )
    {
        ctxCtrl.common.listData.numListElems    = 5;
    }
    else
    {
        ctxCtrl.common.listData.numListElems    = 7;
    }
    /* there is no headset menue, if no headset is connected */
    if( NULL == ERM_pGetActiveHeadsetProfile())
    {
        ctxCtrl.common.listData.numListElems    = ctxCtrl.common.listData.numListElems - 1;
    }

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
}

void _APP_SD_vInitFrameS814()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S814;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state    = APP_SD_CTX_FRAME_REQ_DATA;
    ctxCtrl.common.timeout  = APP_SD_MS_TIMEOUT_5000;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}


void _APP_SD_vInitFrameS815()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S815;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    if( (APP_PHONE_enGetHfpVersion() == AT_CODPROF_HANDSFREE_1_00) ||
        (APP_PHONE_enGetHfpVersion() == AT_CODPROF_HANDSFREE_0_96)  ||
        (BT_TRUE == ERM_bIsCDMAPhone()) )
    {
        ctxCtrl.common.listData.numListElems    = 3;
    }
    else
    {
        ctxCtrl.common.listData.numListElems    = 4;
    }

    /* there is no headset menue, if no headset is connected */
    if( NULL == ERM_pGetActiveHeadsetProfile())
    {
        ctxCtrl.common.listData.numListElems    = ctxCtrl.common.listData.numListElems - 1;
    }

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
}

void _APP_SD_vInitFrameS901(ATCallIndexEnum plccIdx)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S901;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 4;
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    ctxCtrl.s901.plccIndex = plccIdx;

    /* there is no headset menue, if no headset is connected */
    if( NULL == ERM_pGetActiveHeadsetProfile())
    {
        ctxCtrl.common.listData.numListElems    = ctxCtrl.common.listData.numListElems - 1;
    }

    if(ERM_pGetActiveUserProfile() == NULL)
    {
        _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_RESET);
    }
    else
    {
        switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
        {
            case APP_SD_CONTEXT_S902:
            case APP_SD_CONTEXT_SC14:
                _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
                break;
            default:
                _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
                break;
        }
    }
}

void _APP_SD_vInitFrameS902(ATCallIndexEnum activePlccIdx, ATCallIndexEnum waitingPlccIdx)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S902;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    ctxCtrl.s902.activePlccIdx  = activePlccIdx;
    ctxCtrl.s902.waitingPlccIdx = waitingPlccIdx;

    if((APP_PHONE_enGetHfpVersion() == AT_CODPROF_HANDSFREE_1_00) ||
       (APP_PHONE_enGetHfpVersion() == AT_CODPROF_HANDSFREE_0_96) ||
       (BT_TRUE == ERM_bIsCDMAPhone()))
    {
        ctxCtrl.common.listData.numListElems    = 2;
    }
    else
    {
        ctxCtrl.common.listData.numListElems    = 3;
    }

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
}

void _APP_SD_vInitFrameS903()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    // event Screen always activated
    //_APP_SD_vActivateFrame(BT_TRUE, __LINE__);

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S903;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.bActivation  = BT_TRUE;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 3;
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    /* there is no VCR menue, if not coded or UltraLow */                   /* RT 2429 */
    if(ERM_SIVR_FULL_SUPPORTED != ERM_enIsVcrSupported())
    {
        ctxCtrl.common.listData.numListElems    = ctxCtrl.common.listData.numListElems - 1;
    }

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}


void _APP_SD_vInitFrameS904()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    // event Screen always activated
    //_APP_SD_vActivateFrame(BT_TRUE, __LINE__);

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S904;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.bActivation  = BT_TRUE;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 2;
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    /* ticket 12216: fixe merged from polo branch */
    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        case APP_SD_CONTEXT_S802:    // Call Fehler beim Rufaufbau
        case APP_SD_CONTEXT_SC23:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}

void _APP_SD_vInitFrameS913()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    // event Screen always activated
    //_APP_SD_vActivateFrame(BT_TRUE, __LINE__);


    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S913;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.bActivation  = BT_TRUE;

    ctxCtrl.common.state    = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;
    ctxCtrl.common.timeout  = APP_SD_MS_TIMEOUT_5000;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS914(AT_DeviceId deviceId)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    // event Screen always activated
    //_APP_SD_vActivateFrame(BT_TRUE, __LINE__);


    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S914;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.bActivation  = BT_TRUE;

    ctxCtrl.common.state    = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    ctxCtrl.common.timeout  = APP_SD_MS_TIMEOUT_5000;

    ctxCtrl.s914.deviceId   = deviceId;

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        case APP_SD_CONTEXT_S563: // RT 2544
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}


void _APP_SD_vInitFrameS916()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S916;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state    = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;
    ctxCtrl.common.timeout  = APP_SD_MS_TIMEOUT_5000;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS917()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S917;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state    = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;
    ctxCtrl.common.timeout  = APP_SD_MS_TIMEOUT_5000;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS923()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S923;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state        = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_5000;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}



void _APP_SD_vInitFrameS924()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    // event Screen always activated
    //_APP_SD_vActivateFrame(BT_TRUE, __LINE__);

    if(gAppSdContext.ctxInView != APP_SD_UHV_IN_ASG_VIEW) //RT #4694
    {
        (void)_APP_SD_vSetCtxHistoryState(APP_SD_WAIT_BACK_TO_ASG_MENU, __LINE__);
    }

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S924;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.bActivation  = BT_TRUE;

    ctxCtrl.common.state                            = APP_SD_CTX_FRAME_REQ_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId    = KPB_FRAME_ID_1;

    if(NULL == ERM_pGetActiveUserProfile())
    {
        switch(gAppSdContext.pCurCtxCtrl->common.ctxId)     //RT #4087
        {
            case APP_SD_CONTEXT_S001:   // connect user
//            case APP_SD_CONTEXT_S007:   // new mobTel
            case APP_SD_CONTEXT_S408:   // please wait after entering pin
            case APP_SD_CONTEXT_S51D:   // enter pin
            case APP_SD_CONTEXT_S511:
            case APP_SD_CONTEXT_S512:
            case APP_SD_CONTEXT_S513:
            case APP_SD_CONTEXT_S514:
            case APP_SD_CONTEXT_S517:
//            case APP_SD_CONTEXT_S532:
            case APP_SD_CONTEXT_S533:
            case APP_SD_CONTEXT_S533_2:
            case APP_SD_CONTEXT_S534:
//            case APP_SD_CONTEXT_S535:
            case APP_SD_CONTEXT_SC12:   // connect player
            case APP_SD_CONTEXT_SC12_2:
//            case APP_SD_CONTEXT_SC17:
            case APP_SD_CONTEXT_S520:   // search phone
            case APP_SD_CONTEXT_S581:   // search headset
            case APP_SD_CONTEXT_SC13:   // search player
            case APP_SD_CONTEXT_SC23:   // eingehende BT Verbindung nicht nöglich da Telefon verbunden
            case APP_SD_CONTEXT_S903:   // neue SMS at moment this will not happen because feature is deactivated
            case APP_SD_CONTEXT_S914:   // Verbindung zu verbundenem Player verloren
            case APP_SD_CONTEXT_S917:   // Mobiltelfon antwortet nicht
            case APP_SD_CONTEXT_S923:  // Aktualisierung Telefonbuch fehlgeschlagen
            case APP_SD_CONTEXT_S925:  // Telefonbuch unvollständig geladen
            case APP_SD_CONTEXT_S927:  // Telefonbuch laden fehlgeschlagen
            case APP_SD_CONTEXT_S928:  // Nach PTT: Sprachbedienung noch nicht bereit
            case APP_SD_CONTEXT_S930:  // Telefonbuch wurde aktualisiert
            case APP_SD_CONTEXT_S933:
            case APP_SD_CONTEXT_S934:  // Verbunden mit BT-HeadSet <Gerätename>
            case APP_SD_CONTEXT_S935:  // Eingehende BT-Verb. nicht mögl. da HeadSet verbunden
                _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
                break;
            default:
                _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_RESET);
                break;
        }
    }
    else
    {
        // sometimes we wanna replace the current frame cause e.g. its also just an
        // event popup which shall not be shown again when we go back in history
        switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
        {
            case APP_SD_CONTEXT_S903: // new sms
            case APP_SD_CONTEXT_SC01: // Ambiguous name
            case APP_SD_CONTEXT_S105:
            case APP_SD_CONTEXT_S534: //RT #4009
            case APP_SD_CONTEXT_SA01: //RT #3922
            case APP_SD_CONTEXT_SA02: //RT #3922
            case APP_SD_CONTEXT_SA03: //RT #3922
                _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
                break;
            default:
                _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
                break;
        }
    }
}

void _APP_SD_vInitFrameS925()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));
    //RT #3545
    // event Screen always activated
    //_APP_SD_vActivateFrame(BT_TRUE, __LINE__);

    if(gAppSdContext.ctxInView != APP_SD_UHV_IN_ASG_VIEW)
    {
        (void)_APP_SD_vSetCtxHistoryState(APP_SD_WAIT_BACK_TO_ASG_MENU, __LINE__);
    }

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S925;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.bActivation  = BT_TRUE;

    ctxCtrl.common.state        = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_5000;

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)         // RT 3199
    {
        case APP_SD_CONTEXT_S663:
        case APP_SD_CONTEXT_S663_PB:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}

void _APP_SD_vInitFrameS927()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));
    //RT #3545
    // event Screen always activated
    //_APP_SD_vActivateFrame(BT_TRUE, __LINE__);

    if(gAppSdContext.ctxInView != APP_SD_UHV_IN_ASG_VIEW)
    {
        (void)_APP_SD_vSetCtxHistoryState(APP_SD_WAIT_BACK_TO_ASG_MENU, __LINE__);
    }

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S927;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.bActivation  = BT_TRUE;

    ctxCtrl.common.state        = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_5000;

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)         // RT 3199
    {
        case APP_SD_CONTEXT_S663:
        case APP_SD_CONTEXT_S663_PB:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}



void _APP_SD_vInitFrameS928()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    // event Screen always activated
    //_APP_SD_vActivateFrame(BT_TRUE, __LINE__);

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S928;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.bActivation  = BT_TRUE;

    ctxCtrl.common.state        = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_5000;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS929(ATPhoneNumberType number, Uint16Type number_len)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S929;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state        = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;

    number_len = (sizeof(ctxCtrl.s929.number) > number_len) ?
                 number_len : sizeof(ctxCtrl.s929.number);
    (void)memset(ctxCtrl.s929.number, 0, sizeof(ctxCtrl.s929.number));
    (void)memcpy(ctxCtrl.s929.number,number,number_len);
    ctxCtrl.s929.number_len     = number_len;

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        case APP_SD_CONTEXT_S924:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}

void _APP_SD_vInitFrameS930()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S930;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state        = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_5000;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS933()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S933;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.state        = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    ctxCtrl.common.bActivation  = BT_TRUE;

    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem

    ctxCtrl.common.listData.numListElems    = 2;
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;


    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS934(AT_DeviceId deviceId)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S934;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    // copy params
    ctxCtrl.s934.deviceId       = deviceId;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_2000;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS935()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S935;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;

    /* set frame timeout */
    ctxCtrl.common.timeout = APP_SD_MS_TIMEOUT_5000;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameS941(ATCallIndexEnum plccIndex)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S941;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    /* set frame date information */
    ctxCtrl.common.listData.frameId = KPB_FRAME_ID_1;
    ctxCtrl.common.state            = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    ctxCtrl.s941.plccIndex = plccIndex;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_RESET);
}

void _APP_SD_vInitFrameS942(ATCallIndexEnum plccIdx)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S942;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state    = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    ctxCtrl.common.timeout  = APP_SD_MS_TIMEOUT_60000;

    /* set frame date information */
    ctxCtrl.common.listData.frameId = KPB_FRAME_ID_1;

    ctxCtrl.s942.plccIndex = plccIdx;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
}

void _APP_SD_vInitFrameS945_PN(const Uint8Type *pPhoneNumber, Uint8Type phoneNumberLen, BooleanType dial)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_S945;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId = KPB_FRAME_ID_1;

    if(dial == BT_TRUE)
    {
        /* check if number is valid */
        if( BT_FALSE == APP_PHONE_bIsValidPhoneNumber(pPhoneNumber, phoneNumberLen))
        {
            _APP_SD_vInitFrameS806();
            return;
        }
        ctxCtrl.s945.subState = APP_SD_S945_NUMBER_REQUESTED;
    }
    else
    {
        ctxCtrl.s945.subState = APP_SD_S945_NUMBER_DIALED;
    }

    ctxCtrl.s945.pbType     = APP_PHONEBOOK_enPbUnknown;
    ctxCtrl.s945.pbIndex    = 0;
    ctxCtrl.s945.pnIndex    = 0;
    ctxCtrl.s945.number_len = (sizeof(ctxCtrl.s945.number) < phoneNumberLen) ? sizeof(ctxCtrl.s945.number) : phoneNumberLen;
    (void)memcpy( ctxCtrl.s945.number, pPhoneNumber, ctxCtrl.s945.number_len);

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_RESET);
}

void _APP_SD_vInitFrameSC01(const AppSdResultContactAmbType *pContactAmb)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_SC01;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_2;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = pContactAmb->num_ids + 1; // menue entries
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    // no length check needed to to same type
    (void)memcpy(&ctxCtrl.sc01.contactAmb, pContactAmb, sizeof(*pContactAmb));

    _APP_SD_vActivateFrame(BT_TRUE, __LINE__);

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
}


//*********************************************/
// Init Media Player frames
//*********************************************/
void _APP_SD_vInitFrameSC03(Uint8Type focusedElement)
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_SC03;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_2;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = focusedElement;    // first list elem
    ctxCtrl.common.listData.numListElems    = 4;    // menue entries
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameSC04()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_SC04;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_5000;
    ctxCtrl.common.state        = APP_SD_CTX_FRAME_REQ_DATA;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}

void _APP_SD_vInitFrameSC07()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_SC07;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_5000;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_DATA;
    /* set frame date information */

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        case APP_SD_CONTEXT_SC13:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}

void _APP_SD_vInitFrameSC12(Uint8Type playerProfId)
{
    AppSdCtxCtrlType ctxCtrl;
    const ERMPlayerHeadsetProfileType * pPlayerProfile = ERM_pGetPlayerHeadsetProfile(playerProfId);

    if(NULL == pPlayerProfile)
    {   /* cannot connect player, due to unknown profile */
        DEBUG_VALUE1(APP_SD_SWI_ERR, MOD_APP_SD, "InitFrSC12: no valid player profile for index %d, init failed",
                     playerProfId);
        // TODO: We could show S518 here? Connection not possible
        return;
    }

    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_SC12;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_45000;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_4;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 1;    // menue entries
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;


    gAppSdContext.sc12profileId = playerProfId;
    gAppSdContext.sc12DeviceId = pPlayerProfile->deviceIndex;

    gAppSdContext.disconnectPlayerCounter = 0;
    gAppSdContext.connectCounter = 0;

    DEBUG_VALUE2(APP_SD_SWI_TRC, MOD_APP_SD, "InitFrSC12: ERM_u8GetActivePlayer(): %d, associated Player: %d ",
            ERM_u8GetActivePlayer(), pPlayerProfile->deviceIndex);

    if((ERM_u8GetActivePlayer() != AT_INVALID_DEVICE_ID) &&
       (ERM_u8GetActivePlayer() != pPlayerProfile->deviceIndex) &&
       (ERM_u8GetActiveDeviceAVRCP()!= pPlayerProfile->deviceIndex))
    {/* if a2dp is already connected to the associated device and no avrc dont disconnect it ( changed: 14.02.2011 nikolov,RT:9959)*/
        gAppSdContext.sc12SubState = APP_SD_SC12_DISCONNECT_NOT_SENT;
    }
    else
    {
        gAppSdContext.sc12SubState = APP_SD_SC12_CONNECT_NOT_SENT;
    }

    if (gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_S534)
    {
        gAppSdContext.sc12SubState = APP_SD_SC12_CONNECT_NOT_SENT;
        //ctxCtrl.common.timeout = APP_SD_MS_TIMEOUT_15000;
        ctxCtrl.common.timeout = APP_SD_MS_TIMEOUT_45000;
        _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_RESET);
    }
    else
    {
        _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
    }
}

void _APP_SD_vInitFrameSC12_2(Uint8Type playerProfId, Uint8Type count)
{
    AppSdCtxCtrlType ctxCtrl;

    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_SC12_2;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.timeout      = APP_SD_MS_TIMEOUT_60000;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_4;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 1;    // menue entries
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;


    //gAppSdContext.sc12profileId = playerProfId;
    //gAppSdContext.sc12DeviceId = pPlayerProfile->deviceIndex;
    gAppSdContext.sc12DeviceId = playerProfId;

    gAppSdContext.disconnectPlayerCounter = 0;
    gAppSdContext.connectCounter = 0;

    gAppSdContext.sc12Counter = count;

    if(ERM_bIsStartupDone() == BT_FALSE)
    {
        gAppSdContext.sc12SubState = APP_SD_SC12_SHOW_ONLY;
    }
    else if(ERM_u8GetActivePlayer() != AT_INVALID_DEVICE_ID)
    {
        gAppSdContext.sc12SubState = APP_SD_SC12_DISCONNECT_NOT_SENT;
    }
    else
    {
        gAppSdContext.sc12SubState = APP_SD_SC12_CONNECT_NOT_SENT;
    }

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_RESET);
}
void _APP_SD_vInitFrameSC13()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_SC13;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_4;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 1;    // menue entries
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    if( ERM_bIsStartupDone() )
    {
        ctxCtrl.sc13.subState = APP_SD_SC13_START_INQUIRY_NOT_SENT;
    }
    else
    {
        ctxCtrl.sc13.subState = APP_SD_SC13_SHOW_ONLY;
    }

    switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
    {
        case APP_SD_CONTEXT_S522:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}




/* play caller name when contact is ringing */
void _APP_SD_vInitFrameSC16()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_SC16;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state  = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 3;    // menue entries

    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}



//void _APP_SD_vInitFrameSC17(AT_DeviceId deviceId)
//{
//    AppSdCtxCtrlType ctxCtrl;
//    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));
//
//    // event Screen always activated
//    //_APP_SD_vActivateFrame(BT_TRUE, __LINE__);
//
//    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_SC17;
//    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
//    ctxCtrl.common.bActivation  = BT_TRUE;
//
//    ctxCtrl.common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;
//
//    /* set frame timeout */
//    ctxCtrl.common.timeout = APP_SD_MS_TIMEOUT_5000;
//
//    ctxCtrl.sc17.deviceId = deviceId;
//
//    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
//    {
//        case APP_SD_CONTEXT_S924:
//            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
//            break;
//        default:
//            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
//            break;
//    }
//}


void _APP_SD_vInitFrameSC22()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));
    //RT #3545
    // event Screen always activated
    //_APP_SD_vActivateFrame(BT_TRUE, __LINE__);

    if(gAppSdContext.ctxInView != APP_SD_UHV_IN_ASG_VIEW)
    {
        (void)_APP_SD_vSetCtxHistoryState(APP_SD_WAIT_BACK_TO_ASG_MENU, __LINE__);
    }

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_SC22;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.bActivation  = BT_TRUE;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;

    /* set frame timeout */
    ctxCtrl.common.timeout = APP_SD_MS_TIMEOUT_2000;

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        case APP_SD_CONTEXT_S663:     // RT #5847
        case APP_SD_CONTEXT_S663_PB:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
        	/*RT12983: This will be handled in context history step back */
            /* when VCR is active -> screen append and not replace */
        	/*
            if (APP_SD_CONTEXT_S924 == gAppSdContext.pCurCtxCtrl->common.ctxId)
            {
                gAppSdContext.bPbUpdateComplete = BT_TRUE;
            }
            */

            /*RT12983: when s663_pb is active -> incoming call comes */
            if (_APP_SD_pGetHistoryContext(APP_SD_CONTEXT_S663_PB) != NULL)
            {
                DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "12983: CtxStepBack: Screen S663_PB is present in the context history");

                gAppSdContext.bPbUpdateComplete = BT_TRUE;
            }

            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}

void _APP_SD_vInitFrameSC23()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_SC23;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;

    /* set frame timeout */
    ctxCtrl.common.timeout = APP_SD_MS_TIMEOUT_5000;

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        case APP_SD_CONTEXT_S517:
        case APP_SD_CONTEXT_S517_PASSIVE:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}



void _APP_SD_vInitFrameSC24(ATCallIndexEnum activePlccIdx, ATCallIndexEnum outgoingPlccIdx)
{
    // TODO: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // if there is an active call and user initiates a second outgoing call via
    // HU or phone buttons and when this call has been established successfully,
    // show SC24, if HFP version is not 1.5 or higher

    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_SC24;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_3;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 5;
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    ctxCtrl.sc24.activePlccIdx      = activePlccIdx;
    ctxCtrl.sc24.outgoingPlccIdx    = outgoingPlccIdx;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}


void _APP_SD_vInitFrameSA01()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    // event Screen always activated
    //_APP_SD_vActivateFrame(BT_TRUE, __LINE__);

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_SA01;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.bActivation  = BT_TRUE;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;

    /* set frame timeout */
    ctxCtrl.common.timeout = APP_SD_MS_TIMEOUT_2000;

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        case APP_SD_CONTEXT_SA02:
        case APP_SD_CONTEXT_SA03:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}

void _APP_SD_vInitFrameSA02()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    // event Screen always activated
    //_APP_SD_vActivateFrame(BT_TRUE, __LINE__);

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_SA02;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.bActivation  = BT_TRUE;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;

    /* set frame timeout */
    ctxCtrl.common.timeout = APP_SD_MS_TIMEOUT_2000;

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        case APP_SD_CONTEXT_SA01:
        case APP_SD_CONTEXT_SA03:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }

}

void _APP_SD_vInitFrameSA03()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    // event Screen always activated
    //_APP_SD_vActivateFrame(BT_TRUE, __LINE__);

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_SA03;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;
    ctxCtrl.common.bActivation  = BT_TRUE;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;

    /* set frame timeout */
    ctxCtrl.common.timeout = APP_SD_MS_TIMEOUT_2000;

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        case APP_SD_CONTEXT_SA01:
        case APP_SD_CONTEXT_SA02:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_REPLACE);
            break;
        default:
            _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
            break;
    }
}


void _APP_SD_vInitFrameSB34()
{
    AppSdCtxCtrlType ctxCtrl;
    (void)memset(&ctxCtrl, 0, sizeof(ctxCtrl));

    ctxCtrl.common.ctxId        = APP_SD_CONTEXT_SB34;
    ctxCtrl.common.pendingType  = APP_SD_PENDING_INIT;

    ctxCtrl.common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;

    /* set frame date information */
    ctxCtrl.common.listData.frameId         = KPB_FRAME_ID_5;
    ctxCtrl.common.listData.listElemOnTop   = 1;    // first list elem
    ctxCtrl.common.listData.focusedListElemOffset = 0;    // first list elem
    ctxCtrl.common.listData.numListElems    = 1;
    ctxCtrl.common.listData.listOperation   = KPB_NO_LIST_OPERATION;

    _APP_SD_vInitFrame(&ctxCtrl, APP_SD_HISTORY_APPEND);
}


//*********************************************/
// Pending Button handling
//*********************************************/
/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_sfHandlePendingButtonS104                             */
/**
  \brief        This function handles further steps for button press events in
                context S104

  \param        pCtxCtrl
                The current context control structure

  \return       SuccessFailType
                SUCCESS or FAIL

 */
/*----------------------------------------------------------------------------*/
SuccessFailType _APP_SD_sfHandlePendingButtonS104(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s104.subStateBtn)
    {
        case APP_SD_S104_PB_SEARCH_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONEBOOK_rcRequestPbSearch( _APP_SD_vButtonPendingS104_Cb,
                                                                             pCtxCtrl->s104.searchString,
                                                                             pCtxCtrl->s104.searchStringSize);

            /* check return code */
            switch(rspCode)
            {
                case APP_COMMON_RSP_OK:
                    /* everything looks good, go on */
                    pCtxCtrl->s104.subStateBtn = APP_SD_S104_PB_SEARCH_SENT;
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* wait a few time and try again */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(10),
                                                        0);
                    return SUCCESS;
                default:

                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS104: Request failed (%d)",
                                  rspCode);
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
                    return FAIL;
            }
            break;
        }
        case APP_SD_S104_PB_REQUEST_ENTRIES_NOT_SEND:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONEBOOK_rcRequestCompletePbEntries(
                                             _APP_SD_vButtonPendingS104_Cb2,
                                             APP_PHONEBOOK_enUsersPB,
                                             pCtxCtrl->s104.selectedIndex,
                                             1);

            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HaPenBtnS104: entries not send");

            switch(rspCode)
            {
                case APP_COMMON_RSP_ERROR_BUSY:
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                              MSEC(10), 0);
                    break;
                case APP_COMMON_RSP_OK:
                    DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HaPenBtnS104: response ok wait for callback");
                    pCtxCtrl->s104.subStateBtn = APP_SD_S104_PB_SEARCH_SENT;
                    // wait for callback being called
                    break;
                default:

                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HdlPendButtonS104 err %d", rspCode);

            }

            break;
        }
        case APP_SD_S104_PB_SEARCH_SENT:
            DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS104: wait for cb");
            break;
        default:

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS104: invalid state %d",
                          pCtxCtrl->s104.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
    }

    return SUCCESS;
}



SuccessFailType _APP_SD_sfHandlePendingButtonS306(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s306.subStateBtn)
    {
        case APP_SD_S306_SAVE_MAILBOX_NUMBER_NOT_SENT:
        {
            const ERMUserProfileType * userProfile = ERM_pGetActiveUserProfile();
            if( NULL != userProfile )
            {
                APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_OK;

                /* get spelled mailbox number */
                APP_SD_SC_vReadSpelledText( &(pCtxCtrl->s306.spellerCtrl),
                                            &(pCtxCtrl->common.pFrameData->s306.spelledText));
                /* try to save new mailbox number */
                rspCode = APP_DEVICE_rcSetVoiceMailboxNumber(_APP_SD_vButtonPendingS306_Cb,
                                                    ERM_u8GetUserProfileIndexForDeviceId(userProfile->deviceIndex),
                                                    pCtxCtrl->common.pFrameData->s306.spelledText.data,
                                                    pCtxCtrl->common.pFrameData->s306.spelledText.length);

                /* check return code */
                switch(rspCode)
                {
                    case APP_COMMON_RSP_OK:
                        /* do nothing wait for response */
                        gAppSdContext.setMailboxCounter = 0;
                        break;
                    case APP_COMMON_RSP_ERROR_BUSY:
                        /* wait a few time and try again */

                        gAppSdContext.setMailboxCounter += 1;
                        if (gAppSdContext.setMailboxCounter >=10)
                        {
                            APP_DEVICE_vEmergencyReleaseContextFromAppSd();
                            gAppSdContext.setMailboxCounter = 0;
                        }

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(100),
                                                            0);
                        return SUCCESS;
                    default:
                        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS306: Request failed (%d)",
                                        rspCode);
                        (void) _APP_SD_vReleasePendingContext(__LINE__);
                        return FAIL;
                }
            }
            else
            {   /* no user profile */
                _APP_SD_vCtxHistoryStepBack();
            }
            break;
        }
        case APP_SD_S306_DIAL_MAILBOX_NUMBER_NOT_SENT:
        {
            /* dial new mailbox number */
            APP_SD_SC_vReadSpelledText( &(pCtxCtrl->s306.spellerCtrl),
                                        &(pCtxCtrl->common.pFrameData->s306.spelledText));

            _APP_SD_vInitFrameS801_PN( pCtxCtrl->common.pFrameData->s306.spelledText.data,
                                       pCtxCtrl->common.pFrameData->s306.spelledText.length,
                                       BT_TRUE);
            break;
        }
        default:

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS306: invalid state %d",
                          pCtxCtrl->s306.subStateBtn);
           (void) _APP_SD_vReleasePendingContext(__LINE__);
           return FAIL;
    }

    return SUCCESS;
}




SuccessFailType _APP_SD_sfHandlePendingButtonS413(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s413.subStateBtn)
    {
        case APP_SD_S413_DELETE_SMS_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode =
                        APP_SMS_rcDeleteSms(_APP_SD_vButtonPendingS413_Cb, pCtxCtrl->s413.smsIndex, 1, APP_SMS_enRspSd);

                /* check return code */
                switch(rspCode)
                {
                    case APP_COMMON_RSP_OK:
                        pCtxCtrl->s413.subStateBtn = APP_SD_S413_DELETE_SMS_SENT;
                        _APP_SD_vInitFrameS408_USERLIST();
                        break;
                    case APP_COMMON_RSP_ERROR_BUSY:
                        /* wait a few time and try again */
                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(10),
                                                            0);
                        return SUCCESS;
                    default:
                        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS413: Request failed (%d)",
                                  rspCode);
                        pCtxCtrl->s413.subStateBtn = APP_SD_S413_DELETE_SMS_SENT;
                        (void) _APP_SD_vReleasePendingContext(__LINE__);
                        return FAIL;
                }
            break;
        }
        default:
        {
            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS413: invalid state %d",
                          pCtxCtrl->s413.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
        }
    }

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandlePendingButtonS512(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s512.subStateBtn)
    {
        case APP_SD_S512_DELETE_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode       = APP_COMMON_RSP_OK;
            Uint8Type currentProfileId              = AT_INVALID_DEVICE_ID;

            currentProfileId = pCtxCtrl->s512.deviceId;

            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "sfHandlePendingButtonS512: start state APP_SD_S512_DELETE_NOT_SENT");

            rspCode = ERM_rcDeleteDevice( _APP_SD_vButtonPendingS512_Cb, (Uint16Type)currentProfileId);

            /* check response code */
            switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                {
                    /* wait for response */
                    gAppSdContext.deleteDeviceCounter = 0;
                    pCtxCtrl->s512.subStateBtn = APP_SD_S512_DELETE_SENT;
                    break;
                }
                case APP_COMMON_RSP_ERROR_BUSY:
                {
                    /* try again later */

                    gAppSdContext.deleteDeviceCounter += 1;
                    if (gAppSdContext.deleteDeviceCounter >=10)
                    {
                        DEBUG_VALUE1( APP_SD_SWI_WNG, MOD_APP_SD, "HaPenBtnS512: Request busy (%d). EmergencyRelease for APP_DEVICE",
                                  rspCode);
                        APP_DEVICE_vEmergencyReleaseContextFromAppSd();
                        gAppSdContext.deleteDeviceCounter = 0;
                    }

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(100), 0);
                    break;
                }
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS512: Request failed (%d)",
                                  rspCode);
                    pCtxCtrl->s512.subStateBtn = APP_SD_S512_DELETE_SENT;
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    return FAIL;
            }
            break;
       }
        case APP_SD_S512_DELETE_SENT:
        default:
            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS512: invalid state %d",
                          pCtxCtrl->s512.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
    }
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandlePendingButtonS513(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s513.subStateBtn)
    {
        case APP_SD_S513_DELETE_NOT_SENT:
        {
            // delete user
            Uint8Type profileId = ERM_u8GetUserProfileId(pCtxCtrl->s513.deviceId);

            if(profileId != AT_INVALID_DEVICE_ID)
            {

                APP_COMMON_enResponseCode rspCode = APP_DEVICE_rcDeleteUserProfile(
                                                        NULL,
                                                        profileId);

                switch(rspCode)
                {
                    case APP_COMMON_RSP_ERROR_BUSY:
                    {
                        gAppSdContext.deleteDeviceCounter += 1;
                        if (gAppSdContext.deleteDeviceCounter >=10)
                        {
                            APP_DEVICE_vEmergencyReleaseContextFromAppSd();
                            gAppSdContext.deleteDeviceCounter = 0;
                        }

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FCT_PENDING,
                                                                 MSEC(100), 0);
                        return SUCCESS;
                    }
                    case APP_COMMON_RSP_OK:
                    {
                        gAppSdContext.deleteDeviceCounter = 0;
                        pCtxCtrl->s513.subStateBtn = APP_SD_S513_DELETE_SENT;
                        (void) _APP_SD_vReleasePendingContext(__LINE__);
                        gAppSdContext.deleteActionPressedinScreen = APP_SD_CONTEXT_S513;
                        _APP_SD_vInitFrameS408_DEL();
                        break;
                    }
                    default:
                    {
                        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS513: Request failed (%d)",
                                  rspCode);
                        pCtxCtrl->s513.deletePressed = BT_FALSE;
                        pCtxCtrl->s513.subStateBtn = APP_SD_S513_DELETE_SENT;
                        (void) _APP_SD_vReleasePendingContext(__LINE__);
                        return FAIL;
                    }
                }
            }
            else
            {
                pCtxCtrl->s513.deletePressed = BT_FALSE;
                pCtxCtrl->s513.subStateBtn = APP_SD_S513_DELETE_SENT;
                (void) _APP_SD_vReleasePendingContext(__LINE__);
                return FAIL;
            }
            break;
        }
        case APP_SD_S513_DELETE_SENT:
        default:

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS513: invalid state %d",
                          pCtxCtrl->s513.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
    }
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandlePendingButtonS51D(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s51D.subStateBtn)
    {
        case APP_SD_S51D_PAIRING_NOT_SENT:
        {
            /* initiate pairing */
            APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_OK;
            Uint16Type           numPinDigits = 0;
            ATPinCodeBT          pinData;

            APP_SD_SC_vReadSpelledText( &(pCtxCtrl->s51D.spellerCtrl),
                                        &(pCtxCtrl->common.pFrameData->s51D.spelledText));

            numPinDigits = pCtxCtrl->common.pFrameData->s51D.spelledText.length;
            numPinDigits = (AT_MAX_PIN_CODE_LEN < numPinDigits) ? AT_MAX_PIN_CODE_LEN : numPinDigits;
            (void)memset(pinData, 0x00, sizeof(pinData));
            (void)memcpy(pinData, pCtxCtrl->common.pFrameData->s51D.spelledText.data, numPinDigits);

            rspCode = ERM_rcInitiatePairing( pCtxCtrl->s51D.deviceId,
                                             AT_INQUIRY_DEVICE,
                                             pinData,
                                             numPinDigits,
                                             _APP_SD_vButtonPendingS51D_Cb);

            switch(rspCode)
            {
                case APP_COMMON_RSP_ERROR_BUSY:
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FCT_PENDING,
                                                             MSEC(10), 0);
                    break;
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s51D.subStateBtn = APP_SD_S51D_PAIRING_SENT;
                    _APP_SD_vInitFrameS408(pCtxCtrl->s51D.deviceId, pCtxCtrl->s51D.deviceType);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS51D: Request failed (%d)",
                                  rspCode);
                    /* we cannot initiate pairing */
                    _APP_SD_vInitFrameS521();
                    break;
            }
            break;
        }
        default:
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS51D: invalid state %d",
                          pCtxCtrl->s51D.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
        }
    }
    return SUCCESS;
}


SuccessFailType _APP_SD_sfHandlePendingButtonS51D_ACCEPT(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s51D.subStateBtn)
    {
        case APP_SD_S51D_PAIRING_NOT_SENT:
        {
            /* initiate pairing */
            APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_OK;
            Uint16Type           numPinDigits = 0;
            ATPinCodeBT          pinData;

            APP_SD_SC_vReadSpelledText( &(pCtxCtrl->s51D.spellerCtrl),
                                        &(pCtxCtrl->common.pFrameData->s51D.spelledText));

            numPinDigits = pCtxCtrl->common.pFrameData->s51D.spelledText.length;
            numPinDigits = (AT_MAX_PIN_CODE_LEN < numPinDigits) ? AT_MAX_PIN_CODE_LEN : numPinDigits;
            (void)memset(pinData, 0x00, sizeof(pinData));
            (void)memcpy(pinData, pCtxCtrl->common.pFrameData->s51D.spelledText.data, numPinDigits);

            rspCode = ERM_rcAcceptPairing( pCtxCtrl->s51D.deviceId,
                                           pCtxCtrl->s51D.remoteDeviceType,
                                           pinData,
                                           numPinDigits,
                                           _APP_SD_vButtonPendingS51D_Cb);

            switch(rspCode)
            {
                case APP_COMMON_RSP_ERROR_BUSY:
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FCT_PENDING,
                                                             MSEC(10), 0);
                    break;
                case APP_COMMON_RSP_OK:
                    _APP_SD_vInitFrameS517_PASSIVE();
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS51D_ACCEPT: Request failed (%d)",
                            rspCode);
                    /* we cannot initiate pairing */
                    if (BT_FALSE == _APP_SD_bPhoneContextActive())
                    {
                        _APP_SD_vReleasePhoneContext();
                    }
                    else
                    {
                        _APP_SD_vInitFrameS521();
                    }
                    break;
            }
            break;
        }
        case APP_SD_S51D_REJECT_NOT_SENT:
        {
            const ERMPairReqType *pPairRequest = ERM_pGetPairRequest();

            APP_COMMON_enResponseCode rspCode = ERM_rcRejectPairing( pPairRequest->remote_id, pPairRequest->device_type, NULL);

            switch( rspCode )
            {
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD,"_APP_SD_sfHandlePendingButtonS51D_ACCEPT: RejectPairing busy");
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                case APP_COMMON_RSP_OK:
                    /* final state reached */
                    DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD,"_APP_SD_sfHandlePendingButtonS51D_ACCEPT: Reject Pairing sent");
                    if (BT_FALSE == _APP_SD_bPhoneContextActive())
                    {
                        _APP_SD_vReleasePhoneContext();
                    }
                    else
                    {
                        _APP_SD_vInitFrameS521();
                    }
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "_APP_SD_sfHandlePendingButtonS51D_ACCEPT: RejectPairing failed (%d)",
                                  rspCode);

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                   break;
            }
            break;
        }
        default:
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS51D_ACCEPT: invalid state %d",
                          pCtxCtrl->s51D.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
        }
    }
    return SUCCESS;
}


SuccessFailType _APP_SD_sfHandlePendingButtonS520(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s520.subStateBtn)
    {
        case APP_SD_S520_CANCEL_INQUIRY_NOT_SENT:
        {
            // cancel inquiry
            APP_COMMON_enResponseCode rspCode =
                        ERM_rcCancelInquiry(_APP_SD_vButtonPendingS520_Cb);

            switch(rspCode)
            {
                case APP_COMMON_RSP_ERROR_BUSY:
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FCT_PENDING,
                                                             MSEC(10), 0);
                    break;
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s520.subStateBtn = APP_SD_S520_CANCEL_INQUIRY_SENT;
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS520: Request failed (%d)",
                                  rspCode);
                    pCtxCtrl->s520.subStateBtn = APP_SD_S520_CANCEL_INQUIRY_SENT;
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
                    return FAIL;
            }
            break;
        }
        default:
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS520: invalid state %d",
                            pCtxCtrl->s520.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
        }
    }
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandlePendingButtonS52C(AppSdCtxCtrlType *pCtxCtrl)
{
    if (APP_SD_S52C_SSP_CONFIRMED == pCtxCtrl->s52C.subStateBtn)
    {
        APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_OK;
        ATPinCodeBT  pinData;

        /* notify ERM to confirm the pairing request and get PairedID from ERM */
        /* accept pairing */

        DEBUG_VALUE2(APP_SD_SWI_TRC,MOD_APP_SD,"_APP_SD_sfHandlePendingButtonS52C accept for id = %d, device = %d",pCtxCtrl->s52C.deviceId,pCtxCtrl->s52C.pairingDeviceType);
        rspCode = ERM_rcAcceptPairing( pCtxCtrl->s52C.deviceId,
                                       pCtxCtrl->s52C.pairingDeviceType,
                                       pinData,
                                       0,
                                       _APP_SD_vButtonPendingS52C_Cb);

        switch(rspCode)
        {
            case APP_COMMON_RSP_ERROR_BUSY:
            {
                (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FCT_PENDING,
                                                         MSEC(100), 0);
                break;
            }
            case APP_COMMON_RSP_OK:
            {
                DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "S52C:Time out Set in APP_COMMON_RSP_OK");
                pCtxCtrl->common.timeout  = APP_SD_MS_TIMEOUT_500;
                (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FRAME_TIMEOUT,
                        MSEC(pCtxCtrl->common.timeout),
                        0);
                (void) _APP_SD_vReleasePendingContext(__LINE__);
                break;
            }
            default:
            {
                DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS52C: Request failed (%d)",
                              rspCode);
                /* we cannot initiate pairing */
                _APP_SD_vInitFrameS521();
                break;
            }
        }
    }
    else if (APP_SD_S52C_SSP_NOT_CONFIRMED == pCtxCtrl->s52C.subStateBtn)
    {
        APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_OK;

        rspCode = ERM_rcRejectPairing(pCtxCtrl->s52C.deviceId,
                                       pCtxCtrl->s52C.pairingDeviceType,
                                       NULL);

        switch(rspCode)
        {
            case APP_COMMON_RSP_ERROR_BUSY:
            {
                (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FCT_PENDING,
                                                         MSEC(100), 0);
                break;
            }
            case APP_COMMON_RSP_OK:
            {
                DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HaPenBtnS52C: Reject Pairing succeded (%d)");
                // not sure if this is necessary (void) _APP_SD_vReleasePendingContext(__LINE__);
                if (BT_FALSE == _APP_SD_bPhoneContextActive())
                {
                    _APP_SD_vReleasePhoneContext();
                }
                else
                {
                    _APP_SD_vCtxHistoryStepBack();
                }
                break;
            }
            default:
            {
                DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS52C: Reject Pairing failed (%d)",
                              rspCode);
                /* we cannot reject pairing */
                if (BT_FALSE == _APP_SD_bPhoneContextActive())
                {
                    _APP_SD_vReleasePhoneContext();
                }
                else
                {
                    _APP_SD_vInitFrameS521();
                }
                break;
            }
        }
    }
    else
    {
        _APP_SD_vInitFrameS518();
        return FAIL;
    }
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandlePendingButtonS556(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s556.subStateBtn)
    {
        case APP_SD_S556_DEVICE_NAME_NOT_SENT:
        {
            AppSdSpelledTextType spelledText;
            APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_OK;

            APP_SD_SC_vReadSpelledText( &(pCtxCtrl->s556.spellerCtrl),
                                        &spelledText);

            rspCode = APP_DEVICE_rcSaveBtName( _APP_SD_vButtonPendingS556_Cb,
                                               spelledText.data,
                                               spelledText.length );

            switch(rspCode)
            {
                case APP_COMMON_RSP_ERROR_BUSY:
                {
                    gAppSdContext.saveBtNameCounter += 1;
                    if (gAppSdContext.saveBtNameCounter >=10)
                    {
                        APP_DEVICE_vEmergencyReleaseContextFromAppSd();
                        gAppSdContext.saveBtNameCounter = 0;
                    }

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FCT_PENDING,
                                                             MSEC(100), 0);
                    break;
                }
                case APP_COMMON_RSP_OK:
                {
                    gAppSdContext.saveBtNameCounter = 0;
                    pCtxCtrl->s556.subStateBtn = APP_SD_S556_DEVICE_NAME_SENT;
                    break;
                }
                default:
                {
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS556: Request failed (%d)",
                                  rspCode);
                    pCtxCtrl->s556.subStateBtn = APP_SD_S556_DEVICE_NAME_SENT;
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
                    return FAIL;
                }
            }
            break;
        }
        default:
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS556: invalid state %d",
                            pCtxCtrl->s556.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
        }
    }

    return SUCCESS;
}


SuccessFailType _APP_SD_sfHandlePendingButtonS542(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s542.subStateBtn)
    {
        case APP_SD_S542_DISCONNECT_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_DEVICE_sfDeactivatePhoneService(
                                                    pCtxCtrl->s542.deviceId,
                                                    _APP_SD_HandlePendingButtonS542_Cb);

            switch(rspCode)
            {
                case APP_COMMON_RSP_ERROR_BUSY:
                    DEBUG_VALUE1( APP_SD_SWI_WNG, MOD_APP_SD, "HaPenBtnS542: Request busy (%d). EmergencyRelease for APP_DEVICE",
                                  rspCode);
                    gAppSdContext.disconnectPhoneCounter += 1;
                    if (gAppSdContext.disconnectPhoneCounter >=10)
                    {
                        APP_DEVICE_vEmergencyReleaseContextFromAppSd();
                        gAppSdContext.disconnectPhoneCounter = 0;
                    }
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FCT_PENDING,
                                                             MSEC(100), 0);
                    break;
                case APP_COMMON_RSP_OK:
                    gAppSdContext.disconnectRequestedByUser = 1;
                    if (ERM_u8GetActivePlayer() == ERM_u8GetActivePhone())
                    {
                        pCtxCtrl->s542.subStateBtn = APP_SD_S542_DISCONNECT_SENT;
                    }
                    else
                    {
                        pCtxCtrl->s542.subStateBtn = APP_SD_S542_DISCONNECT_PLAYER_STILL_TO_BE_SEND;
                    }
                    gAppSdContext.disconnectPhoneCounter = 0;
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS542: Request failed (%d)",
                                  rspCode);
                    gAppSdContext.disconnectPhoneCounter = 0;
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
                    return FAIL;
            }
            break;
        }
        case APP_SD_S542_DISCONNECT_PLAYER_STILL_TO_BE_SEND:
        {
            if (ERM_u8GetActivePlayer() != AT_INVALID_DEVICE_ID)
            {
                APP_COMMON_enResponseCode rspCode = APP_DEVICE_rcDeactivateMdiDevice(_APP_SD_HandlePendingButtonS542_Cb);

                switch(rspCode)
                {
                    case APP_COMMON_RSP_ERROR_BUSY:

                        gAppSdContext.disconnectPlayerCounter += 1;
                        if (gAppSdContext.disconnectPlayerCounter >=10)
                        {
                            APP_DEVICE_vEmergencyReleaseContextFromAppSd();
                            gAppSdContext.disconnectPlayerCounter = 0;
                        }


                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FCT_PENDING,
                                                                 MSEC(100), 0);
                        break;
                    case APP_COMMON_RSP_OK:
                        pCtxCtrl->s542.subStateBtn = APP_SD_S542_DISCONNECT_PLAYER_SENT;
                        gAppSdContext.disconnectPlayerCounter = 0;
                        gAppSdContext.disconnectRequestedByUser += 1;

                        (void) _APP_SD_vReleasePendingContext(__LINE__);

                        break;
                    default:
                        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS542: Request failed (%d)",
                                      rspCode);
                        (void) _APP_SD_vReleasePendingContext(__LINE__);
                        gAppSdContext.disconnectPlayerCounter = 0;
                        return FAIL;
                }

            }
            else
            {
                (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FCT_PENDING,
                                                             MSEC(100), 0);
            }
            break;
        }
        case APP_SD_S542_DISCONNECT_SENT:
            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "sfHandlePendingButtonS542: disconnect finished");
            break;
        default:

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS542: invalid state %d",
                            pCtxCtrl->s542.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
    }
    return SUCCESS;
}


SuccessFailType _APP_SD_sfHandlePendingButtonS563(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s563.subStateBtn)
    {
        case APP_SD_S563_DISCONNECT_NOT_SENT:
        {
            // disconnect service depending on deviceType
            APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_ERROR;
            switch( pCtxCtrl->s563.deviceType )
            {
                case APP_DEVICE_enTYPE_HEADSET:
                    rspCode = APP_DEVICE_sfDeactivatePhoneService(pCtxCtrl->s563.deviceId,
                                                       _APP_SD_vButtonPendingS563_Cb);
                    break;
                case APP_DEVICE_enTYPE_PLAYER:
                    /* stop avrcp and a2dp sink services */
                    gAppSdContext.disconnectRequestedByUser = 1;
                    rspCode = APP_DEVICE_rcDeactivateMdiDevice(_APP_SD_vButtonPendingS563_Cb);
                    break;
                default:
                    return FAIL;
            }

            switch(rspCode)
            {
                case APP_COMMON_RSP_ERROR_BUSY:

                    gAppSdContext.disconnectPlayerCounter += 1;
                    if (gAppSdContext.disconnectPlayerCounter >=10)
                    {
                        APP_DEVICE_vEmergencyReleaseContextFromAppSd();
                        gAppSdContext.disconnectPlayerCounter = 0;
                    }

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FCT_PENDING,
                                                             MSEC(100), 0);

                    break;
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s563.subStateBtn = APP_SD_S563_DISCONNECT_SENT;
                    gAppSdContext.disconnectPlayerCounter = 0;
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS563: Request failed (%d)",
                                  rspCode);
                    pCtxCtrl->s563.subStateBtn = APP_SD_S563_DISCONNECT_SENT;
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
                    return FAIL;
            }
            break;
        }
        case APP_SD_S563_DISCONNECT_SENT:
        default:

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS563: invalid state %d",
                            pCtxCtrl->s563.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
    }
    return SUCCESS;
}


SuccessFailType _APP_SD_sfHandlePendingButtonS572(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s572.subStateBtn)
    {
        case APP_SD_S572_DISCONNECT_NOT_SENT:
        {
            // disconnect service depending on deviceType
            // of active device
            APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_ERROR;
            switch( pCtxCtrl->s572.deviceType )
            {
                case APP_DEVICE_enTYPE_HEADSET:
                    rspCode = APP_DEVICE_sfDeactivatePhoneService(ERM_u8GetActiveHeadSet(),
                                                       _APP_SD_vButtonPendingS572_Cb);
                    break;
                case APP_DEVICE_enTYPE_PLAYER:
                    /* stop avrcp and a2dp sink services of active device */
                    rspCode = APP_DEVICE_rcDeactivateMdiDevice(_APP_SD_vButtonPendingS572_Cb);
                    break;
                default:
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
                    return FAIL;
            }

            switch(rspCode)
            {
                case APP_COMMON_RSP_ERROR_BUSY:
                {

                    if (gAppSdContext.disconnectPlayerCounter >= 10)
                    {
                        gAppSdContext.disconnectPlayerCounter = 0;
                        APP_DEVICE_vEmergencyReleaseContextFromAppSd();

                        //(void) _APP_SD_vReleasePendingContext(__LINE__);
                        DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "sfHandlePendingButtonS572: response for deactivate mdi busy more than 10 times: emergency release context app_device;");

                    }
                    else
                    {
                        gAppSdContext.disconnectPlayerCounter += 1;
                    }

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(100),
                                                            0);

                }
                    break;
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s572.subStateBtn = APP_SD_S572_DISCONNECT_SENT;
                    gAppSdContext.disconnectPlayerCounter = 0;
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS572: Request failed (%d)",
                                  rspCode);
                    pCtxCtrl->s572.subStateBtn = APP_SD_S572_DISCONNECT_SENT;
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
                    return FAIL;
            }
            break;
        }

        case APP_SD_S572_DISCONNECT_SUCCESSFUL:
        {
            _APP_SD_vInitFrameS408_SSP(pCtxCtrl->s572.deviceId,pCtxCtrl->s572.deviceType);
        break;
        }
        default:
        {
            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS572: invalid state %d",
                            pCtxCtrl->s572.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
        }
    }
    return SUCCESS;
}




//***************************************
// Audio Mode
//***************************************
SuccessFailType _APP_SD_sfHandlePendingButtonS602(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s602.subStateBtn)
    {
        case APP_SD_S602_SET_AUDIO_MODE_NOT_SENT:
        {
            // get active device
            const ERMUserProfileType * profile = ERM_pGetActiveUserProfile();
            if( NULL != profile )
            {
                Uint8Type profileIndex = ERM_u8GetUserProfileIndexForDeviceId(profile->deviceIndex);
                APP_COMMON_enResponseCode rspCode = ERM_rcSetAudioMode_InEeprom(NULL,
                                                            profileIndex,
                                                            pCtxCtrl->s602.audioMode);

                switch(rspCode)
                {
                    case APP_COMMON_RSP_ERROR_BUSY:
                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FCT_PENDING,
                                                                 MSEC(10), 0);
                        break;
                    case APP_COMMON_RSP_OK:
                        pCtxCtrl->s602.subStateBtn = APP_SD_S602_SET_AUDIO_MODE_SENT;
                        _APP_SD_vCtxHistoryStepBack();
                        break;
                    default:
                        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS602: Request failed (%d)",
                                  rspCode);
                        pCtxCtrl->s602.subStateBtn = APP_SD_S602_SET_AUDIO_MODE_SENT;
                        (void) _APP_SD_vReleasePendingContext(__LINE__);
                        return FAIL;
                }
            }
            else
            {
                DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS602: No active device");
                pCtxCtrl->s602.subStateBtn = APP_SD_S602_SET_AUDIO_MODE_SENT;

                (void) _APP_SD_vReleasePendingContext(__LINE__);
                 return FAIL;
            }
            break;
        }
        default:
        {
            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS602: invalid state %d",
                            pCtxCtrl->s602.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
        }
    }

    return SUCCESS;
}




SuccessFailType _APP_SD_sfHandlePendingButtonS555(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s555.subStateBtn)
    {
        case APP_SD_S555_DELETE_NOT_SENT:
        {
            // delete user
            Uint8Type profileId = ERM_u8GetUserProfileId(pCtxCtrl->s555.deviceId);

            if(profileId != AT_INVALID_DEVICE_ID)
            {

                APP_COMMON_enResponseCode rspCode = APP_DEVICE_rcDeleteUserProfile(
                                                        NULL,
                                                        profileId);

                switch(rspCode)
                {
                    case APP_COMMON_RSP_ERROR_BUSY:
                    {
                        gAppSdContext.deleteDeviceCounter += 1;
                        if (gAppSdContext.deleteDeviceCounter >=10)
                        {
                            APP_DEVICE_vEmergencyReleaseContextFromAppSd();
                            gAppSdContext.deleteDeviceCounter = 0;
                        }
                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FCT_PENDING,
                                                                 MSEC(100), 0);
                        break;
                    }
                    case APP_COMMON_RSP_OK:
                    {
                        gAppSdContext.deleteDeviceCounter = 0;
                        pCtxCtrl->s555.subStateBtn = APP_SD_S555_DELETE_SENT;
                        (void) _APP_SD_vReleasePendingContext(__LINE__);
                        gAppSdContext.deleteActionPressedinScreen = APP_SD_CONTEXT_S555;
                        _APP_SD_vInitFrameS408_DEL();
                        break;
                    }
                    default:
                        // request was not accepted due to parameter errors
                        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS555: Request failed (%d)",
                                  rspCode);
                        // reset deletedPressed flag so we will not hang
                        pCtxCtrl->s555.deletePressed = BT_FALSE;
                        pCtxCtrl->s555.subStateBtn = APP_SD_S555_DELETE_SENT;
                        (void) _APP_SD_vReleasePendingContext(__LINE__);
                        return FAIL;
                }
            }
            else
            {
                DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS555: profile ID = invalid");
                // reset deletedPressed flag so we will not hang
                pCtxCtrl->s555.deletePressed = BT_FALSE;
                pCtxCtrl->s555.subStateBtn   = APP_SD_S555_DELETE_SENT;
                (void) _APP_SD_vReleasePendingContext(__LINE__);
                return FAIL;
            }
            break;
        }
        case APP_SD_S555_DELETE_SENT:
        default:

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS555: invalid state %d",
                            pCtxCtrl->s555.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
    }
    return SUCCESS;
}


//SuccessFailType _APP_SD_sfHandlePendingButtonS535(AppSdCtxCtrlType *pCtxCtrl)
//{
//    switch(pCtxCtrl->s535.subStateBtn)
//    {
//        case APP_SD_S535_ADD_NEW_PROFILE_NOT_SENT:
//        {   /* finally add the new profile depending on device type */
//            APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_OK;
//            AppSdSpelledTextType spelledText;
//            APP_SD_SC_vReadSpelledText( &(pCtxCtrl->s536.spellerCtrl),  //to change s536 to s535 here
//                                        &spelledText);
//
//            rspCode = APP_DEVICE_rcAddUserProfile(_APP_SD_AddUserProfile_Cb, pCtxCtrl->s535.deviceId, spelledText.data, spelledText.length);
//
//            switch( rspCode )
//            {
//                case APP_COMMON_RSP_OK:
//                {
//                    /* wait for response */
//
//                    // Show S534 until we get feedback from EEPROM, that
//                    // user profile was successfully saved!!!!!!!
//                    gAppSdContext.addProfileCounter = 0;
//                    _APP_SD_vInitFrameS534(pCtxCtrl->s535.deviceId);
//                    break;
//                }
//                case APP_COMMON_RSP_ERROR_BUSY:
//                {
//                    /* try again later */
//
//                    gAppSdContext.addProfileCounter += 1;
//                    if (gAppSdContext.addProfileCounter >=10)
//                    {
//                        APP_DEVICE_vEmergencyReleaseContextFromAppSd();
//                        gAppSdContext.addProfileCounter = 0;
//                    }
//                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(100), 0);
//
//                    break;
//                }
//                default:
//                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS535: Request failed (%d), ADD_NEW_PROFILE",
//                                  rspCode);
//                    (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
//            }
//            break;
//        }
//        case APP_SD_S535_DELETE_NOT_SENT:
//        {
//            APP_COMMON_enResponseCode rspCode       = APP_COMMON_RSP_OK;
//            Uint8Type currentProfileId              = AT_INVALID_DEVICE_ID;
//
//            currentProfileId = pCtxCtrl->s535.deviceId;
//
//            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "sfHandlePendingButtonS535: start state APP_SD_S535_DELETE_NOT_SENT");
//
//            rspCode = ERM_rcDeleteDevice( _APP_SD_vButtonPendingS535_Cb, (Uint16Type)currentProfileId);
//
//            /* check response code */
//            switch( rspCode )
//            {
//                case APP_COMMON_RSP_OK:
//                    /* wait for response */
//                    pCtxCtrl->s535.subStateBtn = APP_SD_S535_DELETE_SENT;
//                    break;
//                case APP_COMMON_RSP_ERROR_BUSY:
//                    /* try again later */
//                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
//                    break;
//                default:
//                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS535: Request failed (%d), DELETE",
//                                  rspCode);
//                    pCtxCtrl->s535.subStateBtn = APP_SD_S535_DELETE_SENT;
//                   (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
//            }
//            break;
//       }
//        case APP_SD_S535_DELETE_DEVICE_NOT_SENT:
//        {
//            APP_COMMON_enResponseCode rspCode = ERM_rcDeleteDevice( NULL, pCtxCtrl->s535.deviceId );
//
//            switch( rspCode )
//            {
//                case APP_COMMON_RSP_OK:
//                    _APP_SD_vInitFrameS539();
//                    break;
//                case APP_COMMON_RSP_ERROR_BUSY:
//                    /* try again later */
//                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
//                    break;
//                default:
//
//                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPendingBtnS535: ERM_rcDeleteDevice error %d",
//                                    rspCode);
//                    _APP_SD_vInitFrameS539();
//                    break;
//            }
//            break;
//        }
//        case APP_SD_S535_DELETE_SENT:
//        default:
//
//            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPendingBtnS535: invalid state %d",
//                            pCtxCtrl->s535.subStateBtn);
//            (void) _APP_SD_vReleasePendingContext(__LINE__);
//            return FAIL;
//    }
//    return SUCCESS;
//}



SuccessFailType _APP_SD_sfHandlePendingButtonS536(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s536.subStateBtn)
    {
        case APP_SD_S536_CHANGE_PROFILE_NOT_SEND:
        {   /* finally add the new profile depending on device type */
            AppSdSpelledTextType spelledText;
            APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_OK;
            Uint8Type profileIdx = ERM_u8GetUserProfileIndexForDeviceId(pCtxCtrl->s536.deviceId);

            APP_SD_SC_vReadSpelledText( &(pCtxCtrl->s536.spellerCtrl),
                                        &spelledText);

            if( AT_INVALID_DEVICE_ID == profileIdx )
            {

                DEBUG_VALUE2( APP_SD_SWI_ERR, MOD_APP_SD, "HaPendBtnS536: inv. profIdx. %d for devId %d",
                              profileIdx, pCtxCtrl->s536.deviceId);
               (void) _APP_SD_vReleasePendingContext(__LINE__);
                return FAIL;
            }
            rspCode = APP_DEVICE_rcSetUserName(_APP_SD_vButtonPendingS536_Cb,
                                   profileIdx,
                                   spelledText.data,
                                   spelledText.length );

            switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    /* wait for response */
                    gAppSdContext.renameCounter = 0;
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                {
                    /* try again later */
                    gAppSdContext.renameCounter += 1;
                    if (gAppSdContext.renameCounter >=10)
                    {
                        APP_DEVICE_vEmergencyReleaseContextFromAppSd();
                        gAppSdContext.renameCounter = 0;
                    }
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(100), 0);
                    break;
                }
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS536: Request failed (%d)",
                                  rspCode);
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    return FAIL;
            }
            break;
        }
        default:

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPendingBtnS536: invalid state %d",
                          pCtxCtrl->s536.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
    }
    return SUCCESS;
}




SuccessFailType _APP_SD_sfHandlePendingButtonS575(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s575.subStateBtn)
    {
        case APP_SD_S575_CHANGE_PROFILE_NOT_SEND:
        {   /* finally add the new profile depending on device type */
            AppSdSpelledTextType spelledText;
            APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_OK;
            Uint8Type profileIdx = ERM_u8GetPlayerHeadsetProfileIndexForDeviceId(pCtxCtrl->s575.deviceId);

            if( AT_INVALID_DEVICE_ID == profileIdx )
            {

                DEBUG_VALUE2( APP_SD_SWI_ERR, MOD_APP_SD, "HaPendBtnS575: inv. profIdx. %d for devId %d",
                              profileIdx, pCtxCtrl->s575.deviceId);
               (void) _APP_SD_vReleasePendingContext(__LINE__);
                return FAIL;
            }

            APP_SD_SC_vReadSpelledText( &(pCtxCtrl->s575.spellerCtrl),
                                        &spelledText);

            rspCode = APP_DEVICE_rcSetPlayerHsName(_APP_SD_vButtonPendingS575_Cb,
                                   profileIdx,
                                   spelledText.data,
                                   spelledText.length );

            switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    /* wait for response */
                    gAppSdContext.renameCounter = 0;
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    gAppSdContext.renameCounter += 1;
                        if (gAppSdContext.renameCounter >=10)
                        {
                            APP_DEVICE_vEmergencyReleaseContextFromAppSd();
                            gAppSdContext.renameCounter = 0;
                        }

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(100), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS575: Request failed (%d)",
                                  rspCode);
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    return FAIL;
            }
            break;
        }
        default:

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPendingBtnS575: invalid state %d",
                            pCtxCtrl->s575.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
    }
    return SUCCESS;
}




SuccessFailType _APP_SD_sfHandlePendingButtonS576(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s576.subStateBtn)
    {
        case APP_SD_S576_DELETE_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_OK;
            Uint8Type profileId = ERM_u8GetPlayerHeadsetProfileId(pCtxCtrl->s576.deviceId);
            // delete player / headset
            if(profileId != AT_INVALID_DEVICE_ID)
            {
                switch( pCtxCtrl->s576.deviceType )
                {
                    case APP_DEVICE_enTYPE_HEADSET:
                        rspCode = APP_DEVICE_rcDeleteHeadsetProfile( NULL, profileId);
                        break;
                    case APP_DEVICE_enTYPE_PLAYER:
                        rspCode = APP_DEVICE_rcDeletePlayerProfile( NULL, profileId);
                        break;
                    default:
                        rspCode = APP_COMMON_RSP_ERROR;
                        break;
                }

                switch( rspCode )
                {
                    case APP_COMMON_RSP_OK:
                    {
                        gAppSdContext.deleteDeviceCounter = 0;
                        pCtxCtrl->s576.subStateBtn = APP_SD_S576_DELETE_SENT;
                        (void) _APP_SD_vReleasePendingContext(__LINE__);
                        gAppSdContext.deleteActionPressedinScreen = APP_SD_CONTEXT_S576;
                        gAppSdContext.s408DelDeviceType = gAppSdContext.pCurCtxCtrl->s576.deviceType;
                        _APP_SD_vInitFrameS408_DEL();
                        break;
                    }
                    case APP_COMMON_RSP_ERROR_BUSY:
                    {
                        /* try again later */

                        gAppSdContext.deleteDeviceCounter += 1;
                        if (gAppSdContext.deleteDeviceCounter >=10)
                        {
                            APP_DEVICE_vEmergencyReleaseContextFromAppSd();
                            gAppSdContext.deleteDeviceCounter = 0;
                        }
                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(100), 0);
                        break;
                    }
                    default:
                        // request was not accepted due to parameter errors
                        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS576: Request failed (%d)",
                                  rspCode);
                        // reset deletedPressed flag so we will not hang
                        pCtxCtrl->s576.deletePressed = BT_FALSE;
                        pCtxCtrl->s576.subStateBtn = APP_SD_S576_DELETE_SENT;
                        (void) _APP_SD_vReleasePendingContext(__LINE__);
                        return FAIL;
                }
            }
            else
            {
                DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS576: invalid profileId %d",
                                profileId);
                // reset deletedPressed flag so we will not hang
                pCtxCtrl->s576.deletePressed = BT_FALSE;
                pCtxCtrl->s576.subStateBtn = APP_SD_S576_DELETE_SENT;
                (void) _APP_SD_vReleasePendingContext(__LINE__);
            }
            break;
        }
        case APP_SD_S576_DELETE_SENT:
        default:

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS576: invalid state %d",
                            pCtxCtrl->s576.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
    }
    return SUCCESS;
}


SuccessFailType _APP_SD_sfHandlePendingButtonS579(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s579.subStateBtn)
    {
        case APP_SD_S579_DELETE_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_OK;
            Uint8Type profileId = ERM_u8GetPlayerHeadsetProfileId(pCtxCtrl->s579.deviceId);
            // delete player / headset
            if(profileId != AT_INVALID_DEVICE_ID)
            {
                switch( pCtxCtrl->s579.deviceType )
                {
                    case APP_DEVICE_enTYPE_HEADSET:
                        rspCode = APP_DEVICE_rcDeleteHeadsetProfile( NULL, profileId);
                        break;
                    case APP_DEVICE_enTYPE_PLAYER:
                        rspCode = APP_DEVICE_rcDeletePlayerProfile( NULL, profileId);
                        break;
                    default:
                        rspCode = APP_COMMON_RSP_ERROR;
                        break;
                }

                switch( rspCode )
                {
                    case APP_COMMON_RSP_OK:
                    {
                        gAppSdContext.deleteDeviceCounter = 0;
                        pCtxCtrl->s576.subStateBtn = APP_SD_S576_DELETE_SENT;
                        (void) _APP_SD_vReleasePendingContext(__LINE__);
                        gAppSdContext.deleteActionPressedinScreen = APP_SD_CONTEXT_S579;
                        gAppSdContext.s408DelDeviceType = gAppSdContext.pCurCtxCtrl->s579.deviceType;
                        _APP_SD_vInitFrameS408_DEL();
                        break;
                    }
                    case APP_COMMON_RSP_ERROR_BUSY:
                    {
                    /* try again later */
                        gAppSdContext.deleteDeviceCounter += 1;
                        if (gAppSdContext.deleteDeviceCounter >=10)
                        {
                            APP_DEVICE_vEmergencyReleaseContextFromAppSd();
                            gAppSdContext.deleteDeviceCounter = 0;
                        }
                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(100), 0);
                        break;
                    }
                    default:
                        // request was not accepted due to parameter errors
                        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS579: Request failed (%d)",
                                  rspCode);
                        // reset deletedPressed flag so we will not hang
                        pCtxCtrl->s579.deletePressed = BT_FALSE;
                        pCtxCtrl->s579.subStateBtn = APP_SD_S579_DELETE_SENT;
                        (void) _APP_SD_vReleasePendingContext(__LINE__);
                        return FAIL;
                }
            }
            else
            {
                DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS579: invalid profileId %d",
                                profileId);
                // reset deletedPressed flag so we will not hang
                pCtxCtrl->s579.deletePressed = BT_FALSE;
                pCtxCtrl->s579.subStateBtn = APP_SD_S579_DELETE_SENT;
                (void) _APP_SD_vReleasePendingContext(__LINE__);
                return FAIL;
            }
            break;
        }
        case APP_SD_S579_DELETE_SENT:
        default:

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS579: invalid state %d",
                            pCtxCtrl->s579.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
    }
    return SUCCESS;
}


//SuccessFailType _APP_SD_sfHandlePendingButtonS580(AppSdCtxCtrlType *pCtxCtrl)
//{
//    switch(pCtxCtrl->s580.subStateBtn)
//    {
//        case APP_SD_S580_DELETE_CURRENT_PROFILE_NOT_SENT:
//        {
//            APP_COMMON_enResponseCode rspCode       = APP_COMMON_RSP_OK;
//            Uint8Type currentProfileId              = AT_INVALID_DEVICE_ID;
//
//            currentProfileId = pCtxCtrl->s580.deviceId;
//
//            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "sfHandlePendingButtonS580: start state APP_SD_S580_DELETE_CURRENT_PROFILE_NOT_SENT");
//
//            rspCode = ERM_rcDeleteDevice( _APP_SD_vButtonPendingS580_Cb, (Uint16Type)currentProfileId);
//
//            /* check response code */
//            switch( rspCode )
//            {
//                case APP_COMMON_RSP_OK:
//                    /* wait for response */
//                    break;
//                case APP_COMMON_RSP_ERROR_BUSY:
//                    /* try again later */
//                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
//                    break;
//                default:
//                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS580: Request failed (%d), APP_SD_S580_DELETE_CURRENT_PROFILE_NOT_SENT",
//                                  rspCode);
//                   (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
//            }
//            break;
//        }
//        case APP_SD_S580_DELETE_OLDEST_PLAYER_PROFILE_NOT_SENT:
//        {
//            APP_COMMON_enResponseCode rspCode       = APP_COMMON_RSP_OK;
//            Uint8Type oldestProfileId               = AT_INVALID_DEVICE_ID;
//            APP_DEVICE_DeviceType oldestProfileType = pCtxCtrl->s580.deviceType;
//            const ERMPlayerHeadsetProfileType * oldestProfile   = NULL;
//
//            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "sfHandlePendingButtonS580: start state APP_SD_S580_DELETE_OLDEST_PLAYER_PROFILE_NOT_SENT");
//
//            // check which player / headset profile to be deleted
//            switch( pCtxCtrl->s580.deviceType )
//            {   /* prio is to delete a profile of deviceType of current SD context */
//                case APP_DEVICE_enTYPE_HEADSET:
//                    /* first check if we can delete a headset */
//                    oldestProfileId = ERM_u8GetOldestHeadsetProfileId();
//                    if( AT_INVALID_DEVICE_ID == oldestProfileId )
//                    {
//                        /* there was no oldest headset profile, so check for oldest player profile to be deleted instead */
//                        oldestProfileId     = ERM_u8GetOldestPlayerProfileId();
//                        oldestProfileType   = APP_DEVICE_enTYPE_PLAYER;
//                    }
//                    break;
//                case APP_DEVICE_enTYPE_PLAYER:
//                    /* first check if we can delete a player */
//                    oldestProfileId = ERM_u8GetOldestNoActiveUserProfileId();
//                    if( AT_INVALID_DEVICE_ID == oldestProfileId )
//                    {
//                        /* there was no oldest player profile, so check for oldest headset profile to be deleted instead */
//                        oldestProfileId     = ERM_u8GetOldestHeadsetProfileId();
//                        oldestProfileType   = APP_DEVICE_enTYPE_HEADSET;
//                    }
//                    break;
//                default:
//                    rspCode = APP_COMMON_RSP_ERROR;
//                    break;
//            }
//
//            /* check if we found a valid profile to be deleted */
//            oldestProfile = ERM_pGetPlayerHeadsetProfile(oldestProfileId);
//            if( NULL == oldestProfile )
//            {
//
//                DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS580: don't know which profile to be deleted %d",
//                                oldestProfileId);
//               (void) _APP_SD_vReleasePendingContext(__LINE__);
//                return FAIL;
//            }
//
//            /* delete the profile */
//            switch( oldestProfileType )
//            {
//                case APP_DEVICE_enTYPE_HEADSET:
//                    rspCode = APP_DEVICE_rcDeleteHeadsetProfile( _APP_SD_vButtonPendingS580_Cb, oldestProfileId);
//                    break;
//                case APP_DEVICE_enTYPE_PLAYER:
//                    rspCode = APP_DEVICE_rcDeletePlayerProfile( _APP_SD_vButtonPendingS580_Cb, oldestProfileId);
//                    break;
//                default:
//                    rspCode = APP_COMMON_RSP_ERROR;
//                    break;
//            }
//            /* check response code */
//            switch( rspCode )
//            {
//                case APP_COMMON_RSP_OK:
//                    /* wait for response */
//                    gAppSdContext.deleteDeviceCounter = 0;
//                    break;
//                case APP_COMMON_RSP_ERROR_BUSY:
//                    /* try again later */
//                    gAppSdContext.deleteDeviceCounter += 1;
//                    if (gAppSdContext.deleteDeviceCounter >=10)
//                    {
//                        APP_DEVICE_vEmergencyReleaseContextFromAppSd();
//                        gAppSdContext.deleteDeviceCounter = 0;
//                    }
//                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(100), 0);
//                    break;
//                default:
//                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS580: Request failed (%d), DELETE_OLDEST_PROFILE_2",
//                                  rspCode);
//                   (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
//            }
//            break;
//        }
//        /*
//         * ticket 8480: uncommented this case */
////         case APP_SD_S580_DELETE_OLDEST_USER_PROFILE_NOT_SENT:
////        {
////            APP_COMMON_enResponseCode rspCode       = APP_COMMON_RSP_OK;
////            Uint8Type oldestProfileId               = AT_INVALID_DEVICE_ID;
////            APP_DEVICE_DeviceType oldestProfileType = pCtxCtrl->s580.deviceType;
////            const ERMPlayerHeadsetProfileType * oldestProfile   = NULL;
////
////            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "sfHandlePendingButtonS580: start state APP_SD_S580_DELETE_OLDEST_USER_PROFILE_NOT_SENT");
////
////            // check which player / headset profile to be deleted
////            switch( pCtxCtrl->s580.deviceType )
////            {   /* prio is to delete a profile of deviceType of current SD context */
////                case APP_DEVICE_enTYPE_HEADSET:
////                    /* first check if we can delete a headset */
////                    oldestProfileId = ERM_u8GetOldestHeadsetProfileId();
////                    if( AT_INVALID_DEVICE_ID == oldestProfileId )
////                    {
////                        /* there was no oldest headset profile, so check for oldest player profile to be deleted instead */
////                        oldestProfileId     = ERM_u8GetOldestPlayerProfileId();
////                        oldestProfileType   = APP_DEVICE_enTYPE_PLAYER;
////                    }
////                    break;
////                case APP_DEVICE_enTYPE_PLAYER:
////                    /* first check if we can delete a player */
////                    oldestProfileId = ERM_u8GetOldestNoActiveUserProfileId();
////                    if( AT_INVALID_DEVICE_ID == oldestProfileId )
////                    {
////                        /* there was no oldest player profile, so check for oldest headset profile to be deleted instead */
////                        oldestProfileId     = ERM_u8GetOldestHeadsetProfileId();
////                        oldestProfileType   = APP_DEVICE_enTYPE_HEADSET;
////                    }
////                    break;
////                default:
////                    rspCode = APP_COMMON_RSP_ERROR;
////                    break;
////            }
////
////            /* check if we found a valid profile to be deleted */
////            oldestProfile = ERM_pGetPlayerHeadsetProfile(oldestProfileId);
////            if( NULL == oldestProfile )
////            {
////
////                DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS580: don't know which profile to be deleted %d", oldestProfileId);
////               (void) _APP_SD_vReleasePendingContext(__LINE__);
////                return FAIL;
////            }
////
////            /* delete the profile */
////            switch( oldestProfileType )
////            {
////                case APP_DEVICE_enTYPE_HEADSET:
////                    rspCode = APP_DEVICE_rcDeleteHeadsetProfile( _APP_SD_vButtonPendingS580_Cb, oldestProfileId);
////                    break;
////                case APP_DEVICE_enTYPE_PLAYER:
////                    rspCode = APP_DEVICE_rcDeleteUserProfile( _APP_SD_vButtonPendingS580_Cb, oldestProfileId);
////                    break;
////                default:
////                    rspCode = APP_COMMON_RSP_ERROR;
////                    break;
////            }
////            /* check response code */
////            switch( rspCode )
////            {
////                case APP_COMMON_RSP_OK:
////                    /* wait for response */
////                    gAppSdContext.deleteDeviceCounter = 0;
////                    break;
////                case APP_COMMON_RSP_ERROR_BUSY:
////                    /* try again later */
////
////                    gAppSdContext.deleteDeviceCounter += 1;
////                    if (gAppSdContext.deleteDeviceCounter >=10)
////                    {
////                        APP_DEVICE_vEmergencyReleaseContextFromAppSd();
////                        gAppSdContext.deleteDeviceCounter = 0;
////                    }
////                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(100), 0);
////                    break;
////                default:
////                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS580: Request failed (%d), APP_SD_S580_DELETE_OLDEST_USER_PROFILE_NOT_SENT",
////                                  rspCode);
////                   (void) _APP_SD_vReleasePendingContext(__LINE__);
////                    return FAIL;
////            }
////            break;
////        } /* ticket 8480: end of uncommented case */
//        case APP_SD_S580_ADD_NEW_PLAYER_PROFILE_NOT_SEND:
//        {   /* finally add the new profile depending on device type */
//            APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_OK;
//            AppSdSpelledTextType spelledText;
//
//            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "sfHandlePendingButtonS580: start state APP_SD_S580_ADD_NEW_PLAYER_PROFILE_NOT_SEND");
//
//            APP_SD_SC_vReadSpelledText( &(pCtxCtrl->s580.spellerCtrl),
//                                        &spelledText);
//
//            switch( pCtxCtrl->s580.deviceType )
//            {
//                case APP_DEVICE_enTYPE_PLAYER:
//                    rspCode = APP_DEVICE_rcAddPlayerProfile(_APP_SD_vButtonPendingS580_Cb,
//                                           pCtxCtrl->s580.deviceId,
//                                           spelledText.data,
//                                           spelledText.length );
//                    break;
//                case APP_DEVICE_enTYPE_HEADSET:
//                    rspCode = APP_DEVICE_rcAddHeadsetProfile(_APP_SD_vButtonPendingS580_Cb,
//                                           pCtxCtrl->s580.deviceId,
//                                           spelledText.data,
//                                           spelledText.length );
//                    break;
//                default:
//                   (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
//            }
//            switch( rspCode )
//            {
//                case APP_COMMON_RSP_OK:
//                    /* wait for response */
//                    gAppSdContext.addProfileCounter = 0;
//                    break;
//                case APP_COMMON_RSP_ERROR_BUSY:
//                    /* try again later */
//                    gAppSdContext.addProfileCounter += 1;
//                    if (gAppSdContext.addProfileCounter >=10)
//                    {
//                        APP_DEVICE_vEmergencyReleaseContextFromAppSd();
//                        gAppSdContext.addProfileCounter = 0;
//                    }
//                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(100), 0);
//                    break;
//                default:
//                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS580: Request failed (%d), APP_SD_S580_ADD_NEW_PLAYER_PROFILE_NOT_SEND",
//                                  rspCode);
//                   (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
//            }
//            break;
//        }
//        case APP_SD_S580_ADD_NEW_USER_PROFILE_NOT_SEND:
//        {   /* finally add the new profile depending on device type */
//            APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_OK;
//            AppSdSpelledTextType spelledText;
//
//            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "sfHandlePendingButtonS580: start state APP_SD_S580_ADD_NEW_USER_PROFILE_NOT_SEND");
//
//            APP_SD_SC_vReadSpelledText( &(pCtxCtrl->s580.spellerCtrl),
//                                        &spelledText);
//
//            rspCode = APP_DEVICE_rcAddUserProfile(_APP_SD_vButtonPendingS580_Cb, pCtxCtrl->s580.deviceId, spelledText.data, spelledText.length);
//
//            switch( rspCode )
//            {
//                case APP_COMMON_RSP_OK:
//                    /* wait for response */
//
//                    // Show S534 until we get feedback from EEPROM, that
//                    // user profile was successfully saved!!!!!!!
//                    //_APP_SD_vInitFrameS534(pCtxCtrl->s535.deviceId);
//                     gAppSdContext.addProfileCounter = 0;
//                    break;
//                case APP_COMMON_RSP_ERROR_BUSY:
//                    /* try again later */
//                    gAppSdContext.addProfileCounter += 1;
//                    if (gAppSdContext.addProfileCounter >=10)
//                    {
//                        APP_DEVICE_vEmergencyReleaseContextFromAppSd();
//                        gAppSdContext.addProfileCounter = 0;
//                    }
//                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(100), 0);
//                    break;
//                default:
//                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS580: Request failed (%d), APP_SD_S580_ADD_NEW_USER_PROFILE_NOT_SEND",
//                                  rspCode);
//                   (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
//            }
//            break;
//        }
//        default:
//            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS580: invalid state %d",
//                            pCtxCtrl->s580.subStateBtn);
//            (void) _APP_SD_vReleasePendingContext(__LINE__);
//            return FAIL;
//    }
//    return SUCCESS;
//}

SuccessFailType _APP_SD_sfHandlePendingButtonS581(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s581.subStateBtn)
    {
        case APP_SD_S581_CANCEL_INQUIRY_NOT_SENT:
        {
            // cancel inquiry
            APP_COMMON_enResponseCode rspCode =
                        ERM_rcCancelInquiry(_APP_SD_vButtonPendingS581_Cb);

            switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    /* wait for response */
                    pCtxCtrl->s581.subStateBtn = APP_SD_S581_CANCEL_INQUIRY_SENT;
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS581: Request failed (%d)",
                                  rspCode);
                    pCtxCtrl->s581.subStateBtn = APP_SD_S581_CANCEL_INQUIRY_SENT;
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    return FAIL;
            }
            break;
        }
        default:
        {
            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS581: invalid state %d",
                            pCtxCtrl->s581.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
        }
    }
    return SUCCESS;
}



SuccessFailType _APP_SD_sfHandlePendingButtonS642(AppSdCtxCtrlType *pCtxCtrl)
{
    const ERMUserProfileType *profile = ERM_pGetActiveUserProfile();
    if( NULL != profile )
    {
        Uint8Type profileIndex = ERM_u8GetUserProfileIndexForDeviceId(profile->deviceIndex);

        APP_COMMON_enResponseCode rspCode = APP_DEVICE_rcSetRingtone( _APP_SD_vButtonPendingS642_Cb,
                                                                  profileIndex,
                                                                  pCtxCtrl->s642.ringtone);

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    /* wait for response */
                    gAppSdContext.setRingtoneCounter = 0;
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                {
                /* try again later */
                    gAppSdContext.setRingtoneCounter += 1;
                    if (gAppSdContext.setRingtoneCounter >=10)
                    {
                        APP_DEVICE_vEmergencyReleaseContextFromAppSd();
                        gAppSdContext.setRingtoneCounter = 0;
                    }
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(100), 0);
                    break;
                }
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS642: Request failed (%d)",
                                  rspCode);
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    return FAIL;
            }
    }
    else
    {
        DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS642: no active user profile");
       (void) _APP_SD_vReleasePendingContext(__LINE__);
        return FAIL;
    }
    return SUCCESS;
}


SuccessFailType _APP_SD_sfHandlePendingButtonS661(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s661.subStateBtn)
    {
        case APP_SD_S661_START_SYNCHRO_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode =
                        APP_PHONEBOOK_rcRequestManualSync(_APP_SD_vButtonPendingS661_Cb);

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    /* wait for response */
                    gAppSdContext.manualPbSyncInProgress    = BT_TRUE;
                    pCtxCtrl->s661.subStateBtn = APP_SD_S661_START_SYNCHRO_SENT;
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS661: Request failed (%d)",
                                  rspCode);
                    pCtxCtrl->s661.subStateBtn = APP_SD_S661_START_SYNCHRO_SENT;
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    return FAIL;
            }
            break;
        }
        default:
        {
            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS661: invalid state %d",
                            pCtxCtrl->s661.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
        }
    }

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandlePendingButtonS669(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s669.subStateBtn)
    {
        case APP_SD_S669_SORTORDER_SELECT_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONEBOOK_rcSetPbSortOrder(
                                                              _APP_SD_vButtonPendingS669_Cb,
                                                              pCtxCtrl->s669.sortOrder,
                                                              BT_FALSE);

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    /* wait for response */
                    pCtxCtrl->s669.subStateBtn = APP_SD_S669_SORTORDER_SELECT_SENT;
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS669: Request failed (%d)",
                                  rspCode);
                    pCtxCtrl->s669.subStateBtn = APP_SD_S669_SORTORDER_SELECT_SENT;
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    return FAIL;
            }
            break;
        }
        default:
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS669: invalid state %d",
                            pCtxCtrl->s669.subStateBtn);
            _APP_SD_vCtxHistoryStepBack();
            break;
        }
    }
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandlePendingButtonS408_PRECALL(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s408.subStateBtn)
    {
        case APP_SD_S408_HANGUP_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcHangUp( NULL, AT_HANGUP_NO_INDEX);

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:

                    gAppSdContext.preCallStateIsActive = BT_FALSE;

                    pCtxCtrl->s408.subStateBtn = APP_SD_S408_HANGUP_SENT;
                    /* final state reached */
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS408_PRECALL: Request failed (%d)",
                                  rspCode);
                    pCtxCtrl->s408.subStateBtn = APP_SD_S408_HANGUP_SENT;
                    /* final state reached */
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
                    break;
            }
            break;
        }
        default:
        {
            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "_APP_SD_sfHandlePendingButtonS408_PRECALL: invalid state %d",
                            pCtxCtrl->s408.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
//            return FAIL;
            break;
        }
    }
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandlePendingButtonS801(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s801.subStateBtn)

    {
        case APP_SD_S801_HANGUP_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcHangUp( NULL, AT_HANGUP_NO_INDEX);

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s801.subStateBtn = APP_SD_S801_HANGUP_SENT;
                    /* final state reached */
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS801: Request failed (%d), HANGUP",
                                  rspCode);
                    pCtxCtrl->s801.subStateBtn = APP_SD_S801_HANGUP_SENT;
                    /* final state reached */
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
                    break;
            }
        }
        case APP_SD_S801_HEADSET_NOT_SENT:				// RT 2276
        {
            APP_COMMON_enResponseCode rspCode;
            ATAudioGatewayModeEnum mode = ( APP_PHONE_bIsHeadsetOn() == BT_TRUE ) ?
                                            AT_AUDIO_GW_MODE_OFF : AT_AUDIO_GW_MODE_ON;

            rspCode = APP_PHONE_rcHeadsetOnOff( NULL, mode);

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s801.subStateBtn = APP_SD_S801_HEADSET_SENT;
                    /* final state reached */
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS801: Request failed (%d), HEADSET",
                                  rspCode);
                    pCtxCtrl->s801.subStateBtn = APP_SD_S801_HEADSET_SENT;
                    /* final state reached */
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
                    break;
            }
            break;
        }
        case APP_SD_S801_PRIVATE_MODE_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcHandsFreeOnOff( NULL, AT_AUDIO_DISCRETE_MODE );

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s801.subStateBtn = APP_SD_S801_PRIVATE_MODE_SENT;
                    /* final state reached */
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS801: Request failed (%d), PRIVATE_MODE",
                                  rspCode);
                    pCtxCtrl->s801.subStateBtn = APP_SD_S801_PRIVATE_MODE_SENT;
                    /* final state reached */
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
                    break;
            }
            break;
        }
        default:
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS801: invalid state %d",
                            pCtxCtrl->s801.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
//            return FAIL;
            break;
        }
    }
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandlePendingButtonS803(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s803.subStateBtn)
    {
        case APP_SD_S803_HANGUP_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcHangUp( NULL, AT_HANGUP_NO_INDEX);

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s803.subStateBtn = APP_SD_S803_HANGUP_SENT;
                    /* final state reached */
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS803: Request failed (%d), HANGUP",
                                  rspCode);
                    pCtxCtrl->s803.subStateBtn = APP_SD_S803_HANGUP_SENT;
                    /* final state reached */
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
                    break;
            }
            break;
        }
        case APP_SD_S803_HOLD_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcCallHold( NULL );

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s803.subStateBtn = APP_SD_S803_HOLD_SENT;
                    /* final state reached */
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS803: Request failed (%d), HOLD",
                                  rspCode);
                    pCtxCtrl->s803.subStateBtn = APP_SD_S803_HOLD_SENT;
                    /* final state reached */
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
                    break;
            }
            break;
        }
        case APP_SD_S803_HEADSET_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode;
            ATAudioGatewayModeEnum mode = ( APP_PHONE_bIsHeadsetOn() == BT_TRUE ) ?			// RT 2276
                                            AT_AUDIO_GW_MODE_OFF : AT_AUDIO_GW_MODE_ON;

            rspCode = APP_PHONE_rcHeadsetOnOff( NULL, mode);

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s803.subStateBtn = APP_SD_S803_HEADSET_SENT;
                    /* final state reached */
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS803: Request failed (%d), HEADSET",
                                  rspCode);
                    pCtxCtrl->s803.subStateBtn = APP_SD_S803_HEADSET_SENT;
                    /* final state reached */
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
                    break;
            }
            break;
        }
        case APP_SD_S803_HANDSFREE_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcHandsFreeOnOff( NULL, AT_AUDIO_DISCRETE_MODE );

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s803.subStateBtn = APP_SD_S803_HANDSFREE_SENT;
                    /* final state reached */
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS803: Request failed (%d), HANDSFREE",
                                  rspCode);
                    pCtxCtrl->s803.subStateBtn = APP_SD_S803_HANDSFREE_SENT;
                    /* final state reached */
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
                    break;
            }
            break;
        }
        case APP_SD_S803_MICROMUTE_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcToggleMicMute( NULL );

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s803.subStateBtn = APP_SD_S803_MICROMUTE_SENT;
                    /* final state reached */
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS803: Request failed (%d), MICROMUTE",
                                  rspCode);
                    pCtxCtrl->s803.subStateBtn = APP_SD_S803_MICROMUTE_SENT;
                    /* final state reached */
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
                    break;
            }
            break;
        }
        default:
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS803: invalid state %d",
                            pCtxCtrl->s803.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
        }
    }

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandlePendingButtonS804(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s804.subStateBtn)
    {
        case APP_SD_S804_DTMF_NOT_SENT:
        {
            Uint8Type lastChar = 0;

            if( APP_SD_SC_bGetLastSpelledChar(&(pCtxCtrl->s804.spellerCtrl), &lastChar) == BT_TRUE )
            {
                APP_COMMON_enResponseCode rspCode = APP_PHONE_rcSendDTMF( NULL, &lastChar, 1 );

                 switch( rspCode )
                {
                    case APP_COMMON_RSP_OK:
                        pCtxCtrl->s804.subStateBtn = APP_SD_S804_DTMF_SENT;

                        /* Update the frame */
                        pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;
                        pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case APP_COMMON_RSP_ERROR_BUSY:
                        /* try again later */
                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                        break;
                    default:
                        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS804: Request failed (%d)",
                                  rspCode);
                        pCtxCtrl->s804.subStateBtn = APP_SD_S804_DTMF_SENT;
                        /* final state reached */
                        (void) _APP_SD_vReleasePendingContext(__LINE__);
    //                    return FAIL;
                        break;
                }
            }
            else
            {
                pCtxCtrl->s804.subStateBtn = APP_SD_S804_DTMF_SENT;
                /* final state reached */
                (void) _APP_SD_vReleasePendingContext(__LINE__);
            }
            break;
        }
        default:
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS804: invalid state %d",
                            pCtxCtrl->s804.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
        }
    }

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandlePendingButtonS811(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s811.subStateBtn)
    {
        case APP_SD_S811_RESUME_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcResumeCall( NULL );

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s811.subStateBtn = APP_SD_S811_RESUME_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS811: Request failed (%d), RESUME",
                                  rspCode);
                    pCtxCtrl->s811.subStateBtn = APP_SD_S811_RESUME_SENT;
                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
                    break;
            }
            break;
        }
        case APP_SD_S811_HANGUP_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcHangUp( NULL, AT_HANGUP_NO_INDEX );

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s811.subStateBtn = APP_SD_S811_HANGUP_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS811: Request failed (%d), HANGUP",
                                  rspCode);
                    pCtxCtrl->s811.subStateBtn = APP_SD_S811_HANGUP_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
                    break;
            }
            break;
        }
        default:
        {
            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS811: invalid state %d",
                            pCtxCtrl->s811.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
        }
    }

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandlePendingButtonS812(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s812.subStateBtn)
    {
        case APP_SD_S812_HANGUP_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcHangUp( NULL, AT_HANGUP_NO_INDEX ); //(ATCallHangupEnum)pCtxCtrl->s812.activePlccIdx);

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s812.subStateBtn = APP_SD_S812_HANGUP_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS812: Request failed (%d), HANGUP",
                                  rspCode);
                    pCtxCtrl->s812.subStateBtn = APP_SD_S812_HANGUP_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
                    break;
            }
            break;
        }
        case APP_SD_S812_SWITCH_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcSwitchCalls( NULL );

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s812.subStateBtn = APP_SD_S812_SWITCH_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS812: Request failed (%d), SWITCH",
                                  rspCode);
                    pCtxCtrl->s812.subStateBtn = APP_SD_S812_SWITCH_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
                    break;
            }
            break;
        }
        case APP_SD_S812_CONFERENCE_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcJoinToConference( _APP_SD_vButtonPendingS812_Cb );

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s812.subStateBtn = APP_SD_S812_CONFERENCE_SENT;

                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS812: Request failed (%d), CONFERENCE",
                                  rspCode);
                    pCtxCtrl->s812.subStateBtn = APP_SD_S812_CONFERENCE_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
                    break;
            }
            break;
        }
        case APP_SD_S812_MICROMUTE_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcToggleMicMute( NULL );

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s812.subStateBtn = APP_SD_S812_MICROMUTE_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS812: Request failed (%d), MICROMUTE",
                                  rspCode);
                    pCtxCtrl->s812.subStateBtn = APP_SD_S812_MICROMUTE_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
                    break;
            }
            break;
        }
        case APP_SD_S812_HANGUP_BOTH_NOT_SENT:
        {
            /* release first the held plcc, after the asynchronous OK, we set the state
             * to APP_SD_S812_HANGUP_NOT_SENT to hangup the active plcc */
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcHangUpAll(_APP_SD_vButtonPendingS812_Cb);

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s812.subStateBtn = APP_SD_S812_HANGUP_BOTH_SENT;

                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS812: Request failed (%d), HANGUP_BOTH",
                                  rspCode);
                    pCtxCtrl->s812.subStateBtn = APP_SD_S812_HANGUP_BOTH_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
                    break;
            }
            break;
        }
        case APP_SD_S812_HEADSET_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode;
            ATAudioGatewayModeEnum mode = ( APP_PHONE_bIsHeadsetOn() == BT_TRUE ) ?				// RT 2276
                                            AT_AUDIO_GW_MODE_OFF : AT_AUDIO_GW_MODE_ON;

            rspCode = APP_PHONE_rcHeadsetOnOff( NULL, mode);

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s812.subStateBtn = APP_SD_S812_HEADSET_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS812: Request failed (%d), HEADSET",
                                  rspCode);
                    pCtxCtrl->s812.subStateBtn = APP_SD_S812_HEADSET_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
                    break;
            }
            break;
        }
        default:
        {
            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD,"sfHandlePendingButtonS812: invalid state %d",
                            pCtxCtrl->s812.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
        }
    }

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandlePendingButtonS815(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s815.subStateBtn)
    {
        case APP_SD_S815_HANGUP_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcHangUp( NULL, AT_HANGUP_NO_INDEX );

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s815.subStateBtn = APP_SD_S815_HANGUP_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS815: Request failed (%d), HANGUP",
                                  rspCode);
                    pCtxCtrl->s815.subStateBtn = APP_SD_S815_HANGUP_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
                    break;
            }
            break;
        }
        case APP_SD_S815_MICROMUTE_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcToggleMicMute( NULL );

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s815.subStateBtn = APP_SD_S815_MICROMUTE_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS815: Request failed (%d), MICROMUTE",
                                  rspCode);
                    pCtxCtrl->s815.subStateBtn = APP_SD_S815_MICROMUTE_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
                    break;
            }
            break;
        }
        case APP_SD_S815_HEADSET_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode;
            ATAudioGatewayModeEnum mode = ( APP_PHONE_bIsHeadsetOn() == BT_TRUE ) ?				// RT 2276
                                            AT_AUDIO_GW_MODE_OFF : AT_AUDIO_GW_MODE_ON;

            rspCode = APP_PHONE_rcHeadsetOnOff( NULL, mode);

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s815.subStateBtn = APP_SD_S815_HEADSET_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS815: Request failed (%d), HEADSET",
                                  rspCode);
                    pCtxCtrl->s815.subStateBtn = APP_SD_S815_HEADSET_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
                    break;
            }
            break;
        }
        case APP_SD_S815_HOLD_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcCallHold( NULL );

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s815.subStateBtn = APP_SD_S815_HOLD_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS815: Request failed (%d), HOLD",
                                  rspCode);
                    pCtxCtrl->s815.subStateBtn = APP_SD_S815_HOLD_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
                    break;
            }
            break;
        }
        default:
        {
            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS815: invalid state %d",
                            pCtxCtrl->s815.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
        }
    }

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandlePendingButtonS901(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s901.subStateBtn)
    {
        case APP_SD_S901_ACCEPT_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcAcceptCall( NULL );

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s901.subStateBtn = APP_SD_S901_ACCEPT_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS901: Request failed (%d), ACCEPT",
                                  rspCode);
                    pCtxCtrl->s901.subStateBtn = APP_SD_S901_ACCEPT_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
                    break;
            }
            break;
        }
        case APP_SD_S901_HANGUP_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcHangUp( NULL, AT_HANGUP_NO_INDEX);

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s901.subStateBtn = APP_SD_S901_HANGUP_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS901: Request failed (%d), HANGUP",
                                  rspCode);
                    pCtxCtrl->s901.subStateBtn = APP_SD_S901_HANGUP_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
//                    return FAIL;
                    break;
            }
            break;
        }
        case APP_SD_S901_MUTE_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcSilentRinging();

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s901.subStateBtn = APP_SD_S901_MUTE_SENT;
                    pCtxCtrl->s901.muteActivated = BT_TRUE;
                    pCtxCtrl->common.listData.listElemOnTop   = 1;    // first list elem
                    pCtxCtrl->common.listData.focusedListElemOffset = 0;    // first list elem
                    pCtxCtrl->common.listData.numListElems--;

                    _APP_SD_vRefreshFrame(pCtxCtrl);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS901: Request failed (%d), MUTE",
                                  rspCode);
                    pCtxCtrl->s901.subStateBtn = APP_SD_S901_MUTE_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    return FAIL;
            }
            break;
        }
        case APP_SD_S901_HEADSET_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode;
            ATAudioGatewayModeEnum mode = ( APP_PHONE_bIsHeadsetOn() == BT_TRUE ) ?				// RT 2276
                                            AT_AUDIO_GW_MODE_OFF : AT_AUDIO_GW_MODE_ON;

            rspCode = APP_PHONE_rcHeadsetOnOff( NULL, mode);

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    /* AcceptCall */                    // RT 2276
                    pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    pCtxCtrl->s901.subStateBtn   = APP_SD_S901_ACCEPT_NOT_SENT;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                      MSEC(0),
                                                      0);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS901: Request failed (%d), HEADSET",
                                  rspCode);
                    pCtxCtrl->s901.subStateBtn = APP_SD_S901_ACCEPT_NOT_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
            }
            break;
        }
        default:
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS901: invalid state %d",
                            pCtxCtrl->s901.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
        }
    }

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandlePendingButtonS902(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s902.subStateBtn)
    {
        case APP_SD_S902_ACCEPT_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcAcceptCall( NULL );

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s902.subStateBtn = APP_SD_S902_ACCEPT_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS902: Request failed (%d), ACCEPT",
                                  rspCode);
                    pCtxCtrl->s902.subStateBtn = APP_SD_S902_ACCEPT_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
//                   return FAIL;
                   break;
            }
            break;
        }
        case APP_SD_S902_HANGUP_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcHangUp( NULL,
                                                                    (ATCallHangupEnum)pCtxCtrl->s902.waitingPlccIdx);

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s902.subStateBtn = APP_SD_S902_HANGUP_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS902: Request failed (%d), HANGUP",
                                  rspCode);
                    pCtxCtrl->s902.subStateBtn = APP_SD_S902_HANGUP_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
//                   return FAIL;
                   break;
            }
            break;
        }
        case APP_SD_S902_RELEASE_ACCEPT_NOT_SENT:
        {
            // TODO: Ticket #3193 When we have a conference active, we cannot use CHUP to release the
            // active call and accept the waiting call, we need to use PMPC=0
            //APP_COMMON_enResponseCode rspCode = APP_PHONE_rcReleaseActiveCallAcceptWaitingCall( NULL );

            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcCallReplace( NULL);

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s902.subStateBtn = APP_SD_S902_RELEASE_ACCEPT_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS902: Request failed (%d), RELEASE_ACCEPT",
                                  rspCode);
                    pCtxCtrl->s902.subStateBtn = APP_SD_S902_RELEASE_ACCEPT_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                   break;
            }
            break;
        }
        default:
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS902: invalid state %d",
                            pCtxCtrl->s902.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
        }
    }

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandlePendingButtonS933(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s933.subStateBtn)
    {
        case APP_SD_S933_REJECT_NOT_SENT:
        {
            const ERMPairReqType *pPairRequest = ERM_pGetPairRequest();

            APP_COMMON_enResponseCode rspCode = ERM_rcRejectPairing( pPairRequest->remote_id, pPairRequest->device_type, _APP_SD_vButtonPendingS933_Cb);

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    /* final state reached */
                    DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD,"RejectPairing Successfull send -> release pending conext");

                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                   if (!_APP_SD_bPhoneContextActive())
                   {
                       _APP_SD_vReleasePhoneContext();
                   }
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD,"RejectPairing busy -> stay in pending conext");
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS933: Reject Pairing Request failed (%d)",
                                  rspCode);

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                   break;
            }
            break;
        }
        default:
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS933: invalid state %d",
                            pCtxCtrl->s933.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
        }
    }

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandlePendingButtonS941(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s941.subStateBtn)
    {
        case APP_SD_S941_ACCEPT_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcAcceptCall( NULL );

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s941.subStateBtn = APP_SD_S941_ACCEPT_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS941: Request failed (%d), ACCEPT",
                                  rspCode);
                    pCtxCtrl->s941.subStateBtn = APP_SD_S941_ACCEPT_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
//                   return FAIL;
                   break;
            }
            break;
        }
        default:
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS941: invalid state %d",
                            pCtxCtrl->s941.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
        }
    }

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandlePendingButtonS942(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s942.subStateBtn)
    {
        case APP_SD_S942_HANGUP_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcHangUp( NULL, AT_HANGUP_NO_INDEX);

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s942.subStateBtn = APP_SD_S942_HANGUP_SENT;

                    /* switch display off */
                    (void)KPB_sfShutdown();

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS942: Request failed (%d)",
                                  rspCode);
                    pCtxCtrl->s942.subStateBtn = APP_SD_S942_HANGUP_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                   break;
            }
            break;
        }
        default:
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS942: invalid state %d",
                            pCtxCtrl->s942.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
        }
    }
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandlePendingButtonS945(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s945.subStateBtn)
    {
        case APP_SD_S945_HANGUP_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcHangUp( NULL, AT_HANGUP_NO_INDEX);

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->s945.subStateBtn = APP_SD_S945_HANGUP_SENT;

                    /* switch display off */
                    (void)KPB_sfShutdown();

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnS945: Request failed (%d)",
                                  rspCode);
                    pCtxCtrl->s945.subStateBtn = APP_SD_S945_HANGUP_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                   break;
            }
            break;
        }
        default:
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonS945: invalid state %d",
                            pCtxCtrl->s945.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
        }
    }
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandlePendingButtonSC13(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->sc13.subStateBtn)
    {
        case APP_SD_SC13_CANCEL_INQUIRY_NOT_SENT:
        {
            // cancel inquiry
            APP_COMMON_enResponseCode rspCode =
                        ERM_rcCancelInquiry(_APP_SD_vButtonPendingSC13_Cb);

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->sc13.subStateBtn = APP_SD_SC13_CANCEL_INQUIRY_SENT;
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnSC13: Request failed (%d)",
                                  rspCode);
                    pCtxCtrl->sc13.subStateBtn = APP_SD_SC13_CANCEL_INQUIRY_SENT;
                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                   break;
            }
            break;
        }
        default:
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonSC13: invalid state %d",
                            pCtxCtrl->sc13.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
        }
    }
    return SUCCESS;
}


SuccessFailType _APP_SD_sfHandlePendingButtonSC16(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->sc16.subStateBtn)
    {
        case APP_SD_SC16_SET_PLAY_CALLER_NAME_SELECT_NOT_SENT:
        {
            const ERMUserProfileType * profile = ERM_pGetActiveUserProfile();
            if( NULL != profile )
            {
                Uint8Type profileIndex = ERM_u8GetUserProfileIndexForDeviceId(profile->deviceIndex);
                APP_COMMON_enResponseCode rspCode = APP_DEVICE_rcSetRingtoneAlternate(
                                                         NULL,
                                                         profileIndex,
                                                         pCtxCtrl->sc16.bPlayCallerName);

                 switch( rspCode )
                {
                    case APP_COMMON_RSP_OK:
                    {
                        gAppSdContext.setRingtoneCounter = 0;
                        pCtxCtrl->sc16.subStateBtn = APP_SD_SC16_SET_PLAY_CALLER_NAME_SELECT_SENT;
                        _APP_SD_vCtxHistoryStepBack();
                        break;
                    }
                    case APP_COMMON_RSP_ERROR_BUSY:
                    {
                    /* try again later */
                        gAppSdContext.setRingtoneCounter += 1;
                        if (gAppSdContext.setRingtoneCounter >=10)
                        {
                            APP_DEVICE_vEmergencyReleaseContextFromAppSd();
                            gAppSdContext.setRingtoneCounter = 0;
                        }
                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(100), 0);
                        break;
                    }
                    default:
                        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnSC16: Request failed (%d)",
                                  rspCode);
                        pCtxCtrl->sc16.subStateBtn = APP_SD_SC16_SET_PLAY_CALLER_NAME_SELECT_SENT;
                        _APP_SD_vCtxHistoryStepBack();
                       break;
                }
            }
            else
            {
                DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnSC16: no active profile");
                pCtxCtrl->sc16.subStateBtn = APP_SD_SC16_SET_PLAY_CALLER_NAME_SELECT_SENT;
                _APP_SD_vCtxHistoryStepBack();
            }
            break;
        }
        default:
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonSC16: invalid state %d",
                            pCtxCtrl->sc16.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
        }
    }
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandlePendingButtonSC20(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->sc20.subStateBtn)
    {
        case APP_SD_SC20_HANGUP_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcHangUp( NULL, AT_HANGUP_NO_INDEX);

                 switch( rspCode )
                {
                    case APP_COMMON_RSP_OK:
                        pCtxCtrl->sc20.subStateBtn = APP_SD_SC20_HANGUP_SENT;

                        /* final state reached */
                       (void) _APP_SD_vReleasePendingContext(__LINE__);
                        break;
                    case APP_COMMON_RSP_ERROR_BUSY:
                        /* try again later */
                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                        break;
                    default:
                        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnSC20: Request failed (%d), HANGUP",
                                  rspCode);
                        pCtxCtrl->sc20.subStateBtn = APP_SD_SC20_HANGUP_SENT;

                        /* final state reached */
                       (void) _APP_SD_vReleasePendingContext(__LINE__);
                       break;
                }
            break;
        }
        case APP_SD_SC20_HANDSFREE_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcHandsFreeOnOff( NULL, AT_AUDIO_HANDSFREE_MODE );

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->sc20.subStateBtn = APP_SD_SC20_HANDSFREE_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnSC20: Request failed (%d), HANDSFREE",
                              rspCode);
                    pCtxCtrl->sc20.subStateBtn = APP_SD_SC20_HANDSFREE_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                   break;
            }
            break;
        }
        default:
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonSC20: invalid state %d",
                            pCtxCtrl->sc20.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
        }
    }

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandlePendingButtonSC24(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->sc24.subStateBtn)
    {
        case APP_SD_SC24_HANGUP_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcHangUp( NULL, AT_HANGUP_NO_INDEX ); //(ATCallHangupEnum)pCtxCtrl->s824.activePlccIdx);

                 switch( rspCode )
                {
                    case APP_COMMON_RSP_OK:
                        pCtxCtrl->sc24.subStateBtn = APP_SD_SC24_HANGUP_SENT;

                        /* final state reached */
                       (void) _APP_SD_vReleasePendingContext(__LINE__);
                        break;
                    case APP_COMMON_RSP_ERROR_BUSY:
                        /* try again later */
                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                        break;
                    default:
                        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnSC24: Request failed (%d), HANGUP",
                                  rspCode);
                        pCtxCtrl->sc24.subStateBtn = APP_SD_SC24_HANGUP_SENT;

                        /* final state reached */
                       (void) _APP_SD_vReleasePendingContext(__LINE__);
                       break;
                }
            break;
        }
        case APP_SD_SC24_SWITCH_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcSwitchCalls( NULL );

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->sc24.subStateBtn = APP_SD_SC24_SWITCH_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnSC24: Request failed (%d), SWITCH",
                                  rspCode);
                    pCtxCtrl->sc24.subStateBtn = APP_SD_SC24_SWITCH_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                   break;
            }
            break;
        }
        case APP_SD_SC24_CONFERENCE_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcJoinToConference( _APP_SD_vButtonPendingSC24_Cb );

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->sc24.subStateBtn = APP_SD_SC24_CONFERENCE_SENT;
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnSC24: Request failed (%d), CONFERENCE",
                                  rspCode);
                    pCtxCtrl->sc24.subStateBtn = APP_SD_SC24_CONFERENCE_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                   break;
            }
            break;
        }
        case APP_SD_SC24_MICROMUTE_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONE_rcToggleMicMute( NULL );

             switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->sc24.subStateBtn = APP_SD_SC24_MICROMUTE_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    /* try again later */
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    break;
                default:
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaPenBtnSC24: Request failed (%d), MICROMUTE",
                              rspCode);
                    pCtxCtrl->sc24.subStateBtn = APP_SD_SC24_MICROMUTE_SENT;

                    /* final state reached */
                   (void) _APP_SD_vReleasePendingContext(__LINE__);
                   break;
            }
            break;
        }
        default:
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePendingButtonSC24: invalid state %d",
                            pCtxCtrl->sc24.subStateBtn);
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            return FAIL;
        }
    }

    return SUCCESS;
}


/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_sfHandleInitFrame                                     */
/**
  \brief        This function handles further steps to initialize a frame

  \param        pCtxCtrl
                The current context control structure

  \return       SuccessFailType
                SUCCESS or FAIL

 */
/*----------------------------------------------------------------------------*/
SuccessFailType _APP_SD_sfHandleInitFrame(AppSdCtxCtrlType *pCtxCtrl)
{

    switch(pCtxCtrl->common.state)
    {
        case APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA:
        {
            SuccessFailType result = SUCCESS;
            if( pCtxCtrl->common.ctxId < NUM_ELEMENTS_OF_ARRAY(_APP_SD_sfHandleInitFrameTable))
            {
                if (_APP_SD_sfHandleInitFrameTable[pCtxCtrl->common.ctxId] != NULL)
                {
                    result = _APP_SD_sfHandleInitFrameTable[pCtxCtrl->common.ctxId](pCtxCtrl);
                }
                else
                {
                    pCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                }
            }
            else
            {

                DEBUG_VALUE1( APP_SD_SWI_WNG, MOD_APP_SD, "sFHIF: invalid ctx %d",
                                    pCtxCtrl->common.ctxId);
                result = FAIL;
                (void) _APP_SD_vReleasePendingContext(__LINE__);
            }

            if(result != SUCCESS)
            {

                DEBUG_VALUE2( APP_SD_SWI_ERR, MOD_APP_SD, "sFHIF: error in state %d (ctx %d) ",
                                    pCtxCtrl->common.state,
                                    pCtxCtrl->common.ctxId);
                _APP_SD_vInitIdleScreen(0);
            }
            break;
        }
        case APP_SD_CTX_FRAME_REQ_DATA:
        {
            switch(pCtxCtrl->common.listData.frameId)
            {
                case KPB_FRAME_ID_2:
                case KPB_FRAME_ID_3:
                case KPB_FRAME_ID_4:
                case KPB_FRAME_ID_5:
                case KPB_FRAME_ID_6:
                    if(APP_SD_LC_bDataNeed(&(pCtxCtrl->common.listData)) == BT_TRUE)
                    {
                        pCtxCtrl->common.state = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
                        APP_SD_LC_vRequestData(&(pCtxCtrl->common.listData));
                    }
                    else
                    {
                        pCtxCtrl->common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;

                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                    }
                    break;
                default:
                    pCtxCtrl->common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(0),
                                                        0);
                    break;
            }
            break;
        }
        case APP_SD_CTX_FRAME_WAIT_FOR_DATA:
        {
            /* do nothing but wait */
            break;
        }
        case APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE:
        {
            AppSdFrameDataType      *pFrameData = pCtxCtrl->common.pFrameData;
            AppSdFrameDataListCommon *pListCtrl = &pCtxCtrl->common.listData;

            /* ------------------------------- */
            /* send and activate the frame     */
            KpbFrameDataReqType *pFrameBuffer = NULL;
            SuccessFailType            result = FAIL;


            if(KPB_enGetAsgState() == KPB_ASG_STATUS_ALIVE)
            {
                //result = POOL_sfAllocate( POOL_enKpbFrameDataReqType,
                //                          (void**)&pFrameBuffer );
                result = KPB_sfAllocFrameBuffer( &pFrameBuffer, BT_TRUE );

                if(result != SUCCESS)
                {

                    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "sfHIF: GetFrameData blocked (%d)",
                                  pCtxCtrl->common.ctxId);

                    pCtxCtrl->common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                              MSEC(500),
                                                              0);
                    return FAIL;
                }

                switch(pCtxCtrl->common.listData.frameId)
                {
                    case KPB_FRAME_ID_2:
                    case KPB_FRAME_ID_3:
                    case KPB_FRAME_ID_4:
                    case KPB_FRAME_ID_5:
                    case KPB_FRAME_ID_6:
                    {
                        if(APP_SD_LC_sfSendListFrame( pFrameBuffer,
                                                      pListCtrl,
                                                      pFrameData,
                                                      gAppSdContext.activate) != SUCCESS)
                        {

                            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHIF: APP_SD_LC_vSendListFrame failed (ctx %d)",
                                            pCtxCtrl->common.ctxId);

                            pCtxCtrl->common.state = APP_SD_CTX_FRAME_SENT_FAILED;
                        }
                        else
                        {
                            pCtxCtrl->common.state = APP_SD_CTX_FRAME_SENT;
                        }
                        break;
                    }
                    default:
                    {
                        if(_APP_SD_FB_sfSendAndActivateFrame( pFrameBuffer,
                                                              pCtxCtrl->common.pFrameData,
                                                              gAppSdContext.activate) != SUCCESS)
                        {

                            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHIF: SendAndActivateFrame failed (ctx %d)",
                                            pCtxCtrl->common.ctxId);

                            pCtxCtrl->common.state = APP_SD_CTX_FRAME_SENT_FAILED;
                        }
                        else
                        {
                            pCtxCtrl->common.state = APP_SD_CTX_FRAME_SENT;
                        }
                        break;
                    }
                }
            }
            else // if(KPB_enGetAsgState() == KPB_ASG_STATUS_ALIVE)
            {

                DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHIF: ASG dead, drop ctx %d",
                              pCtxCtrl->common.ctxId);
            }

            /* final state reached */
           (void) _APP_SD_vReleasePendingContext(__LINE__);
            break;
        }
        default:

            DEBUG_VALUE2( APP_SD_SWI_ERR, MOD_APP_SD, "sfHIF: invalid state %d (ctx %d)",
                          pCtxCtrl->common.state,
                          pCtxCtrl->common.ctxId);
            return FAIL;
    }

    return SUCCESS;
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_sfHandleInitFrame                                     */
/**
  \brief        This function handles further steps to initialize context S001

  \param        pCtxCtrl
                The current context control structure

  \return       SuccessFailType
                SUCCESS or FAIL

 */
/*----------------------------------------------------------------------------*/
SuccessFailType _APP_SD_sfHandleInitFrameS001(AppSdCtxCtrlType *pCtxCtrl)
{
    Uint8Type profileId = ERM_GetLastActiveProfileId( pCtxCtrl->s001.connectAttempt,
                                                      APP_DEVICE_enTYPE_PHONE);
    const ERMUserProfileType *pUserProfile = ERM_pGetUserProfile(profileId);
    const ERMBTDeviceTableType *pBtDevice = NULL;
    const ERMPhysicalBTDeviceType *pPhyDevice = NULL;

    static BooleanType firstCall = BT_TRUE;

    if(firstCall)
    {
        firstCall = BT_FALSE;

        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "SYS_PERF: SD Presentation: %d ms",
                      osGetSystemCounter());
    }

    if(pUserProfile == NULL)
    {
        /* no further profile available */
        Uint8Type playerProfileId = ERM_GetLastActiveProfileId( 0, APP_DEVICE_enTYPE_PLAYER);
        const ERMPlayerHeadsetProfileType *pPlayerProfile = ERM_pGetPlayerHeadsetProfile(playerProfileId);

        if(pPlayerProfile != NULL)
        {
            Uint8Type counter;
            BooleanType bconnectPlayer = BT_FALSE;
            pBtDevice = ERM_GetBTDevice(pPlayerProfile->deviceIndex);

            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "pUserProfile == NULL, try first PlayerProfile: %d", pPlayerProfile->deviceIndex);

            if(pBtDevice == NULL)
            {

                DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "HaInitFrS001: no BT-DevT entry for Player, try Phy-DevT for idx %d",
                              playerProfileId);

                /* try to get the phy device, available after ERM EPROM read */
                pPhyDevice  = ERM_pGetPhyDevice(pPlayerProfile->deviceIndex);

                if( pPhyDevice == NULL )
                {

                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaInitFrS001: no dev for PlayerProfile %d",
                                  playerProfileId);

                    /* no device available */
                    _APP_SD_vCtxHistoryStepBack();
                    return SUCCESS;
                }
            }
            /* if last used player is stand alone player (not in phone list), connect else check if next last used player is stand alone */
            for (counter=1; counter <= ERM_MAX_NUM_HEADSET_PROFILE; counter++)
            {
                if (ERM_bPlayerIdIsInphoneList(pPlayerProfile->deviceIndex))
                {
                    DEBUG_VALUE2( APP_SD_SWI_TRC, MOD_APP_SD, "HaInitFrS001: playerprofile->Id  %d is in telefonlist. value of counter is %d",
                              pPlayerProfile->deviceIndex,counter) ;

                    pPlayerProfile =  ERM_pGetPlayerHeadsetProfile(ERM_GetLastActiveProfileId( counter, APP_DEVICE_enTYPE_PLAYER));
                    if (pPlayerProfile == NULL)
                    {
                        bconnectPlayer = BT_FALSE;
                        break;
                    }
                }
                else
                {
                   DEBUG_VALUE2( APP_SD_SWI_TRC, MOD_APP_SD, "HaInitFrS001: playerprofile->Id %d is not in telefonlist. value of counter is %d",
                              pPlayerProfile->deviceIndex,counter);
                   bconnectPlayer = BT_TRUE;
                   break;
                }
            }
            if (BT_TRUE == bconnectPlayer)
            {
                _APP_SD_vInitFrameSC12_2(pPlayerProfile->deviceIndex,counter);
                return SUCCESS;
            }
            else
            {
                DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "HaInitFrS001: no further Playerprof avail %d",
                        pCtxCtrl->s001.connectAttempt);
                _APP_SD_vCtxHistoryStepBack();
                return SUCCESS;

            }

        }
        else
        {
            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "HaInitFrS001: no further prof avail %d",
                    pCtxCtrl->s001.connectAttempt);
            _APP_SD_vCtxHistoryStepBack();
            return SUCCESS;
        }
    }

    /* try to get the bt device, available after CK5050 boot up */
    pBtDevice = ERM_GetBTDevice(pUserProfile->deviceIndex);
    if(pBtDevice == NULL)
    {

        DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "HaInitFrS001: no BT-DevT entry, try Phy-DevT for idx %d",
                      profileId);

        /* try to get the phy device, available after ERM EPROM read */
        pPhyDevice  = ERM_pGetPhyDevice(pUserProfile->deviceIndex);

        if( pPhyDevice == NULL )
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaInitFrS001: no dev for UserProfile %d",
                          profileId);

            /* no device available */
            _APP_SD_vCtxHistoryStepBack();
            return SUCCESS;
        }
    }

//    if(pCtxCtrl->s001.abort)
//    {
//        /* user triggered to stop */
//
//
//       _APP_SD_vCtxHistoryStepBack();
//       return SUCCESS;
//    }

    switch(pCtxCtrl->s001.subState)
    {
        case APP_SD_S001_CONNECT_NOT_SENT:
        {
            APP_COMMON_enResponseCode rsp = APP_DEVICE_sfActivatePhoneDevice( pUserProfile->deviceIndex, NULL);
            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "sfHandleInitFrameS001: Act.PhPlDev %d", pUserProfile->deviceIndex);

                switch(rsp)
                {
                    case APP_COMMON_RSP_OK:
                        /* wait for response */
                        pCtxCtrl->s001.subState = APP_SD_S001_CONNECT_SENT;
                        gAppSdContext.connectCounter = 0;
                        break;
                    case APP_COMMON_RSP_ERROR_BUSY:
                        /* try it again later */
                        gAppSdContext.connectCounter += 1;
                        if (gAppSdContext.connectCounter >=10)
                        {
                            APP_DEVICE_vEmergencyReleaseContextFromAppSd();
                            gAppSdContext.connectCounter = 0;
                        }
                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(100),
                                                            0);
                        return SUCCESS;
                    default:

                        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandleInitFrameS001: unexpected error code %x",
                                      rsp);
                        _APP_SD_vCtxHistoryStepBack();
                        return FAIL;
                }
            break;
        }
        default:
            break;
    }


    if(pBtDevice != NULL)
    {
        pCtxCtrl->common.pFrameData->s001.btName_len =
                    (AT_BT_DEVICE_NAME_MAX_LEN < pBtDevice->device_name_len) ?
                     AT_BT_DEVICE_NAME_MAX_LEN : pBtDevice->device_name_len;
        (void)memcpy( pCtxCtrl->common.pFrameData->s001.btName,
                      pBtDevice->device_name,
                      pCtxCtrl->common.pFrameData->s001.btName_len);
    }
    else if(pPhyDevice != NULL)
    {
        pCtxCtrl->common.pFrameData->s001.btName_len =
                    (AT_BT_DEVICE_NAME_MAX_LEN < pPhyDevice->name_len) ?
                     AT_BT_DEVICE_NAME_MAX_LEN : pPhyDevice->name_len;
        (void)memcpy( pCtxCtrl->common.pFrameData->s001.btName,
                      pPhyDevice->name,
                      pCtxCtrl->common.pFrameData->s001.btName_len);
    }

    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                         MSEC(0),
                                         0);

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS_18(AppSdCtxCtrlType *pCtxCtrl)
{
    const ERMBTDeviceTableType *pBtDevice    = NULL;
    const AT_NetworkProvider   *pNetProvider = NULL;
    AppSdFrameDataType          *frameData = pCtxCtrl->common.pFrameData;
    AT_DeviceId                 deviceId = ERM_u8GetActivePhone();

    frameData->common.ctxId = pCtxCtrl->common.ctxId;

    if( deviceId == AT_INVALID_DEVICE_ID)
    {

        DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandleFrameS_18: ERM_u8GetActivePhone failed");
        return FAIL;
    }

    /* ------------------------------- */
    /* set name of current active user */
    pBtDevice = ERM_GetBTDevice(deviceId);
    if(pBtDevice != NULL)
    {
        frameData->s_18.device_name_len =
                    (sizeof(frameData->s_18.device_name) < pBtDevice->device_name_len) ?
                     sizeof(frameData->s_18.device_name) : pBtDevice->device_name_len;
        (void)memcpy( frameData->s_18.device_name,
                pBtDevice->device_name,
                frameData->s_18.device_name_len);
    }
    else
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandleFrameS_18: GetBTDevice failed (device %d)",
                      deviceId);
        frameData->s_18.device_name_len = 0;
    }


    /* ------------------------------- */
    /* set name of network provider    */
    // first check if network is available, if not, show empty Provider and not
    // last saved Provider
    if( 0 != APP_PHONE_GetNetworkAvailable())
    {
        // registered to network so show provider if available
        pNetProvider = APP_PHONE_GetNetworkProvider();
        if(pNetProvider != NULL)
        {
            // add roaming informations before the provider name without space
            // between roaming symbol and provider name -> CR15
            if ( 0 == APP_PHONE_GetRoaming())
            {
                frameData->s_18.netprov_name_len =
                            (sizeof(frameData->s_18.netprov_name) < pNetProvider->name_len) ?
                             sizeof(frameData->s_18.netprov_name) : pNetProvider->name_len;
                (void)memcpy(frameData->s_18.netprov_name,
                             pNetProvider->name,
                             frameData->s_18.netprov_name_len);
            }
            else
            {
                /* roaming is active */
                frameData->s_18.netprov_name_len =
                            (sizeof(frameData->s_18.netprov_name) < (pNetProvider->name_len + COMMON_SYMBOL_LENGTH)) ?
                             sizeof(frameData->s_18.netprov_name) : (pNetProvider->name_len + COMMON_SYMBOL_LENGTH);
                (void)memcpy( frameData->s_18.netprov_name,
                             KPB_ROAMING_SYMBOL,
                             COMMON_SYMBOL_LENGTH);
                (void)memcpy((void *)&frameData->s_18.netprov_name[COMMON_SYMBOL_LENGTH],
                             pNetProvider->name,
                             (frameData->s_18.netprov_name_len - COMMON_SYMBOL_LENGTH));
                DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "sfHandleFrameS_18: Set Roaming information symbol for Network-Provider");
            }
        }
        else
        {

            DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandleFrameS_18: GetNetworkProvider failed");
            frameData->s_18.netprov_name_len = 0;
        }
    }
    else
    {
        // not registered to network, show empty provider
        frameData->s_18.netprov_name_len = 0;
        (void)memcpy( frameData->s_18.netprov_name,
                "",
                0);
    }


    /* ------------------------------- */
    /* set signal strength information */
    if( APP_PHONE_PIEV_INVALID_VALUE != APP_PHONE_GetSignalStrength())
    {
        frameData->s_18.signal_strength_avail   = BT_TRUE;
        frameData->s_18.signal_strength         = APP_PHONE_GetSignalStrength();
    }
    else
    {
        frameData->s_18.signal_strength_avail   = BT_FALSE;
    }

    /* ------------------------------- */
    /* set battery level information   */
    if(APP_PHONE_enGetHfpVersion() == AT_CODPROF_HANDSFREE_1_50 &&
       APP_PHONE_PIEV_INVALID_VALUE != APP_PHONE_GetBatteryLevel() )
    {
        frameData->s_18.battery_level_avail = BT_TRUE;
        frameData->s_18.battery_level       = APP_PHONE_GetBatteryLevel();
    }
    else
    {
        frameData->s_18.battery_level_avail = BT_FALSE;
    }

    pCtxCtrl->common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameSC20(AppSdCtxCtrlType *pCtxCtrl)
{
    const ATRspCallStatValType *plcc = APP_PHONE_AT_PNCC_pGetPlccContext(pCtxCtrl->sc20.plccIndex);

    if(plcc != NULL && plcc->id_avail)
    {
        if(AT_CC_NOT_CONFERENCE == pCtxCtrl->sc20.confState)         // RT #3554
        {
            pCtxCtrl->common.pFrameData->sc20.name_len =
                    _APP_SD_u16WriteCallerId( &(pCtxCtrl->common.pFrameData->sc20.name),
                                              &(plcc->caller_id),
                                              plcc->caller_id_len);

            DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "HdlInitSC20: no conference");
        }
        else
        {
            pCtxCtrl->common.pFrameData->sc20.name_len = gAppSdContext.prompts_len[APP_SD_en_S815_ta_head_conference_1_Zeile_1];

            (void)memcpy(pCtxCtrl->common.pFrameData->sc20.name,
                         gAppSdContext.prompts[APP_SD_en_S815_ta_head_conference_1_Zeile_1],
                         pCtxCtrl->common.pFrameData->sc20.name_len);

            DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "HdlInitSC20: conference");
        }
    }
    else
    {
        if(AT_CC_NOT_CONFERENCE == pCtxCtrl->sc20.confState)
        {
//            pCtxCtrl->common.pFrameData->sc20.name_len =
//                        _APP_SD_u16WriteCallerId( &(pCtxCtrl->common.pFrameData->sc20.name),
//                                                  NULL, 0);
            // the enum can be used from Screen S211, till the special texts for this Screen are generated
            // fix for ticket #3045 (no name matching)
            pCtxCtrl->common.pFrameData->sc20.name_len = gAppSdContext.prompts_len[APP_SD_en_S211_ta_menu_no_nbr_Auswahl_1];

            (void)memcpy(pCtxCtrl->common.pFrameData->sc20.name,
                         gAppSdContext.prompts[APP_SD_en_S211_ta_menu_no_nbr_Auswahl_1],
                         pCtxCtrl->common.pFrameData->sc20.name_len);

            DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "HdlInitSC20: no conference");
        }
        else
        {
            pCtxCtrl->common.pFrameData->sc20.name_len = gAppSdContext.prompts_len[APP_SD_en_S815_ta_head_conference_1_Zeile_1];

            (void)memcpy(pCtxCtrl->common.pFrameData->sc20.name,
                         gAppSdContext.prompts[APP_SD_en_S815_ta_head_conference_1_Zeile_1],
                         pCtxCtrl->common.pFrameData->sc20.name_len);

            DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "HdlInitSC20: conference");
        }
    }

//     if(plcc != NULL && plcc->id_avail)
//     {
//        // check if callerId is number saved for mailbox for active user, if so, show
//        // 'Mailbox' instead of number
//        BooleanType bIsMailboxCall = BT_FALSE;
//        const ERMUserProfileType * profile = ERM_pGetActiveUserProfile();
//        if( NULL != profile )
//        {
//            // compare mailbox number saved for profile with s801 number
//            if(plcc->caller_id_len == profile->voicemailbox_len &&
//               0 == memcmp( profile->voicemailbox, plcc->caller_id, plcc->caller_id_len ))
//            {
//                bIsMailboxCall = BT_TRUE;
//            }
//        }
//
//        if( BT_TRUE == bIsMailboxCall )
//        {   // TODO: Maybe VW wants to show different name for Mailbox
//            // depending on language
//            pCtxCtrl->common.pFrameData->sc20.name_len = strlen("Mailbox");
//            memcpy( pCtxCtrl->common.pFrameData->sc20.name,
//                    "Mailbox",
//                    pCtxCtrl->common.pFrameData->sc20.name_len);
//        }
//        else
//        {
//            /* set the callerId to show in frame*/
//            pCtxCtrl->common.pFrameData->sc20.name_len = plcc->caller_id_len;
//            memcpy( pCtxCtrl->common.pFrameData->sc20.name,
//                    plcc->caller_id,
//                    pCtxCtrl->common.pFrameData->sc20.name_len);
//        }
//     }
//     else
//     {
//         /* set the callerId to show in frame*/
//         /* unknown */
//         pCtxCtrl->common.pFrameData->sc20.name_len = 0;
//     }

     pCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

     (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                         MSEC(0),
                                         0);

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS101(AppSdCtxCtrlType *pCtxCtrl)
{
    /* make sure sms menue is available if init was finished in background */
    if(APP_SMS_INITIALIZED_AND_SUPPORTED == APP_SMS_enGetSmsSupportState() &&
       pCtxCtrl->s101.messagesAvail == BT_FALSE)        // sms menue not yet available
    {   /* sms was not yet shown but is available now */
        pCtxCtrl->common.listData.numListElems++;
        pCtxCtrl->s101.messagesAvail = BT_TRUE;
    }

    pCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);

    return SUCCESS;
}


SuccessFailType _APP_SD_sfHandleInitFrameS102(AppSdCtxCtrlType *pCtxCtrl)
{
    pCtxCtrl->common.pFrameData->s102.numEntries = APP_PHONEBOOK_u16GetPbDlStatus();
    pCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS105(AppSdCtxCtrlType *pCtxCtrl)
{
    APP_COMMON_enResponseCode rspCode = APP_PHONEBOOK_rcRequestCompletePbEntries(
                                             _APP_SD_vInitPendingS105_Cb,
                                             APP_PHONEBOOK_enUsersPB,
                                             pCtxCtrl->s105.pbIndex,
                                             1);

    _APP_SD_vActivateFrame(BT_TRUE, __LINE__);

    switch(rspCode)
    {
        case APP_COMMON_RSP_ERROR_BUSY:
            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                      MSEC(10), 0);
            break;
        case APP_COMMON_RSP_OK:
            // wait for callback being called
            pCtxCtrl->common.state  = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
            break;
        default:

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HdlInitFrS105: err %d, goto Idle", rspCode);
            // SUSANNE: 21.11.2009: InitIdleScreen is called in HandleInitFrame() main function
            // when we return FAIL here
            //_APP_SD_vInitIdleScreen(0);
            return FAIL;
    }


    return SUCCESS;
}


//SuccessFailType _APP_SD_sfHandleInitFrameS111(AppSdCtxCtrlType *pCtxCtrl)
//{
//
//    APP_COMMON_enResponseCode rspCode = APP_PHONEBOOK_rcRequestCompletePbEntries(
//                                             _APP_SD_vInitPendingS111_Cb,
//                                             APP_PHONEBOOK_enUsersPB,
//                                             pCtxCtrl->s111.pbIndex,
//                                             1);
//    switch(rspCode)
//    {
//        case APP_COMMON_RSP_ERROR_BUSY:
//            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
//                                                      MSEC(10), 0);
//            break;
//        case APP_COMMON_RSP_OK:
//            // wait for callback being called
//            pCtxCtrl->common.state = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
//            break;
//        default:
//
//            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HdlInitFrS111: err %d, goto Idle", rspCode);
//            // SUSANNE: 21.11.2009: InitIdleScreen is called in HandleInitFrame() main function
//            // when we return FAIL here
//            //_APP_SD_vInitIdleScreen(0);
//            return FAIL;
//    }
//
//    return SUCCESS;
//}

SuccessFailType _APP_SD_sfHandleInitFrameS115(AppSdCtxCtrlType *pCtxCtrl)
{

    if(BT_TRUE == pCtxCtrl->s115.deletePressed)
    {

        DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "HdlInitS115: voice tag deleted");

        _APP_SD_vInitFrameS114(pCtxCtrl->s115.pbIndex);

        return SUCCESS;
    }

    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
    return SUCCESS;
}


SuccessFailType _APP_SD_sfHandleInitFrameS117(AppSdCtxCtrlType *pCtxCtrl)
{
    APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_OK;


    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "HdlInitS117: subState %d", pCtxCtrl->s117.subState);

    switch(pCtxCtrl->s117.subState)
    {
        case APP_SD_S117_REQUEST_CONTACT_INFO_NOT_SENT:
            rspCode = APP_PHONEBOOK_rcRequestCompletePbEntries(
                                             _APP_SD_vInitPendingS117_Cb,
                                             APP_PHONEBOOK_enUsersPB,
                                             pCtxCtrl->s117.pbIndex,
                                             1);
            // check rsp code
            switch(rspCode)
            {
                case APP_COMMON_RSP_ERROR_BUSY:
                {   // try again later
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    //return SUCCESS;
                    break;      // avoid unreachable statement (break) at end of switch/case
                }
                case APP_COMMON_RSP_OK:
                {
                    // sent request was successful
                    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
                    pCtxCtrl->s117.subState = APP_SD_S117_REQUEST_CONTACT_INFO_SENT;
                    //return SUCCESS;
                    break;      // avoid unreachable statement (break) at end of switch/case
                }
                default:

                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HdlInitS117: err state %d", pCtxCtrl->s117.subState);
                    // #4365: to avoid sd freeze we need to return FAIL here, instead we would return SUCCESS
                    return FAIL;
            }
            //break;
            return SUCCESS;     // to have same behaviour as with the prior returns ( BUSY and OK ), return here

        case APP_SD_S117_REQUEST_VOICE_TAG_NUMBER_NOT_SENT:
            rspCode = APP_PHONEBOOK_rcRequestNumVoiceTagsForContact(_APP_SD_vInitPendingS117_Cb,
                                                                    pCtxCtrl->s117.pbIndex);

            // check rsp code
            switch(rspCode)
            {
                case APP_COMMON_RSP_ERROR_BUSY:
                {   // try again later
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(10), 0);
                    //return SUCCESS;
                    break;      // avoid unreachable statement (break) at end of switch/case
                }
                case APP_COMMON_RSP_OK:
                {
                    // sent request was successful
                    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
                    pCtxCtrl->s117.subState = APP_SD_S117_REQUEST_VOICE_TAG_NUMBER_SENT;
                    //return SUCCESS;
                    break;      // avoid unreachable statement (break) at end of switch/case
                }
                default:

                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HdlInitS117: err state %d", pCtxCtrl->s117.subState);
                    // #4365: to avoid sd freeze we need to return FAIL here, instead we would return SUCCESS
                    return FAIL;
            }
            //break;
            return SUCCESS;     // to have same behaviour as with the prior returns ( BUSY and OK ), return here

        case APP_SD_S117_REQUEST_VOICE_TAG_NUMBER_SENT:
            pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
            // reset subState so we process the whole stuff again when e.g. step back to S117 is performed
            pCtxCtrl->s117.subState = APP_SD_S117_REQUEST_CONTACT_INFO_NOT_SENT;
            (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FCT_PENDING,
                                                     MSEC(0),
                                                     0);
            break;

        default:

            DEBUG_VALUE1( APP_SD_SWI_WNG, MOD_APP_SD, "HdlInitS117: unsup substate %d",
                         pCtxCtrl->s117.subState);
            return FAIL;
    }
    return SUCCESS;
}



SuccessFailType _APP_SD_sfHandleInitFrameS211(AppSdCtxCtrlType *pCtxCtrl)
{
    APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

    switch(pCtxCtrl->s211.pbType)
    {
        case APP_PHONEBOOK_enLastDialed:
            txtId = APP_SD_en_S211_ta_head_stack_dialled_1_Zeile_1;
            break;
        case APP_PHONEBOOK_enReceivedCalls:
            txtId = APP_SD_en_S211_ta_head_stack_received_1_Zeile_1;
            break;
        case APP_PHONEBOOK_enMissedCalls:
            txtId = APP_SD_en_S211_ta_head_stack_missed_1_Zeile_1;
            break;
        default:
            txtId = APP_SD_enError;
            break;
    }

    pCtxCtrl->common.pFrameData->s211.headline_len = gAppSdContext.prompts_len[txtId];

    if(pCtxCtrl->common.pFrameData->s211.headline_len >
        sizeof(pCtxCtrl->common.pFrameData->s211.headline) )
    {
        pCtxCtrl->common.pFrameData->s211.headline_len =
                sizeof(pCtxCtrl->common.pFrameData->s211.headline);
    }

    (void)memcpy( pCtxCtrl->common.pFrameData->s211.headline,
            gAppSdContext.prompts[txtId],
            pCtxCtrl->common.pFrameData->s211.headline_len);

    pCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS212(AppSdCtxCtrlType *pCtxCtrl)
{
    APP_COMMON_enResponseCode rspCode = APP_PHONEBOOK_rcRequestCompletePbEntries(
                                             _APP_SD_vInitPendingS212_Cb,
                                             pCtxCtrl->s212.pbType,
                                             pCtxCtrl->s212.pbIndex,
                                             1);
    switch(rspCode)
    {
        case APP_COMMON_RSP_ERROR_BUSY:
            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                      MSEC(10), 0);
            break;
        case APP_COMMON_RSP_OK:
            // wait for callback being called
            pCtxCtrl->common.state = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
            break;
        default:

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HdlInitFrS212: err %d, goto Idle",
                          rspCode);
            // SUSANNE: 21.11.2009: InitIdleScreen is called in HandleInitFrame() main function
            // when we return FAIL here
            //_APP_SD_vInitIdleScreen(0);
            return FAIL;
    }
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS213(AppSdCtxCtrlType *pCtxCtrl)
{
    APP_COMMON_enResponseCode rspCode = APP_SMS_rcReadSmsPreview(
                                             _APP_SD_vInitPendingS213_Cb,
                                             pCtxCtrl->s213.smsIndex,
                                             1);
    switch(rspCode)
    {
        case APP_COMMON_RSP_ERROR_BUSY:
            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                      MSEC(10), 0);
            break;
        case APP_COMMON_RSP_OK:
            // wait for callback being called
            pCtxCtrl->common.state = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
            break;
        default:

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HdlInitFrS213: err %d, goto Idle",
                          rspCode);
            // SUSANNE: 21.11.2009: InitIdleScreen is called in HandleInitFrame() main function
            // when we return FAIL here
            //_APP_SD_vInitIdleScreen(0);
            return FAIL;
    }
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS305(AppSdCtxCtrlType *pCtxCtrl)
{
    APP_SD_SC_vReadSelectionText( &(pCtxCtrl->s305.spellerCtrl),
                                  &(pCtxCtrl->common.pFrameData->s305.selectedText));

    APP_SD_SC_vReadSpelledText( &(pCtxCtrl->s305.spellerCtrl),
                                &(pCtxCtrl->common.pFrameData->s305.spelledText));


    pCtxCtrl->common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS306(AppSdCtxCtrlType *pCtxCtrl)
{
    /* per default, show frame when leaving this function. */
    /* if we start a search or request a pb entry, this shall be set to FALSE to
     * avoid sending of the frame */
    BooleanType bShowFrame = BT_TRUE;


    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "HdlInitS306: state %d",
                  pCtxCtrl->s306.subState);

    // check whether we need to search the phonebook
    switch(pCtxCtrl->s306.subState)
    {
        case APP_SD_S306_SEARCH_MAILBOX_NUMBER_NOT_SENT:
        {
            // first check if curKeywordIdx is valid to avoid segmentation fault
            if( NULL != pCtxCtrl->s306.curKeywordArray &&
                pCtxCtrl->s306.curKeywordIdx < MAX_MBOX_KEYWORDS_PER_LANGUAGE)
            {
                APP_COMMON_enResponseCode rsp = APP_COMMON_RSP_OK;

                // set keyword and len depending on language
                const Uint8Type * keyword = pCtxCtrl->s306.curKeywordArray[pCtxCtrl->s306.curKeywordIdx].pu8PromptsToDisplay;
                Uint16Type len            = pCtxCtrl->s306.curKeywordArray[pCtxCtrl->s306.curKeywordIdx].u16LengthOfPrompt;


                DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HdlInitS306: try search mbox");

                // check current values
                if( NULL != keyword && 0 != len )
                {
                    // don't show frame cause of search
                    bShowFrame = BT_FALSE;
                    // valid keyword, start search
                    rsp = APP_PHONEBOOK_rcRequestPbSearch(_APP_SD_vInitPendingS306_Cb, keyword, len);

                    // check rsp code
                    switch( rsp)
                    {
                        case APP_COMMON_RSP_ERROR_BUSY:
                        {   // try again later
                            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                MSEC(10),
                                                                0);
                            return SUCCESS;
                        }
                        case APP_COMMON_RSP_OK:
                        {
                            // sent request was successful

                            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "HdlInitS306: search mbox sent ok (%d)",
                                          pCtxCtrl->s306.curKeywordIdx);
                            pCtxCtrl->s306.subState = APP_SD_S306_SEARCH_MAILBOX_NUMBER_SENT;;
                            pCtxCtrl->common.state  = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
                            return SUCCESS;
                        }
                        default:
                        {
                            /* error, show frame without mbox number */

                            DEBUG_VALUE2( APP_SD_SWI_TRC, MOD_APP_SD, "HdlInitS306: search mbox sent err %d (%d)",
                                          rsp, pCtxCtrl->s306.curKeywordIdx);
                            bShowFrame = BT_TRUE;
                            break;
                        }
                    }
                }
                else
                {

                    DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HdlInitS306: no valid keyword");
                }
            }
            break;
        }
        case APP_SD_S306_REQUEST_FOUND_ENTRY_NOT_SENT:
        {
            APP_COMMON_enResponseCode rsp = APP_COMMON_RSP_OK;

            // don't show frame cause of pb request
            bShowFrame = BT_FALSE;


            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HdlInitS306: req mbox number");

            // request found pb entry to get number
            rsp = APP_PHONEBOOK_rcRequestCompletePbEntries(_APP_SD_vInitPendingS306_Cb,
                                                           APP_PHONEBOOK_enUsersPB,
                                                           pCtxCtrl->s306.entryToBeRequested, 1);
            // check rsp code
            switch(rsp)
            {
                case APP_COMMON_RSP_ERROR_BUSY:

                {   // try again later
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(10),
                                                        0);
                    return SUCCESS;
                }
                case APP_COMMON_RSP_OK:
                {
                    // sent request was successful

                    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "HdlInitS306: req pb idx ok (%d)",
                                  pCtxCtrl->s306.entryToBeRequested);
                    pCtxCtrl->s306.subState = APP_SD_S306_REQUEST_FOUND_ENTRY_SENT;
                    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
                    return SUCCESS;
                }
                default:
                {
                    /* error */

                    DEBUG_VALUE2( APP_SD_SWI_TRC, MOD_APP_SD, "HdlInitS306:req pb idx err %d (%d)",
                                  rsp, pCtxCtrl->s306.entryToBeRequested);
                    bShowFrame = BT_TRUE;
                    break;
                }
            }
            break;
        }
        case APP_SD_S306_SEARCH_MAILBOX_NUMBER_SENT:
        case APP_SD_S306_REQUEST_FOUND_ENTRY_SENT:
        case APP_SD_S306_SHOW_FRAME:
        default:
            /* frame will be shown due to default value of bShowFrame */
            bShowFrame = BT_TRUE;
            break;
    }

    if( BT_TRUE == bShowFrame )
    {

        DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HdlInitS306: show Frame");
        APP_SD_SC_vReadSelectionText( &(pCtxCtrl->s306.spellerCtrl),
                                  &(pCtxCtrl->common.pFrameData->s306.selectedText));

        APP_SD_SC_vReadSpelledText(&(pCtxCtrl->s306.spellerCtrl),
                                   &(pCtxCtrl->common.pFrameData->s306.spelledText));

        pCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;
        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                            MSEC(0),
                                            0);
    }


    return SUCCESS;
}


SuccessFailType _APP_SD_sfHandleInitFrameS406(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s406.subState)
    {
        case APP_SD_S406_SMS_NOT_REQUESTED:
        {
            APP_COMMON_enResponseCode rspCode = APP_SMS_rcReadSms(
                                                     _APP_SD_vInitPendingS406_Msg_Cb,
                                                     pCtxCtrl->s406.smsIndex,
                                                     1);
            switch(rspCode)
            {
                case APP_COMMON_RSP_ERROR_BUSY:
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                              MSEC(10), 0);
                    break;
                case APP_COMMON_RSP_OK:
                    // wait for callback being called
                    pCtxCtrl->s406.subState = APP_SD_S406_SMS_REQUESTED;
                    pCtxCtrl->common.state = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
                    break;
                default:

                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HdlInitFrS406: err %d, goto Idle",
                                  rspCode);
                    // SUSANNE: 21.11.2009: InitIdleScreen is called in HandleInitFrame() main function
                    // when we return FAIL here
                    //_APP_SD_vInitIdleScreen(0);
                    return FAIL;
            }
            break;
        }

        case APP_SD_S406_MARK_AS_READ_NOT_REQUESTED:
        {
            APP_COMMON_enResponseCode rspCode = APP_SMS_rcMarkAsRead(
                                                _APP_SD_vInitPendingS406_MarkAsRead_Cb,
                                                pCtxCtrl->s406.smsIndex);
            switch(rspCode)
            {
                case APP_COMMON_RSP_ERROR_BUSY:
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                              MSEC(10), 0);
                    break;
                case APP_COMMON_RSP_OK:
                    // wait for callback being called
                    pCtxCtrl->s406.subState = APP_SD_S406_SMS_REQUESTED;
                    pCtxCtrl->common.state = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
                    break;
                default:

                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HdlInitFrS406: err %d, goto Idle(2)",
                                  rspCode);
                    // SUSANNE: 21.11.2009: InitIdleScreen is called in HandleInitFrame() main function
                    // when we return FAIL here
                    //_APP_SD_vInitIdleScreen(0);
                    return FAIL;
            }
            break;
        }
        case APP_SD_S406_SMS_REQUESTED:
        {
            /* this state should only be reached after history step back or reinit */
            if(pCtxCtrl->s406.smsType == AT_SMS_TYPE_READ)
            {
                pCtxCtrl->s406.subState = APP_SD_S406_SMS_NOT_REQUESTED;
                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                    MSEC(0),
                                                    0);
            }
            else
            {
                Uint16Type numSms = APP_SMS_u16GetNumReadSms() +
                                    APP_SMS_u16GetNumUnreadSms();


                DEBUG_VALUE1( APP_SD_SWI_WNG, MOD_APP_SD, "HdlInitS406: reinit unavail for type %d",
                             pCtxCtrl->s406.smsType);

                if( numSms > 0 )
                {
                    _APP_SD_vInitFrameS404(numSms);
                }
                else
                {
                    _APP_SD_vInitIdleScreen(0);
                }
            }
            break;
        }
        default:

            DEBUG_VALUE1( APP_SD_SWI_WNG, MOD_APP_SD, "HdlInitS406: unsup substate %d",
                         pCtxCtrl->s406.subState);
            return FAIL;
    }

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS407(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s407.subState)
    {
        case APP_SD_S407_STOP_BT_SEARCH_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = ERM_rcCancelInquiry(_APP_SD_vInitPendingS407_Cb);

            if( rspCode == APP_COMMON_RSP_ERROR_BUSY )
            {
                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                    MSEC(10),
                                                    0);
                return SUCCESS;
            }


            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HdlInitS407: stopped inq.");
            pCtxCtrl->s407.subState = APP_SD_S407_STOP_BT_SEARCH_SENT;
            pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                       MSEC(0),
                                                       0);
            break;
        }
        case APP_SD_S407_STOP_BT_SEARCH_SKIPPED:
            // immediately show frame

            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HdlInitS407: skip stop inq.");
            pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                       MSEC(0),
                                                       0);
            break;


        default:

            DEBUG_VALUE1( APP_SD_SWI_WNG, MOD_APP_SD, "HdlInitS407: unsup substate %d",
                          pCtxCtrl->s407.subState);
            return FAIL;
    }

    APP_MDI_bUnmutePlayer(APP_MDI_MUTE_DEVICE_SEARCH, UNMUTE_IMMEDIATELY);
//    if((gAppSdContext.lastConnectionDevice.playerState == APP_SD_MDI_PLAY) &&
//       (APP_MDI_GetPlayStatus() != APP_MDI_ACT_STATE_PLAY))
//    {
//        (void)APP_MDI_sfSetPlayMode(APP_MDI_RESUME);
////
//        DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HdlInitS407: resume player");
//    }
//
//    gAppSdContext.lastConnectionDevice.playerState = APP_SD_MDI_STOP;


    return SUCCESS;
}





SuccessFailType _APP_SD_sfHandleInitFrameS405(AppSdCtxCtrlType *pCtxCtrl)
{

    APP_COMMON_enResponseCode rspCode = APP_SMS_rcReadSmsPreview(
                                             _APP_SD_vInitPendingS405_Cb,
                                             pCtxCtrl->s405.smsIndex,
                                             1);

    switch(rspCode)
    {
        case APP_COMMON_RSP_ERROR_BUSY:
            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                    MSEC(10), 0);
            break;
        case APP_COMMON_RSP_OK:
            // wait for data
            pCtxCtrl->common.state  = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
            break;
        default:

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HdlInitFrS405: err %d, goto Idle", rspCode);
            // SUSANNE: 21.11.2009: InitIdleScreen is called in HandleInitFrame() main function
            // when we return FAIL here
            //_APP_SD_vInitIdleScreen(0);
            return FAIL;
    }

    return SUCCESS;
}


SuccessFailType _APP_SD_sfHandleInitFrameS408(AppSdCtxCtrlType *pCtxCtrl)
{

    DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD,"_APP_SD_sfHandleInitFrameS408 called with $APP_SD_enSubStateS408$ = %d ",pCtxCtrl->s408.subState);
    switch(pCtxCtrl->s408.subState)
    {
        case APP_SD_S408_WAIT_FOR_SERVICE_SUPPORT_CHANGED:
            /* not yet received it, so just show Frame again */
            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HdlInitS408: show");
            pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
            (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FCT_PENDING, MSEC(0), 0);
            break;
        case APP_SD_S408_RECEIVED_SERVICE_SUPPORT_CHANGED:
            /* service support changed notification has been received in background
               now handle it */
            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HdlInitS408: recvd. serv. supp. changd.");
            _APP_SD_sfHandleErmNotificationServiceSupportChanged();
            break;
        case APP_SD_S408_RECEIVED_PAIRING_FAILED:
            /* pairing failed, handle it */
            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HdlInitS408: recvd. pairing failed");
            _APP_SD_sfHandleErmNotificationPairingFailed();
            break;
        case APP_SD_S408_NOT_SEND_SSP_SUPPORT:
        {
            APP_COMMON_enResponseCode respCode = APP_COMMON_RSP_OK;
            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "_APP_SD_sfHandleInitFrameS408: send request for SSP support.");
            respCode = ERM_rcSendSSPSupportedRequest(pCtxCtrl->s408.deviceId, _APP_SD_vInitPendingS408_Cb);
            switch (respCode)
            {
                case APP_COMMON_RSP_OK:
                    DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "_APP_SD_sfHandleInitFrameS408: SSP support sent -> next state wait for response.");
                    pCtxCtrl->s408.subState = APP_SD_S408_WAIT_FOR_SSP_SUPPORT;
                    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FCT_PENDING, MSEC(0), 0);
                    break;
                case APP_COMMON_RSP_ERROR_BUSY:
                    DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "_APP_SD_sfHandleInitFrameS408: retry send request for SSP support.");
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FCT_PENDING, MSEC(100), 0);
                default:
                    if (BT_FALSE == _APP_SD_bPhoneContextActive())
                    {
                        _APP_SD_vReleasePhoneContext();
                    }
                    else
                    {
                        _APP_SD_vInitFrameS521();
                    }
                    break;
            }
            break;
        }
        case APP_SD_S408_WAIT_FOR_SSP_SUPPORT:
            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "_APP_SD_sfHandleInitFrameS408: waiting for PBSF.");
            break;
        case APP_SD_S408_RECEIVED_SSP_SUPPORT:
            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "_APP_SD_sfHandleInitFrameS408: PBSF received.");
            pCtxCtrl->s408.retryCounter++;
            if (AT_BT_FEAT_UNKNOWN == pCtxCtrl->s408.sspSupported )
            {
                if (0x03 <= pCtxCtrl->s408.retryCounter)
                {
                    _APP_SD_vInitFrameS51D(pCtxCtrl->s408.deviceId,pCtxCtrl->s408.deviceType);
                }
                else
                {
                    /* retry with sending the PBSF request */
                    pCtxCtrl->s408.subState = APP_SD_S408_NOT_SEND_SSP_SUPPORT;
                    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FCT_PENDING, MSEC(100), 0);
                }
            }
            else
            {
                _APP_SD_vReleasePendingContext(__LINE__);
                if (AT_BT_FEAT_SUPPORTED == pCtxCtrl->s408.sspSupported )
                {
                    _APP_SD_bSSPInitiatePairingAfterInquiry(pCtxCtrl->s408.deviceId,_APP_SD_vInitPendingS408_Cb);
                }
                else
                {
                    _APP_SD_vInitFrameS51D(pCtxCtrl->s408.deviceId,pCtxCtrl->s408.deviceType);
                }
            }
            break;
        default:
            return FAIL;
    }

    return SUCCESS;
}

//*****************************************************
// Bluetooth User Handling
//*****************************************************
SuccessFailType _APP_SD_sfHandleInitFrameS513(AppSdCtxCtrlType *pCtxCtrl)
{
    // set bt device name
    const ERMBTDeviceTableType *devInfo = ERM_GetBTDevice(pCtxCtrl->s513.deviceId);

    if( NULL == devInfo )
    {
        if(pCtxCtrl->s513.deletePressed == BT_TRUE)
        {
            /* if the device is not available anymore and the we sent delete, it seems
               that the device was deleted */

            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "HaInitFrS513: dev %d deleted",
                          pCtxCtrl->s513.deviceId);

            _APP_SD_vInitFrameS514( gAppSdContext.pCurCtxCtrl->s513.deviceId,
                                    BT_FALSE,
                                    gAppSdContext.pCurCtxCtrl->s513.btName,
                                    gAppSdContext.pCurCtxCtrl->s513.btName_len);

            return SUCCESS;
        }
        else
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaInitFrS513: dev %d not avail",
                          pCtxCtrl->s513.deviceId);
            return FAIL;
        }
    }

    pCtxCtrl->common.pFrameData->s513.btName_len =
                (AT_BT_DEVICE_NAME_MAX_LEN < devInfo->device_name_len) ?
                 AT_BT_DEVICE_NAME_MAX_LEN : devInfo->device_name_len;
    (void)memcpy(pCtxCtrl->common.pFrameData->s513.btName,
           devInfo->device_name,
           pCtxCtrl->common.pFrameData->s513.btName_len );

    // copy btName into current ctx, needed for S514
    pCtxCtrl->s513.btName_len =
                (AT_BT_DEVICE_NAME_MAX_LEN < devInfo->device_name_len) ?
                 AT_BT_DEVICE_NAME_MAX_LEN : devInfo->device_name_len;
    (void)memcpy(pCtxCtrl->s513.btName,
           devInfo->device_name,
           pCtxCtrl->s513.btName_len);

    gAppSdContext.s408DelDeviceNameLength = (AT_BT_DEVICE_NAME_MAX_LEN < devInfo->device_name_len) ?
                                             AT_BT_DEVICE_NAME_MAX_LEN : devInfo->device_name_len;

    (void)memcpy(gAppSdContext.s408DelDeviceName, devInfo->device_name, gAppSdContext.s408DelDeviceNameLength);

    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS514(AppSdCtxCtrlType *pCtxCtrl)
{
    // set bt device name into frame data buffer
    pCtxCtrl->common.pFrameData->s514.btName_len =
                (AT_BT_DEVICE_NAME_MAX_LEN < pCtxCtrl->s514.btName_len) ?
                 AT_BT_DEVICE_NAME_MAX_LEN : pCtxCtrl->s514.btName_len;
    (void)memcpy(pCtxCtrl->common.pFrameData->s514.btName,
            pCtxCtrl->s514.btName,
            pCtxCtrl->common.pFrameData->s514.btName_len);

    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS517(AppSdCtxCtrlType *pCtxCtrl)
{

    ERM_vSetDisconnectWillFollow(BT_FALSE);
    DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "HandleInitFrameS517: Substate $APP_SD_enSubStateS517$ = %d",pCtxCtrl->s517.subState);

    switch(pCtxCtrl->s517.subState)
    {
        case APP_SD_S517_START_SERIVCE_NOT_SENT:
        {
            APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_ERROR;
            switch( pCtxCtrl->s517.deviceType )
            {
                case APP_DEVICE_enTYPE_PHONE:
                    DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "activatePhoneDevice S517");
                    rspCode = APP_DEVICE_sfActivatePhoneDevice(pCtxCtrl->s517.deviceId,
                                                           _APP_SD_vInitPendingS517_Cb);
                    break;
                case APP_DEVICE_enTYPE_PLAYER:
                    rspCode = APP_DEVICE_rcActivateMdiDevice(_APP_SD_vInitPendingS517_Cb, pCtxCtrl->s517.deviceId);
                    break;
                case APP_DEVICE_enTYPE_HEADSET:
                    rspCode = ERM_rcStartHeadsetService(pCtxCtrl->s517.deviceId,
                                                          _APP_SD_vInitPendingS517_Cb);
                    break;
                default:
                    {

                        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HandleInitFrameS517: deviceType %d out of range",
                                      pCtxCtrl->s517.deviceType);
                        break;
                    }
            }

            if( rspCode == APP_COMMON_RSP_ERROR_BUSY )
            {

                gAppSdContext.connectCounter += 1;
                if (gAppSdContext.connectCounter >=10)
                {
                    DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "sfHandleInitFrameS517: APP_DEVICE_EmegencyRelease");
                    APP_DEVICE_vEmergencyReleaseContextFromAppSd();
                    gAppSdContext.connectCounter = 0;
                }
                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                            MSEC(1000),
                                            0);
                return SUCCESS;
            }
            gAppSdContext.connectCounter = 0;
            pCtxCtrl->s517.subState = APP_SD_S517_START_SERIVCE_SENT;
            pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FCT_PENDING,
                                              MSEC(0),
                                              0);
            break;
        }
        default:
        {
            pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
            if (gAppSdContext.connectCounter2 >=10)
            {
                DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "sfHandleInitFrameS517: connectCounter2 >=10  counter stop.");
                gAppSdContext.connectCounter2 = 0;
            }
            else
            {
                gAppSdContext.connectCounter2 += 1;
                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                    MSEC(100),
                                                    0);
            }
            break;
        }
    }

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS51D(AppSdCtxCtrlType *pCtxCtrl)
{
    APP_SD_SC_vReadSelectionText( &(pCtxCtrl->s51D.spellerCtrl),
                                  &(pCtxCtrl->common.pFrameData->s51D.selectedText));

    APP_SD_SC_vReadSpelledText( &(pCtxCtrl->s51D.spellerCtrl),
                                &(pCtxCtrl->common.pFrameData->s51D.spelledText));


    pCtxCtrl->common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);

    return SUCCESS;
}


SuccessFailType _APP_SD_sfHandleInitFrameS520(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s520.subState)
    {
        case APP_SD_S520_START_INQUIRY_NOT_SENT:
        {
            // start inquiry
            APP_COMMON_enResponseCode rspCode = ERM_rcStartInquiry( _APP_SD_vInitPendingS520_Cb);

            switch(rspCode)
            {
                case APP_COMMON_RSP_ERROR_BUSY:
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                              MSEC(10), 0);
                    break;
                case APP_COMMON_RSP_OK:
                    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
                    break;
                default:

                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HdlInitFrS520: err %d, goto Idle", rspCode);
                    // SUSANNE: 21.11.2009: InitIdleScreen is called in HandleInitFrame() main function
                    // when we return FAIL here
                    //_APP_SD_vInitIdleScreen(0);
                    return FAIL;
            }
            break;
        }
        case APP_SD_S520_START_INQUIRY_SENT:
            //RS: we received an inquiry end but were hide by a popup, so handle the
            //    inquiry end event now
            if( pCtxCtrl->s520.inquiryEndRcvd == BT_TRUE )
            {

                DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "HaInitFrameS520: call sfHaErmNotInqEnd");

                if(_APP_SD_sfHandleErmNotificationInquiryEnd() != SUCCESS)
                {
                    //RS: that should never happen

                    DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "HaInitFrameS520: sfHaErmNotInqEnd failed!");

                    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                              MSEC(0),
                                                              0);
                }
            }
            else
            {
                pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                          MSEC(0),
                                                          0);
            }
            break;
        case APP_SD_S520_SHOW_ONLY:
        default:
            pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
    }

    return SUCCESS;
}


//// added the HandleInitFrame to process the busy response from the MDI application.
//SuccessFailType _APP_SD_sfHandleInitFrameS522(AppSdCtxCtrlType *pCtxCtrl)
//{
//    switch(pCtxCtrl->s522.subState)
//    {
//        case APP_SD_S522_PAUSE_STATE_NOT_SENT:
//        {
//            // start inquiry
//            //(void)APP_MDI_sfSetPlayMode(APP_MDI_PAUSE);
//            APP_MDI_bMutePlayer(pCtxCtrl->s522.unMuteReason);
//
//            gAppSdContext.lastConnectionDevice.playerState = APP_SD_MDI_PLAY;
//            /* !!!!!! no break here because play state is set cancell alarm */
//            pCtxCtrl->s522.subState = APP_SD_S522_PAUSE_STATE_SENT;
//        }
//        case APP_SD_S522_PAUSE_STATE_SENT:
//        default:
//            pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
//            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
//                                                MSEC(0),
//                                                0);
//            break;
//    }
//
//    return SUCCESS;
//}
SuccessFailType _APP_SD_sfHandleInitFrameS52C(AppSdCtxCtrlType *pCtxCtrl)
{
    const ERMSspReqType *pSspReq = ERM_pGetSspRequest();

//    APP_SD_SC_vReadSelectionText( &(pCtxCtrl->s52C.spellerCtrl),
//            &(pCtxCtrl->common.pFrameData->s52C.selectedText));

    /* prepare frame */
    memcpy(pCtxCtrl->common.pFrameData->s52C.aucPinData, pSspReq->passphrase, sizeof(pSspReq->passphrase));

    pCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS534(AppSdCtxCtrlType *pCtxCtrl)
{
    // get bt device name
    const ERMBTDeviceTableType *devInfo = ERM_GetBTDevice(pCtxCtrl->s534.deviceId);

    if( NULL == devInfo )
    {
        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HandleInitFrameS534: dev %d not avail", pCtxCtrl->s534.deviceId);
        return FAIL;
    }


    switch(pCtxCtrl->s534.subState)
    {
        case APP_SD_S534_WAIT_FOR_TIMEOUT:
            pCtxCtrl->common.pFrameData->s534.btName_len = (AT_BT_DEVICE_NAME_MAX_LEN < devInfo->device_name_len) ?
                                                                AT_BT_DEVICE_NAME_MAX_LEN : devInfo->device_name_len;
            (void)memcpy(pCtxCtrl->common.pFrameData->s534.btName, devInfo->device_name, pCtxCtrl->common.pFrameData->s534.btName_len);
            pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        case APP_SD_S534_ADD_NEW_PROFILE_NOT_SENT:
        {   /* finally add the new profile depending on device type */
            APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_OK;

            rspCode = APP_DEVICE_rcAddUserProfile(_APP_SD_AddUserProfile_Cb, pCtxCtrl->s534.deviceId, devInfo->device_name, devInfo->device_name_len);

            switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                {
                    /* wait for response */

                    // Show S534 until we get feedback from EEPROM, that
                    // user profile was successfully saved!!!!!!!
                    gAppSdContext.addProfileCounter = 0;
                    pCtxCtrl->s534.subState = APP_SD_S534_ADD_NEW_PROFILE_SENT;
                    break;
                }
                case APP_COMMON_RSP_ERROR_BUSY:
                {
                    /* try again later */
                    gAppSdContext.addProfileCounter++;
                    if (gAppSdContext.addProfileCounter >=10)
                    {
                        APP_DEVICE_vEmergencyReleaseContextFromAppSd();
                        gAppSdContext.addProfileCounter = 0;
                    }
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(100), 0);
                    break;
                }
                default:
                {
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "S534: Request failed (%d), ADD_NEW_PROFILE",
                                  rspCode);
                    (void) _APP_SD_vReleasePendingContext(__LINE__);
                    return FAIL;
                }
            }
            break;
        }
        case APP_SD_S534_ADD_PLAYER_PROFILE_NOT_SENT:
        {
            /* Create PlayerProfile */
            APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_OK;

            rspCode = APP_DEVICE_rcAddPlayerProfile(_APP_SD_AddPlayerProfile_Cb,
                                                    pCtxCtrl->s534.deviceId,
                                                    devInfo->device_name,
                                                    devInfo->device_name_len);
            switch( rspCode )
            {
                case APP_COMMON_RSP_OK:
                {
                    /* wait for response */
                    gAppSdContext.addProfileCounter = 0;
                    pCtxCtrl->s534.subState = APP_SD_S534_ADD_PLAYER_PROFILE_SENT;
                    break;
                }
                case APP_COMMON_RSP_ERROR_BUSY:
                {
                    /* try again later */
                    gAppSdContext.addProfileCounter++;
                    if (gAppSdContext.addProfileCounter >=10)
                    {
                        APP_DEVICE_vEmergencyReleaseContextFromAppSd();
                        gAppSdContext.addProfileCounter = 0;
                    }
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(100), 0);
                    break;
                }
                default:
                {
                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD,"S534: AddPly failed. res %d",
                                  rspCode);
                    // no return FAIL needed cause state is changed at end of function and frame
                    // is sent out anyway
                    pCtxCtrl->s534.subState = APP_SD_S534_ADD_PLAYER_PROFILE_SENT;
                    break;
                }
            }
            break;
        }
        case APP_SD_S534_ADD_PLAYER_PROFILE_SENT:
        {
            if(pCtxCtrl->s534.addPlayerCbRcvd == BT_TRUE)
            {
                _APP_SD_vInitIdleScreen(0);
            }
            else
            {
                DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "S534: wait for add player callback");
            }
            break;
        }
        default:
            break;
    }


    return SUCCESS;
}

//SuccessFailType _APP_SD_sfHandleInitFrameS535(AppSdCtxCtrlType *pCtxCtrl)
//{
//    AppSdScSpellerCtrlType *pSpellerCtrl = &(pCtxCtrl->s535.spellerCtrl);
//    APP_SD_SC_vReadSelectionText( pSpellerCtrl, &(pCtxCtrl->common.pFrameData->s535.selectedText));
//
//    APP_SD_SC_vReadSpelledText( pSpellerCtrl, &(pCtxCtrl->common.pFrameData->s535.spelledText));
//
//    pCtxCtrl->common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;
//
//    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
//                                        MSEC(0),
//                                        0);
//    return SUCCESS;
//}

SuccessFailType _APP_SD_sfHandleInitFrameS536(AppSdCtxCtrlType *pCtxCtrl)
{
    AppSdScSpellerCtrlType *pSpellerCtrl = &(pCtxCtrl->s536.spellerCtrl);
    APP_SD_SC_vReadSelectionText( pSpellerCtrl, &(pCtxCtrl->common.pFrameData->s536.selectedText));

    APP_SD_SC_vReadSpelledText( pSpellerCtrl, &(pCtxCtrl->common.pFrameData->s536.spelledText));


    pCtxCtrl->common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS542(AppSdCtxCtrlType *pCtxCtrl)
{
    // set bt device name
    const ERMBTDeviceTableType *devInfo = ERM_GetBTDevice(pCtxCtrl->s542.deviceId);

    if( NULL == devInfo )
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HandleInitFrameS542: dev %d not avail",
                        pCtxCtrl->s542.deviceId);
        return FAIL;
    }

    pCtxCtrl->common.pFrameData->s542.btName_len =
            (AT_BT_DEVICE_NAME_MAX_LEN < devInfo->device_name_len) ?
             AT_BT_DEVICE_NAME_MAX_LEN : devInfo->device_name_len;
    (void)memcpy(pCtxCtrl->common.pFrameData->s542.btName,
           devInfo->device_name,
           pCtxCtrl->common.pFrameData->s542.btName_len);

    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS543(AppSdCtxCtrlType *pCtxCtrl)
{
    // set bt device name
    const ERMBTDeviceTableType *devInfo = ERM_GetBTDevice(pCtxCtrl->s543.deviceId);

    if( NULL == devInfo )
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HandleInitFrameS543: dev %d not avail",
                      pCtxCtrl->s543.deviceId);
        return FAIL;
    }

    pCtxCtrl->common.pFrameData->s543.btName_len =
            (AT_BT_DEVICE_NAME_MAX_LEN < devInfo->device_name_len) ?
             AT_BT_DEVICE_NAME_MAX_LEN : devInfo->device_name_len;
    (void)memcpy(pCtxCtrl->common.pFrameData->s543.btName,
           devInfo->device_name,
           pCtxCtrl->common.pFrameData->s543.btName_len);

    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS554(AppSdCtxCtrlType *pCtxCtrl)
{
    /* get the deviceName to show in frame*/
    pCtxCtrl->common.pFrameData->s554.btName_len =
        (AT_BT_DEVICE_NAME_MAX_LEN < strlen((const char*)ERM_GetBTDeviceName())) ?
         AT_BT_DEVICE_NAME_MAX_LEN : strlen((const char*)ERM_GetBTDeviceName());
    (void)memcpy( pCtxCtrl->common.pFrameData->s554.btName,
            ERM_GetBTDeviceName(),
            pCtxCtrl->common.pFrameData->s554.btName_len);

    pCtxCtrl->common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS555(AppSdCtxCtrlType *pCtxCtrl)
{
    // set bt device name
    const ERMBTDeviceTableType *devInfo = ERM_GetBTDevice(pCtxCtrl->s555.deviceId);

    if( NULL == devInfo )
    {
        if(pCtxCtrl->s555.deletePressed == BT_TRUE)
        {
            /* if the device is not available anymore and the we sent delete, it seems
               that the device was deleted */

            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "HaInitFrS555: dev %d deleted",
                          pCtxCtrl->s555.deviceId);

            _APP_SD_vInitFrameS514( gAppSdContext.pCurCtxCtrl->s555.deviceId,
                                    BT_TRUE,
                                    gAppSdContext.pCurCtxCtrl->s555.btName,
                                    gAppSdContext.pCurCtxCtrl->s555.btName_len);
            return SUCCESS;
        }
        else
        {

            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "HaInitFrS555: dev %d not avail",
                          pCtxCtrl->s555.deviceId);
            return FAIL;
        }
    }

    pCtxCtrl->common.pFrameData->s555.btName_len =
            (AT_BT_DEVICE_NAME_MAX_LEN < devInfo->device_name_len) ?
             AT_BT_DEVICE_NAME_MAX_LEN : devInfo->device_name_len;
    (void)memcpy(pCtxCtrl->common.pFrameData->s555.btName,
           devInfo->device_name,
           pCtxCtrl->common.pFrameData->s555.btName_len);

    // copy btName into current ctx, needed for S514
    pCtxCtrl->s555.btName_len =
            (AT_BT_DEVICE_NAME_MAX_LEN < devInfo->device_name_len) ?
             AT_BT_DEVICE_NAME_MAX_LEN : devInfo->device_name_len;
    (void)memcpy(pCtxCtrl->s555.btName,
           devInfo->device_name,
           pCtxCtrl->s555.btName_len);

    gAppSdContext.s408DelDeviceNameLength = (AT_BT_DEVICE_NAME_MAX_LEN < devInfo->device_name_len) ?
             AT_BT_DEVICE_NAME_MAX_LEN : devInfo->device_name_len;

    (void)memcpy(gAppSdContext.s408DelDeviceName, devInfo->device_name, gAppSdContext.s408DelDeviceNameLength);

    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
    return SUCCESS;
}


SuccessFailType _APP_SD_sfHandleInitFrameS556(AppSdCtxCtrlType *pCtxCtrl)
{
    APP_SD_SC_vReadSelectionText( &(pCtxCtrl->s556.spellerCtrl),
                                  &(pCtxCtrl->common.pFrameData->s556.selectedText));

    APP_SD_SC_vReadSpelledText( &(pCtxCtrl->s556.spellerCtrl),
                                &(pCtxCtrl->common.pFrameData->s556.spelledText));


    pCtxCtrl->common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS563(AppSdCtxCtrlType *pCtxCtrl)
{
    // set bt device name
    const ERMBTDeviceTableType *devInfo = ERM_GetBTDevice(pCtxCtrl->s563.deviceId);

    if( NULL == devInfo )
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HandleInitFrameS563: dev %d not avail",
                      pCtxCtrl->s563.deviceId);
        return FAIL;
    }

    pCtxCtrl->common.pFrameData->s563.btName_len =
            (AT_BT_DEVICE_NAME_MAX_LEN < devInfo->device_name_len) ?
            AT_BT_DEVICE_NAME_MAX_LEN : devInfo->device_name_len;
    (void)memcpy(pCtxCtrl->common.pFrameData->s563.btName,
           devInfo->device_name,
           pCtxCtrl->common.pFrameData->s563.btName_len);

    // set device type
    switch( pCtxCtrl->s563.deviceType)
    {
        case APP_DEVICE_enTYPE_HEADSET:
            pCtxCtrl->common.pFrameData->s563.device_type_len = strlen("Headset");
            (void)memcpy(pCtxCtrl->common.pFrameData->s563.device_type,
                    "Headset",
                    strlen("Headset"));
            break;
        case APP_DEVICE_enTYPE_PLAYER:
            pCtxCtrl->common.pFrameData->s563.device_type_len = strlen("Media Player");
            (void)memcpy(pCtxCtrl->common.pFrameData->s563.device_type,
                    "Media Player",
                    strlen("Media Player"));
            break;
        default:
            // unknown
            break;
    }

    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS571(AppSdCtxCtrlType *pCtxCtrl)
{
    // set bt device name
    const ERMBTDeviceTableType *devInfo = NULL;
    const ERMPhysicalBTDeviceType *devPhyInfo = NULL;


    if( (devInfo = ERM_GetBTDevice(pCtxCtrl->s571.deviceId)) != NULL )
    {
        pCtxCtrl->common.pFrameData->s571.btName_len =
            (AT_BT_DEVICE_NAME_MAX_LEN < devInfo->device_name_len) ?
             AT_BT_DEVICE_NAME_MAX_LEN : devInfo->device_name_len;
        (void)memcpy(pCtxCtrl->common.pFrameData->s571.btName,
               devInfo->device_name,
               pCtxCtrl->common.pFrameData->s571.btName_len);
    }
    else if( (devPhyInfo = ERM_pGetPhyDevice(pCtxCtrl->s571.deviceId)) != NULL )
    {

        DEBUG_VALUE1( APP_SD_SWI_WNG, MOD_APP_SD, "HaInitFrameS571: no BTDevEntry %d, PhyDev fallback",
                      pCtxCtrl->s571.deviceId);

        pCtxCtrl->common.pFrameData->s571.btName_len =
            (AT_BT_DEVICE_NAME_MAX_LEN < devPhyInfo->name_len) ?
             AT_BT_DEVICE_NAME_MAX_LEN : devPhyInfo->name_len;

        (void)memcpy(pCtxCtrl->common.pFrameData->s571.btName,
                     devPhyInfo->name,
                     pCtxCtrl->common.pFrameData->s571.btName_len);
    }
    else
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaInitFrameS571: dev %d not avail",
                      pCtxCtrl->s571.deviceId);
        return FAIL;
    }


    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
    return SUCCESS;
}


SuccessFailType _APP_SD_sfHandleInitFrameS573(AppSdCtxCtrlType *pCtxCtrl)
{
    // set bt device name
    const ERMBTDeviceTableType *devInfo = ERM_GetBTDevice(pCtxCtrl->s573.deviceId);
    if( NULL == devInfo )
    {
        pCtxCtrl->common.pFrameData->s573.btName_len = 0;
    }
    else
    {
        pCtxCtrl->common.pFrameData->s573.btName_len =
                (AT_BT_DEVICE_NAME_MAX_LEN < devInfo->device_name_len) ?
                 AT_BT_DEVICE_NAME_MAX_LEN : devInfo->device_name_len;

        (void)memcpy(pCtxCtrl->common.pFrameData->s573.btName,
                     devInfo->device_name,
                     pCtxCtrl->common.pFrameData->s573.btName_len);
    }

    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS574(AppSdCtxCtrlType *pCtxCtrl)
{
    // set bt device name
    const ERMBTDeviceTableType *devInfo = ERM_GetBTDevice(pCtxCtrl->s574.deviceId);

    if( NULL == devInfo )
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HandleInitFrameS574: dev %d not avail",
                      pCtxCtrl->s574.deviceId);
        return FAIL;
    }

    pCtxCtrl->common.pFrameData->s574.btName_len =
           (AT_BT_DEVICE_NAME_MAX_LEN < devInfo->device_name_len) ?
            AT_BT_DEVICE_NAME_MAX_LEN : devInfo->device_name_len;

    (void)memcpy(pCtxCtrl->common.pFrameData->s574.btName,
                 devInfo->device_name,
                 pCtxCtrl->common.pFrameData->s574.btName_len);

    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
    return SUCCESS;
}



SuccessFailType _APP_SD_sfHandleInitFrameS575(AppSdCtxCtrlType *pCtxCtrl)
{
    // write spelled text into / selected text into frame
    AppSdScSpellerCtrlType *pSpellerCtrl = &(pCtxCtrl->s536.spellerCtrl);
    APP_SD_SC_vReadSelectionText( pSpellerCtrl, &(pCtxCtrl->common.pFrameData->s575.selectedText));

    APP_SD_SC_vReadSpelledText( pSpellerCtrl, &(pCtxCtrl->common.pFrameData->s575.spelledText));

    // write device type into frame
    switch( pCtxCtrl->s575.deviceType )
    {
        case APP_DEVICE_enTYPE_HEADSET:
            pCtxCtrl->common.pFrameData->s575.device_type_len = strlen("Headset:");
            (void)memcpy(pCtxCtrl->common.pFrameData->s575.device_type,
                "Headset:",
                strlen("Headset:"));
            break;
        case APP_DEVICE_enTYPE_PLAYER:
            pCtxCtrl->common.pFrameData->s575.device_type_len = strlen("Media Player:");
            (void)memcpy(pCtxCtrl->common.pFrameData->s575.device_type,
                "Media Player:",
                strlen("Media Player:"));
            break;
    }

    pCtxCtrl->common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);

    return SUCCESS;
}



SuccessFailType _APP_SD_sfHandleInitFrameS576(AppSdCtxCtrlType *pCtxCtrl)
{
    // set bt device name
    const ERMBTDeviceTableType *devInfo = NULL;
    const ERMPhysicalBTDeviceType *phyDevInfo = NULL;

    if( (devInfo = ERM_GetBTDevice(pCtxCtrl->s576.deviceId)) != NULL )
    {
        pCtxCtrl->common.pFrameData->s576.btName_len =
            (AT_BT_DEVICE_NAME_MAX_LEN < devInfo->device_name_len) ?
             AT_BT_DEVICE_NAME_MAX_LEN : devInfo->device_name_len;

        (void)memcpy(pCtxCtrl->common.pFrameData->s576.btName,
                     devInfo->device_name,
                     pCtxCtrl->common.pFrameData->s576.btName_len);
    }
    else if( (phyDevInfo = ERM_pGetPhyDevice(pCtxCtrl->s576.deviceId)) != NULL )
    {

        DEBUG_VALUE1( APP_SD_SWI_WNG, MOD_APP_SD, "HandleInitFrameS576: no BtDevEntry %d, PhyDevEntry fallback",
                      pCtxCtrl->s576.deviceId);

        pCtxCtrl->common.pFrameData->s576.btName_len =
               (AT_BT_DEVICE_NAME_MAX_LEN < phyDevInfo->name_len) ?
                AT_BT_DEVICE_NAME_MAX_LEN : phyDevInfo->name_len;

        (void)memcpy(pCtxCtrl->common.pFrameData->s576.btName,
                     phyDevInfo->name,
                     pCtxCtrl->common.pFrameData->s576.btName_len);
    }
    else
    {
        if(pCtxCtrl->s576.deletePressed == BT_TRUE)
        {
            /* if the device is not available anymore and the we sent delete, it seems
               that the device was deleted */

            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "HaInitFrS576: dev %d deleted",
                          pCtxCtrl->s576.deviceId);

            _APP_SD_vInitFrameS578( gAppSdContext.pCurCtxCtrl->s576.deviceId,
                                    gAppSdContext.pCurCtxCtrl->s576.deviceType,
                                    gAppSdContext.pCurCtxCtrl->s576.btName,
                                    gAppSdContext.pCurCtxCtrl->s576.btName_len);
            return SUCCESS;
        }
        else
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaInitFrS576: dev %d not avail",
                          pCtxCtrl->s576.deviceId);
            return FAIL;
        }
    }


    // copy btName into current ctx, needed for S578
    pCtxCtrl->s576.btName_len = pCtxCtrl->common.pFrameData->s576.btName_len;
    (void)memcpy(pCtxCtrl->s576.btName,
           pCtxCtrl->common.pFrameData->s576.btName,
           pCtxCtrl->common.pFrameData->s576.btName_len);


    gAppSdContext.s408DelDeviceNameLength = pCtxCtrl->common.pFrameData->s576.btName_len;
    (void)memcpy(gAppSdContext.s408DelDeviceName, pCtxCtrl->common.pFrameData->s576.btName,gAppSdContext.s408DelDeviceNameLength);
    gAppSdContext.s408DelDeviceType = gAppSdContext.pCurCtxCtrl->s576.deviceType;

    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS578(AppSdCtxCtrlType *pCtxCtrl)
{
    // set bt device name into frame data buffer
    pCtxCtrl->common.pFrameData->s578.btName_len =
            (AT_BT_DEVICE_NAME_MAX_LEN < pCtxCtrl->s578.btName_len) ?
             AT_BT_DEVICE_NAME_MAX_LEN : pCtxCtrl->s578.btName_len;

    (void)memcpy(pCtxCtrl->common.pFrameData->s578.btName,
            pCtxCtrl->s578.btName,
            pCtxCtrl->common.pFrameData->s578.btName_len);

    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
    return SUCCESS;
}



SuccessFailType _APP_SD_sfHandleInitFrameS579(AppSdCtxCtrlType *pCtxCtrl)
{
    // set bt device name
    const ERMBTDeviceTableType *devInfo = ERM_GetBTDevice(pCtxCtrl->s579.deviceId);

    if( NULL == devInfo )
    {
        if(pCtxCtrl->s579.deletePressed == BT_TRUE)
        {
            /* if the device is not available anymore and the we sent delete, it seems
               that the device was deleted */

            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "HaInitFrS579: dev %d deleted",
                          pCtxCtrl->s579.deviceId);

            _APP_SD_vInitFrameS578( gAppSdContext.pCurCtxCtrl->s579.deviceId,
                                    gAppSdContext.pCurCtxCtrl->s579.deviceType,
                                    gAppSdContext.pCurCtxCtrl->s579.btName,
                                    gAppSdContext.pCurCtxCtrl->s579.btName_len);
            return SUCCESS;
        }
        else
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HaInitFrS579: dev %d not avail",
                          pCtxCtrl->s579.deviceId);
            return FAIL;
        }
    }

    pCtxCtrl->common.pFrameData->s579.btName_len =
           (AT_BT_DEVICE_NAME_MAX_LEN < devInfo->device_name_len) ?
            AT_BT_DEVICE_NAME_MAX_LEN : devInfo->device_name_len;

    (void)memcpy(pCtxCtrl->common.pFrameData->s579.btName,
                 devInfo->device_name,
                 pCtxCtrl->common.pFrameData->s579.btName_len );

    // copy btName into current ctx, needed for S578
    pCtxCtrl->s579.btName_len =
           (AT_BT_DEVICE_NAME_MAX_LEN < devInfo->device_name_len) ?
            AT_BT_DEVICE_NAME_MAX_LEN : devInfo->device_name_len;

    (void)memcpy(pCtxCtrl->s579.btName,
                 devInfo->device_name,
                 pCtxCtrl->s579.btName_len );

     gAppSdContext.s408DelDeviceNameLength = (AT_BT_DEVICE_NAME_MAX_LEN < devInfo->device_name_len) ?
                                            AT_BT_DEVICE_NAME_MAX_LEN : devInfo->device_name_len;

    (void)memcpy(gAppSdContext.s408DelDeviceName,devInfo->device_name,gAppSdContext.s408DelDeviceNameLength);

    gAppSdContext.s408DelDeviceType = gAppSdContext.pCurCtxCtrl->s579.deviceType;

    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
    return SUCCESS;
}

//SuccessFailType _APP_SD_sfHandleInitFrameS580(AppSdCtxCtrlType *pCtxCtrl)
//{
//    // write spelled text into / selected text into frame
//    AppSdScSpellerCtrlType *pSpellerCtrl = &(pCtxCtrl->s536.spellerCtrl);
//    APP_SD_SC_vReadSelectionText( pSpellerCtrl, &(pCtxCtrl->common.pFrameData->s580.selectedText));
//
//    APP_SD_SC_vReadSpelledText( pSpellerCtrl, &(pCtxCtrl->common.pFrameData->s580.spelledText));
//
//    // write device type into frame
//    switch( pCtxCtrl->s580.deviceType )
//    {
//        case APP_DEVICE_enTYPE_HEADSET:
//            pCtxCtrl->common.pFrameData->s580.device_type_len = strlen("Headset:");
//            (void)memcpy(pCtxCtrl->common.pFrameData->s580.device_type,
//                "Headset:",
//                strlen("Headset:"));
//            break;
//        case APP_DEVICE_enTYPE_PLAYER:
//            pCtxCtrl->common.pFrameData->s580.device_type_len = strlen("Media Player:");
//            (void)memcpy(pCtxCtrl->common.pFrameData->s580.device_type,
//                "Media Player:",
//                strlen("Media Player:"));
//            break;
//    }
//
//    pCtxCtrl->common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;
//
//    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
//                                        MSEC(0),
//                                        0);
//
//    return SUCCESS;
//}

SuccessFailType _APP_SD_sfHandleInitFrameS581(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s581.subState)
    {
        case APP_SD_S581_START_INQUIRY_NOT_SENT:
        {
            // start inquiry
            APP_COMMON_enResponseCode rspCode = ERM_rcStartInquiry( _APP_SD_vInitPendingS581_Cb);

            switch(rspCode)
            {
                case APP_COMMON_RSP_ERROR_BUSY:
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                              MSEC(10), 0);
                    break;
                case APP_COMMON_RSP_OK:
                    // wait for callback being called
                    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
                    break;
                default:

                    DEBUG_VALUE1(APP_SD_SWI_ERR, MOD_APP_SD, "HdlInitFrS581: err %d, goto Idle", rspCode);
                    // SUSANNE: 21.11.2009: InitIdleScreen is called in HandleInitFrame() main function
                    // when we return FAIL here
                    //_APP_SD_vInitIdleScreen(0);
                    return FAIL;
            }
            break;
        }
        case APP_SD_S581_START_INQUIRY_SENT:
            //RS: we received an inquiry end but were hide by a popup, so handle the
            //    inquiry end event now
            if( pCtxCtrl->s581.inquiryEndRcvd == BT_TRUE )
            {

                DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HaInitFrameS581: call sfHaErmNotInqEnd");

                if(_APP_SD_sfHandleErmNotificationInquiryEnd() != SUCCESS)
                {
                    //RS: that should never happen

                    DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "HaInitFrameS581: sfHaErmNotInqEnd failed!");

                    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                              MSEC(0),
                                                              0);
                }
            }
            else
            {
                pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                          MSEC(0),
                                                          0);
            }
            break;
        default:
            pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
    }

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS597(AppSdCtxCtrlType *pCtxCtrl)
{
    // set bt device name
    const ERMBTDeviceTableType *devInfo = ERM_GetBTDevice(pCtxCtrl->s597.deviceId);

    if( NULL == devInfo )
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HandleInitFrameS597: dev %d not avail",
                      pCtxCtrl->s597.deviceId);
        return FAIL;
    }

    pCtxCtrl->common.pFrameData->s597.btName_len =
            (AT_BT_DEVICE_NAME_MAX_LEN < devInfo->device_name_len) ?
             AT_BT_DEVICE_NAME_MAX_LEN : devInfo->device_name_len;

    (void)memcpy(pCtxCtrl->common.pFrameData->s597.btName,
                 devInfo->device_name,
                 pCtxCtrl->common.pFrameData->s597.btName_len);

    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS601(AppSdCtxCtrlType *pCtxCtrl)
{
    if(ERM_bIsBluetoothVisible())
    {

        DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HaInitFrS601: bt vis -> version");

        pCtxCtrl->s601.bVersion = BT_TRUE;

#ifdef UHV_ACTIVATE_FEATURE_SET_AUDIO_MODE
        pCtxCtrl->common.listData.numListElems    = 5;    // menue entries
#else
        pCtxCtrl->common.listData.numListElems    = 4;    // menue entries
#endif
    }
    else
    {

        DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HaInitFrS601: bt vis -> version");

        pCtxCtrl->s601.bVersion = BT_FALSE;

#ifdef UHV_ACTIVATE_FEATURE_SET_AUDIO_MODE
        pCtxCtrl->common.listData.numListElems    = 4;    // menue entries
#else
        pCtxCtrl->common.listData.numListElems    = 3;    // menue entries
#endif
        if(APP_SD_LC_u16GetSelectedIndex(&pCtxCtrl->common.listData) >= pCtxCtrl->common.listData.numListElems)
        {
            pCtxCtrl->common.listData.listElemOnTop   = 1;    // first list elem
            pCtxCtrl->common.listData.focusedListElemOffset = 0;    // first list elem
        }
    }

    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(0), 0);
    return SUCCESS;
}


//SuccessFailType _APP_SD_sfHandleInitFrameS602(AppSdCtxCtrlType *pCtxCtrl)
//{
//    APP_COMMON_enResponseCode rspCode = ERM_enGetActiveUserAudioMode();
//
//    if( rspCode == APP_COMMON_RSP_ERROR_BUSY )
//    {
//        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
//                                            MSEC(10),
//                                            0);
//        return SUCCESS;
//    }
//    else if( rspCode != APP_COMMON_RSP_OK)
//    {   /* for now ERM will not be able to handle request, cause of unknown
//        parrot cmd. */
//        pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
//    }
//    else
//    {
//        pCtxCtrl->common.state  = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
//    }
//
//    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
//                                        MSEC(10),
//                                        0);
//    return SUCCESS;
//}



SuccessFailType _APP_SD_sfHandleInitFrameS642(AppSdCtxCtrlType *pCtxCtrl)
{
    AppSdFrameDataListCommon *pListCtrl = &(pCtxCtrl->common.listData);
    Uint16Type selIdx = APP_SD_LC_u16GetSelectedIndex(pListCtrl);
    ATRintoneModeEnum ringtone = ERM_eGetUmpteenthRingtone(selIdx);

    if(ringtone != AT_RTMODE_INVALID)
    {
        (void)APP_DEVICE_rcStartRingtoneNonBlock(ringtone);
        pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
        (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
    }
    else
    {
        /* without a valid ringtone we have nothing to do here,
         * so just request the frame presentation */
        pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                  MSEC(0),
                                                  0);
    }
    return SUCCESS;
}
//SuccessFailType _APP_SD_sfHandleInitFrameS406(AppSdCtxCtrlType *pCtxCtrl)
//{
//    APP_COMMON_enResponseCode rspCode = APP_SMS_rcReadSms(
//                                             _APP_SD_vInitPendingS406_Cb,
//                                             pCtxCtrl->s406.smsIndex,
//                                             1);
//
//    switch(rspCode)
//    {
//        case APP_COMMON_RSP_ERROR_BUSY:
//            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
//                                                      MSEC(10), 0);
//            break;
//        case APP_COMMON_RSP_OK:
//            // wait for callback being called
//            pCtxCtrl->common.state  = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
//            break;
//        default:
//
              // SUSANNE: 21.11.2009: InitIdleScreen is called in HandleInitFrame() main function
              // when we return FAIL here
//            //_APP_SD_vInitIdleScreen(0);
//            return FAIL;
//    }
//
//    return SUCCESS;
//}

SuccessFailType _APP_SD_sfHandleInitFrameS669(AppSdCtxCtrlType *pCtxCtrl)
{   // Sortierung Telefonbuch ändern
    APP_COMMON_enResponseCode rspCode = APP_PHONEBOOK_rcRequestCurrentPbSortOrder(
                                             _APP_SD_vInitPendingS669_Cb);

    switch(rspCode)
    {
        case APP_COMMON_RSP_ERROR_BUSY:
            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                      MSEC(10), 0);
            break;
        case APP_COMMON_RSP_OK:
            // wait for callback being called
            pCtxCtrl->common.state  = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
            break;
        default:

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HdlInitFrS669: err %d, goto Idle", rspCode);
            // SUSANNE: 21.11.2009: InitIdleScreen is called in HandleInitFrame() main function
            // when we return FAIL here
            //_APP_SD_vInitIdleScreen(0);
            return FAIL;
    }
    return SUCCESS;
}




/******************************************/
// call handling
/******************************************/

SuccessFailType _APP_SD_sfHandleInitFrameS801(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s801.subState)
    {
        case APP_SD_S801_NUMBER_NOT_REQUESTED:
        {
            APP_COMMON_enResponseCode rspCode = APP_PHONEBOOK_rcRequestCompletePbEntries(
                                                     _APP_SD_vInitPendingS801_ReqNumber_Cb,
                                                     pCtxCtrl->s801.pbType,
                                                     pCtxCtrl->s801.pbIndex,
                                                     1);

            switch(rspCode)
            {
                case APP_COMMON_RSP_ERROR_BUSY:
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                              MSEC(10), 0);
                    break;
                case APP_COMMON_RSP_OK:
                    // wait for callback being called
                    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
                    pCtxCtrl->s801.subState = APP_SD_S801_NUMBER_REQUESTED;
                    break;
                default:

                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HdlInitFrS801: err %d, goto Idle", rspCode);
                    // SUSANNE: 21.11.2009: InitIdleScreen is called in HandleInitFrame() main function
                    // when we return FAIL here
                    //_APP_SD_vInitIdleScreen(0);
                    return FAIL;
            }
            break;
        }
        case APP_SD_S801_NUMBER_REQUESTED:
        {
            APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_ERROR_BUSY;

            if( pCtxCtrl->s801.pbType == APP_PHONEBOOK_enUsersPB )
            {
                /* we have a pbIndex to call (if pnIndex is 0, we will call the default number */
                rspCode = APP_PHONE_rcDialPnIndex( _APP_SD_vInitPendingS801_Dial_Cb,
                                                   pCtxCtrl->s801.pbIndex,
                                                   pCtxCtrl->s801.pnIndex );
            }
            else
            {
                /* we have a number to dial */
                // check number, if invalid, show info to user
                if( BT_FALSE == APP_PHONE_bIsValidPhoneNumber(pCtxCtrl->s801.number, pCtxCtrl->s801.number_len))
                {
                    _APP_SD_vInitFrameS806();
                    return SUCCESS;
                }
                rspCode = APP_PHONE_rcDialNumber( _APP_SD_vInitPendingS801_Dial_Cb,
                                                  pCtxCtrl->s801.number,
                                                  pCtxCtrl->s801.number_len );
            }

            switch(rspCode)
            {
                case APP_COMMON_RSP_ERROR_BUSY:
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                          MSEC(10), 0);
                    return SUCCESS;
                case APP_COMMON_RSP_OK:
                    /* dialled */
                    break;
                default:
                    /* we did not dialled and so no call will be established. Also APP_PHONE will not
                       trigger an outgoing call timeout, so SD would freeze with pending init */
                    // #4365 avoid sd freeze
                    return FAIL;
            }

            pCtxCtrl->s801.subState = APP_SD_S801_NUMBER_DIALED;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        }
        case APP_SD_S801_NUMBER_DIALED:
            if( pCtxCtrl->s801.pbType == APP_PHONEBOOK_enPbUnknown )
            {
                /* get the callerId to show in frame*/
                //// check if callerId is number saved for mailbox for active user, if so, show
                //// 'Mailbox' instead of number
                //BooleanType bIsMailboxCall = BT_FALSE;
                //const ERMUserProfileType * profile = ERM_pGetActiveUserProfile();
                //if( NULL != profile )
                //{
                //    // compare mailbox number saved for profile with s801 number
                //    if(pCtxCtrl->s801.number_len == profile->voicemailbox_len &&
                //       0 == memcmp( profile->voicemailbox, pCtxCtrl->s801.number, pCtxCtrl->s801.number_len ))
                //    {
                //        bIsMailboxCall = BT_TRUE;
                //    }
                //}

                //if( BT_TRUE == bIsMailboxCall )
                //{   // TODO: Maybe VW wants to show different name for Mailbox
                //    // depending on language
                //    pCtxCtrl->common.pFrameData->s801.name_len = strlen("Mailbox");
                //    memcpy( pCtxCtrl->common.pFrameData->s801.name,
                //            "Mailbox",
                //            pCtxCtrl->common.pFrameData->s801.name_len);
                //}
                //else
                //{
                //    pCtxCtrl->common.pFrameData->s801.name_len = pCtxCtrl->s801.number_len;
                //    memcpy( pCtxCtrl->common.pFrameData->s801.name,
                //            pCtxCtrl->s801.number,
                //            pCtxCtrl->common.pFrameData->s801.name_len);
                //}

                // fix for ticket #3045 (no name matching)
                if(0 != pCtxCtrl->s801.number_len)
                {
                    AT_CallerId callerId;
                    Uint16Type callerIdLen = pCtxCtrl->s801.number_len;

                    if(callerIdLen > sizeof(callerId))
                    {
                        callerIdLen = sizeof(callerId);
                    }

                    (void)memcpy(callerId, pCtxCtrl->s801.number, callerIdLen);

                    pCtxCtrl->common.pFrameData->s801.name_len =
                                _APP_SD_u16WriteCallerId( &(pCtxCtrl->common.pFrameData->s801.name),
                                                          (const AT_CallerId*)&callerId,
                                                          callerIdLen);
                }
                else
                {
                    // the enum can be used from Screen S211, till the special texts for this Screen are generated
                    pCtxCtrl->common.pFrameData->s801.name_len = gAppSdContext.prompts_len[APP_SD_en_S211_ta_menu_no_nbr_Auswahl_1];

                    (void)memcpy(pCtxCtrl->common.pFrameData->s801.name,
                                 gAppSdContext.prompts[APP_SD_en_S211_ta_menu_no_nbr_Auswahl_1],
                                 pCtxCtrl->common.pFrameData->s801.name_len);
                }
            }

            pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        default:

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandleInitFrameS801: invalid subState %d",
                          pCtxCtrl->s801.subState);

            pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
    }

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS802(AppSdCtxCtrlType *pCtxCtrl)
{
    /*
    // fill text depending on error
    switch( pCtxCtrl->s802.error )
    {
        case APP_SD_enS02_DIAL_ERROR:
            break;
        default:

            break;
    }
    */

     pCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

     (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                         MSEC(0),
                                         0);

    return SUCCESS;
}


SuccessFailType _APP_SD_sfHandleInitFrameS803(AppSdCtxCtrlType *pCtxCtrl)
{
    const ATRspCallStatValType *plcc = APP_PHONE_AT_PNCC_pGetPlccContext(pCtxCtrl->s803.plccIndex);

    //pCtxCtrl->common.pFrameData->s803.name_len =
    //            _APP_SD_u16WriteCallerId(&(pCtxCtrl->common.pFrameData->s803.name),
    //                                      &(plcc->caller_id),
    //                                      plcc->caller_id_len);

    if(plcc != NULL && plcc->id_avail)
    {
        pCtxCtrl->common.pFrameData->s803.name_len =
                    _APP_SD_u16WriteCallerId( &(pCtxCtrl->common.pFrameData->s803.name),
                                              &(plcc->caller_id),
                                              plcc->caller_id_len);
    }
    else
    {
//        pCtxCtrl->common.pFrameData->s803.name_len =
//                    _APP_SD_u16WriteCallerId( &(pCtxCtrl->common.pFrameData->s803.name),
//                                              NULL, 0);
        // the enum can be used from Screen S211, till the special texts for this Screen are generated
        // fix for ticket #3045 (no name matching)
        pCtxCtrl->common.pFrameData->s803.name_len = gAppSdContext.prompts_len[APP_SD_en_S211_ta_menu_no_nbr_Auswahl_1];

        (void)memcpy(pCtxCtrl->common.pFrameData->s803.name,
                     gAppSdContext.prompts[APP_SD_en_S211_ta_menu_no_nbr_Auswahl_1],
                     pCtxCtrl->common.pFrameData->s803.name_len);
    }

//    if(plcc != NULL && plcc->id_avail)
//    {
//       // check if callerId is number saved for mailbox for active user, if so, show
//       // 'Mailbox' instead of number
//       BooleanType bIsMailboxCall = BT_FALSE;
//       const ERMUserProfileType * profile = ERM_pGetActiveUserProfile();
//       if( NULL != profile )
//       {
//           // compare mailbox number saved for profile with s801 number
//           if(plcc->caller_id_len == profile->voicemailbox_len &&
//              0 == memcmp( profile->voicemailbox, plcc->caller_id, plcc->caller_id_len ))
//           {
//               bIsMailboxCall = BT_TRUE;
//           }
//       }
//
//       if( BT_TRUE == bIsMailboxCall )
//       {   // TODO: Maybe VW wants to show different name for Mailbox
//           // depending on language
//           pCtxCtrl->common.pFrameData->s803.name_len = strlen("Mailbox");
//           memcpy( pCtxCtrl->common.pFrameData->s803.name,
//                   "Mailbox",
//                   pCtxCtrl->common.pFrameData->s803.name_len);
//       }
//       else
//       {
//           /* set the callerId to show in frame*/
//           pCtxCtrl->common.pFrameData->s803.name_len = plcc->caller_id_len;
//           memcpy( pCtxCtrl->common.pFrameData->s803.name,
//                   plcc->caller_id,
//                   pCtxCtrl->common.pFrameData->s803.name_len);
//       }
//    }
//    else
//    {
//        /* set the callerId to be shown in frame to empty */
//        /* unknown */
//        pCtxCtrl->common.pFrameData->s803.name_len = 0;
//    }

    //pCtxCtrl->common.pFrameData->s803.call_type_len = strlen("Anruf");

    pCtxCtrl->common.pFrameData->s803.call_type_len = gAppSdContext.prompts_len[APP_SD_en_S803_ta_head_call_active_1_Zeile_1];
    // check length first
    if(sizeof(pCtxCtrl->common.pFrameData->s803.call_type) < pCtxCtrl->common.pFrameData->s803.call_type_len)
    {
        pCtxCtrl->common.pFrameData->s803.call_type_len = sizeof(pCtxCtrl->common.pFrameData->s803.call_type);
    }
    // then copy data
    (void)memcpy(pCtxCtrl->common.pFrameData->s803.call_type,
                 //"Anruf",
                 gAppSdContext.prompts[APP_SD_en_S803_ta_head_call_active_1_Zeile_1],
                 pCtxCtrl->common.pFrameData->s803.call_type_len);

    pCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS804(AppSdCtxCtrlType *pCtxCtrl)
{
    APP_SD_SC_vReadSelectionText( &(pCtxCtrl->s804.spellerCtrl),
                                  &(pCtxCtrl->common.pFrameData->s804.selectedText));

    APP_SD_SC_vReadSpelledText( &(pCtxCtrl->s804.spellerCtrl),
                                &(pCtxCtrl->common.pFrameData->s804.spelledText));


    pCtxCtrl->common.state = APP_SD_CTX_FRAME_WAIT_FOR_RESSOURCE;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS811(AppSdCtxCtrlType *pCtxCtrl)
{
    const ATRspCallStatValType *plcc = APP_PHONE_AT_PNCC_pGetPlccContext(pCtxCtrl->s811.plccIndex);

    //pCtxCtrl->common.pFrameData->s811.name_len =
    //            _APP_SD_u16WriteCallerId(&(pCtxCtrl->common.pFrameData->s811.name),
    //                                     &(plcc->caller_id),
    //                                      plcc->caller_id_len);

    if(plcc != NULL && plcc->id_avail)
    {
        pCtxCtrl->common.pFrameData->s811.name_len =
                    _APP_SD_u16WriteCallerId( &(pCtxCtrl->common.pFrameData->s811.name),
                                              &(plcc->caller_id),
                                              plcc->caller_id_len);
    }
    else
    {   /* this path will also be used when we have a conferece on hold, cause there will be no valid
           plcc, cause we need to handle 2 plccs */
//        pCtxCtrl->common.pFrameData->s811.name_len =
//                    _APP_SD_u16WriteCallerId( &(pCtxCtrl->common.pFrameData->s811.name),
//                                              NULL, 0);
		// the enum can be used from Screen S211, till the special texts for this Screen are generated
		// fix for ticket #3045 (no name matching)
        pCtxCtrl->common.pFrameData->s811.name_len = gAppSdContext.prompts_len[APP_SD_en_S211_ta_menu_no_nbr_Auswahl_1];

        (void)memcpy(pCtxCtrl->common.pFrameData->s811.name,
                     gAppSdContext.prompts[APP_SD_en_S211_ta_menu_no_nbr_Auswahl_1],
                     pCtxCtrl->common.pFrameData->s811.name_len);
    }

//    if(plcc != NULL && plcc->id_avail)
//    {
//        // check if callerId is number saved for mailbox for active user, if so, show
//        // 'Mailbox' instead of number
//        BooleanType bIsMailboxCall = BT_FALSE;
//        const ERMUserProfileType * profile = ERM_pGetActiveUserProfile();
//        if( NULL != profile )
//        {
//            // compare mailbox number saved for profile with s801 number
//            if(plcc->caller_id_len == profile->voicemailbox_len &&
//               0 == memcmp( profile->voicemailbox, plcc->caller_id, plcc->caller_id_len ))
//            {
//                bIsMailboxCall = BT_TRUE;
//            }
//        }
//
//        if( BT_TRUE == bIsMailboxCall )
//        {   // TODO: Maybe VW wants to show different name for Mailbox
//            // depending on language
//            pCtxCtrl->common.pFrameData->s811.name_len = strlen("Mailbox");
//            memcpy( pCtxCtrl->common.pFrameData->s811.name,
//                    "Mailbox",
//                    pCtxCtrl->common.pFrameData->s811.name_len);
//        }
//        else
//        {
//            /* set the callerId to show in frame*/
//            pCtxCtrl->common.pFrameData->s811.name_len = plcc->caller_id_len;
//            memcpy( pCtxCtrl->common.pFrameData->s811.name,
//                    plcc->caller_id,
//                    pCtxCtrl->common.pFrameData->s811.name_len);
//        }
//    }
//    else
//    {
//        /* set the callerId to show in frame*/
//        pCtxCtrl->common.pFrameData->s811.name_len = 0;
//    }

    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS812(AppSdCtxCtrlType *pCtxCtrl)
{
    const ATRspCallStatValType *plcc = APP_PHONE_AT_PNCC_pGetPlccContext(pCtxCtrl->s812.activePlccIdx);

    //pCtxCtrl->common.pFrameData->s812.name_len =
    //            _APP_SD_u16WriteCallerId(&(pCtxCtrl->common.pFrameData->s812.name),
    //                                     &(plcc->caller_id),
    //                                      plcc->caller_id_len);

    if(plcc != NULL && plcc->id_avail)
    {
        pCtxCtrl->common.pFrameData->s812.name_len =
                    _APP_SD_u16WriteCallerId( &(pCtxCtrl->common.pFrameData->s812.name),
                                              &(plcc->caller_id),
                                              plcc->caller_id_len);
    }
    else
    {
//        pCtxCtrl->common.pFrameData->s812.name_len =
//                    _APP_SD_u16WriteCallerId( &(pCtxCtrl->common.pFrameData->s812.name),
//                                              NULL, 0);
		// the enum can be used from Screen S211, till the special texts for this Screen are generated
		// fix for ticket #3045 (no name matching)
        pCtxCtrl->common.pFrameData->s812.name_len = gAppSdContext.prompts_len[APP_SD_en_S211_ta_menu_no_nbr_Auswahl_1];

        (void)memcpy(pCtxCtrl->common.pFrameData->s812.name,
                     gAppSdContext.prompts[APP_SD_en_S211_ta_menu_no_nbr_Auswahl_1],
                     pCtxCtrl->common.pFrameData->s812.name_len);
    }

//     if(plcc != NULL && plcc->id_avail)
//     {
//        // check if callerId is number saved for mailbox for active user, if so, show
//        // 'Mailbox' instead of number
//        BooleanType bIsMailboxCall = BT_FALSE;
//        const ERMUserProfileType * profile = ERM_pGetActiveUserProfile();
//        if( NULL != profile )
//        {
//            // compare mailbox number saved for profile with s801 number
//            if(plcc->caller_id_len == profile->voicemailbox_len &&
//               0 == memcmp( profile->voicemailbox, plcc->caller_id, plcc->caller_id_len ))
//            {
//                bIsMailboxCall = BT_TRUE;
//            }
//        }
//
//        if( BT_TRUE == bIsMailboxCall )
//        {   // TODO: Maybe VW wants to show different name for Mailbox
//            // depending on language
//            pCtxCtrl->common.pFrameData->s812.name_len = strlen("Mailbox");
//            memcpy( pCtxCtrl->common.pFrameData->s812.name,
//                    "Mailbox",
//                    pCtxCtrl->common.pFrameData->s812.name_len);
//        }
//        else
//        {
//            /* set the callerId to show in frame*/
//            pCtxCtrl->common.pFrameData->s812.name_len = plcc->caller_id_len;
//            memcpy( pCtxCtrl->common.pFrameData->s812.name,
//                    plcc->caller_id,
//                    pCtxCtrl->common.pFrameData->s812.name_len);
//        }
//     }
//     else
//     {
//         /* set the callerId to show in frame*/
//         pCtxCtrl->common.pFrameData->s812.name_len = 0;
//     }

     if(pCtxCtrl->s812.activePlccIdx == AT_CALL_INDEX_0)
     {  //"Anruf 1",
        // headline "Anruf 1" is associated to S813, but we handle S812 and S813
        // together in S812 frame, but here we use the textIds from S813
        pCtxCtrl->common.pFrameData->s812.title_len = gAppSdContext.prompts_len[APP_SD_en_S813_ta_head_call1_1_Zeile_1];
        if(sizeof(pCtxCtrl->common.pFrameData->s812.title) < pCtxCtrl->common.pFrameData->s812.title_len)
        {
            pCtxCtrl->common.pFrameData->s812.title_len = sizeof(pCtxCtrl->common.pFrameData->s812.title);
        }
        (void)memcpy(pCtxCtrl->common.pFrameData->s812.title,
                     gAppSdContext.prompts[APP_SD_en_S813_ta_head_call1_1_Zeile_1],
                     pCtxCtrl->common.pFrameData->s812.title_len);
     }
     else
     {  //"Anruf 2",
        pCtxCtrl->common.pFrameData->s812.title_len = gAppSdContext.prompts_len[APP_SD_en_S812_ta_head_call2_1_Zeile_1];
        if(sizeof(pCtxCtrl->common.pFrameData->s812.title) < pCtxCtrl->common.pFrameData->s812.title_len)
        {
            pCtxCtrl->common.pFrameData->s812.title_len = sizeof(pCtxCtrl->common.pFrameData->s812.title);
        }
        (void)memcpy(pCtxCtrl->common.pFrameData->s812.title,
                     gAppSdContext.prompts[APP_SD_en_S812_ta_head_call2_1_Zeile_1],
                     pCtxCtrl->common.pFrameData->s812.title_len);
     }


     pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;

     (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                         MSEC(0),
                                         0);
    return SUCCESS;
}


SuccessFailType _APP_SD_sfHandleInitFrameS901(AppSdCtxCtrlType *pCtxCtrl)
{
    const ATRspCallStatValType *plcc = APP_PHONE_AT_PNCC_pGetPlccContext(pCtxCtrl->s901.plccIndex);

    _APP_SD_vActivateFrame(BT_TRUE, __LINE__);

    //pCtxCtrl->common.pFrameData->s901.name_len =
    //            _APP_SD_u16WriteCallerId(&(pCtxCtrl->common.pFrameData->s901.name),
    //                                     &(plcc->caller_id),
    //                                      plcc->caller_id_len);


    if(plcc != NULL && plcc->id_avail)
    {
        pCtxCtrl->common.pFrameData->s901.name_len =
                    _APP_SD_u16WriteCallerId( &(pCtxCtrl->common.pFrameData->s901.name),
                                              &(plcc->caller_id),
                                              plcc->caller_id_len);
    }
    else
    {
//        pCtxCtrl->common.pFrameData->s901.name_len =
//                    _APP_SD_u16WriteCallerId( &(pCtxCtrl->common.pFrameData->s901.name),
//                                              NULL, 0);
		// the enum can be used from Screen S211, till the special texts for this Screen are generated
		// fix for ticket #3045 (no name matching)
        pCtxCtrl->common.pFrameData->s901.name_len = gAppSdContext.prompts_len[APP_SD_en_S211_ta_menu_no_nbr_Auswahl_1];

        (void)memcpy(pCtxCtrl->common.pFrameData->s901.name,
                     gAppSdContext.prompts[APP_SD_en_S211_ta_menu_no_nbr_Auswahl_1],
                     pCtxCtrl->common.pFrameData->s901.name_len);
    }

//     if(plcc != NULL && plcc->id_avail)
//     {
//        // check if callerId is number saved for mailbox for active user, if so, show
//        // 'Mailbox' instead of number
//        BooleanType bIsMailboxCall = BT_FALSE;
//        const ERMUserProfileType * profile = ERM_pGetActiveUserProfile();
//        if( NULL != profile )
//        {
//            // compare mailbox number saved for profile with s801 number
//            if(plcc->caller_id_len == profile->voicemailbox_len &&
//               0 == memcmp( profile->voicemailbox, plcc->caller_id, plcc->caller_id_len ))
//            {
//                bIsMailboxCall = BT_TRUE;
//            }
//        }
//
//        if( BT_TRUE == bIsMailboxCall )
//        {   // TODO: Maybe VW wants to show different name for Mailbox
//            // depending on language
//            pCtxCtrl->common.pFrameData->s901.name_len = strlen("Mailbox");
//            memcpy( pCtxCtrl->common.pFrameData->s901.name,
//                    "Mailbox",
//                    pCtxCtrl->common.pFrameData->s901.name_len);
//        }
//        else
//        {
//             /* set the callerId to show in frame*/
//             pCtxCtrl->common.pFrameData->s901.name_len = plcc->caller_id_len;
//             memcpy( pCtxCtrl->common.pFrameData->s901.name,
//                     plcc->caller_id,
//                     pCtxCtrl->common.pFrameData->s901.name_len);
//        }
//     }
//     else
//     {
//         /* set the callerId to show in frame*/
//         pCtxCtrl->common.pFrameData->s901.name_len = 0;
//     }

    //"Anruf",
    pCtxCtrl->common.pFrameData->s901.call_type_len = gAppSdContext.prompts_len[APP_SD_en_S901_ta_head_incoming_call_1_Zeile_1];
    // check length
    if(sizeof(pCtxCtrl->common.pFrameData->s901.call_type) < pCtxCtrl->common.pFrameData->s901.call_type_len)
    {
        pCtxCtrl->common.pFrameData->s901.call_type_len = sizeof(pCtxCtrl->common.pFrameData->s901.call_type);
    }
    // copy data
    (void)memcpy(pCtxCtrl->common.pFrameData->s901.call_type,
                 gAppSdContext.prompts[APP_SD_en_S901_ta_head_incoming_call_1_Zeile_1],
                 pCtxCtrl->common.pFrameData->s901.call_type_len);

    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
    return SUCCESS;
}


SuccessFailType _APP_SD_sfHandleInitFrameS914(AppSdCtxCtrlType *pCtxCtrl)
{
    const ERMBTDeviceTableType *pDevice = ERM_GetBTDevice(pCtxCtrl->s914.deviceId);

    if(pDevice == NULL)
    {
         pCtxCtrl->common.pFrameData->s914.btName_len = 0;
    }
    else
    {
         pCtxCtrl->common.pFrameData->s914.btName_len =
                (AT_BT_DEVICE_NAME_MAX_LEN < pDevice->device_name_len) ?
                 AT_BT_DEVICE_NAME_MAX_LEN : pDevice->device_name_len;

         (void)memcpy(pCtxCtrl->common.pFrameData->s914.btName,
                      pDevice->device_name,
                      pCtxCtrl->common.pFrameData->s914.btName_len);

         pCtxCtrl->common.pFrameData->s914.btName[pCtxCtrl->common.pFrameData->s914.btName_len] = '\0';
    }

    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
    return SUCCESS;
}


SuccessFailType _APP_SD_sfHandleInitFrameS902(AppSdCtxCtrlType *pCtxCtrl)
{
    const ATRspCallStatValType *plcc = APP_PHONE_AT_PNCC_pGetPlccContext(pCtxCtrl->s902.waitingPlccIdx);

    _APP_SD_vActivateFrame(BT_TRUE, __LINE__);

    if(plcc != NULL && plcc->id_avail)
    {
        pCtxCtrl->common.pFrameData->s902.name_len =
                    _APP_SD_u16WriteCallerId( &(pCtxCtrl->common.pFrameData->s902.name),
                                              &(plcc->caller_id),
                                              plcc->caller_id_len);
    }
    else
    {
//        pCtxCtrl->common.pFrameData->s902.name_len =
//                    _APP_SD_u16WriteCallerId( &(pCtxCtrl->common.pFrameData->s902.name),
//                                              NULL, 0);
		// the enum can be used from Screen S211, till the special texts for this Screen are generated
		// fix for ticket #3045 (no name matching)
        pCtxCtrl->common.pFrameData->s902.name_len = gAppSdContext.prompts_len[APP_SD_en_S211_ta_menu_no_nbr_Auswahl_1];

        (void)memcpy(pCtxCtrl->common.pFrameData->s902.name,
                     gAppSdContext.prompts[APP_SD_en_S211_ta_menu_no_nbr_Auswahl_1],
                     pCtxCtrl->common.pFrameData->s902.name_len);
    }

//     if(plcc != NULL && plcc->id_avail)
//     {
//        // check if callerId is number saved for mailbox for active user, if so, show
//        // 'Mailbox' instead of number
//        BooleanType bIsMailboxCall = BT_FALSE;
//        const ERMUserProfileType * profile = ERM_pGetActiveUserProfile();
//        if( NULL != profile )
//        {
//            // compare mailbox number saved for profile with s801 number
//            if(plcc->caller_id_len == profile->voicemailbox_len &&
//               0 == memcmp( profile->voicemailbox, plcc->caller_id, plcc->caller_id_len ))
//            {
//                bIsMailboxCall = BT_TRUE;
//            }
//        }
//
//        if( BT_TRUE == bIsMailboxCall )
//        {   // TODO: Maybe VW wants to show different name for Mailbox
//            // depending on language
//            pCtxCtrl->common.pFrameData->s902.name_len = strlen("Mailbox");
//            memcpy( pCtxCtrl->common.pFrameData->s902.name,
//                    "Mailbox",
//                    pCtxCtrl->common.pFrameData->s902.name_len);
//        }
//        else
//        {
//            /* set the callerId to show in frame*/
//            pCtxCtrl->common.pFrameData->s902.name_len = plcc->caller_id_len;
//            memcpy( pCtxCtrl->common.pFrameData->s902.name,
//                    plcc->caller_id,
//                    pCtxCtrl->common.pFrameData->s902.name_len);
//        }
//     }
//     else
//     {
//         /* set 'unknown' as callerId to show in frame*/
//         pCtxCtrl->common.pFrameData->s902.name_len = 0;
//     }

     pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;

     (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                         MSEC(0),
                                         0);
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS903(AppSdCtxCtrlType *pCtxCtrl)
{
     pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;

     (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                         MSEC(0),
                                         0);
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS929(AppSdCtxCtrlType *pCtxCtrl)
{
    _APP_SD_vActivateFrame(BT_TRUE, __LINE__);
    // copy number into frame data
    pCtxCtrl->common.pFrameData->s929.number_len =
                (AT_CALLER_ID_STRING_MAX_LEN < pCtxCtrl->s929.number_len) ?
                 AT_CALLER_ID_STRING_MAX_LEN : pCtxCtrl->s929.number_len;

    (void)memcpy(pCtxCtrl->common.pFrameData->s929.number,
                 pCtxCtrl->s929.number,
                 pCtxCtrl->common.pFrameData->s929.number_len);

    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                         MSEC(0),
                                         0);
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS933(AppSdCtxCtrlType *pCtxCtrl)
{
    const ERMPairReqType *pPairRequest = ERM_pGetPairRequest();

    if(pCtxCtrl->s933.pprsFailed)
    {
        if (BT_FALSE == _APP_SD_bPhoneContextActive())
        {
            _APP_SD_vReleasePhoneContext();
        }
        else
        {
            _APP_SD_vCtxHistoryStepBack();
        }
        return SUCCESS;
    }

    pCtxCtrl->common.pFrameData->s933.btName_len =
            (AT_BT_DEVICE_NAME_MAX_LEN < pPairRequest->name_len) ?
             AT_BT_DEVICE_NAME_MAX_LEN : pPairRequest->name_len;

    (void)memcpy(pCtxCtrl->common.pFrameData->s933.btName,
                 pPairRequest->device_name,
                 pCtxCtrl->common.pFrameData->s933.btName_len);

    pCtxCtrl->common.pFrameData->s933.btName[pCtxCtrl->common.pFrameData->s933.btName_len] = '\0';

    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                         MSEC(0),
                                         0);
    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS934(AppSdCtxCtrlType *pCtxCtrl)
{
    // set bt device name
    const ERMBTDeviceTableType *devInfo = ERM_GetBTDevice(pCtxCtrl->s934.deviceId);
    if( NULL == devInfo )
    {
        pCtxCtrl->common.pFrameData->s934.btName_len = 0;
    }
    else
    {
        pCtxCtrl->common.pFrameData->s934.btName_len =
                (AT_BT_DEVICE_NAME_MAX_LEN < devInfo->device_name_len) ?
                 AT_BT_DEVICE_NAME_MAX_LEN : devInfo->device_name_len;

        (void)memcpy(pCtxCtrl->common.pFrameData->s934.btName,
                     devInfo->device_name,
                     pCtxCtrl->common.pFrameData->s934.btName_len);
    }

    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
    return SUCCESS;
}



SuccessFailType _APP_SD_sfHandleInitFrameS941(AppSdCtxCtrlType *pCtxCtrl)
{
    const ATRspCallStatValType *plcc = APP_PHONE_AT_PNCC_pGetPlccContext(pCtxCtrl->s941.plccIndex);

    //pCtxCtrl->common.pFrameData->s941.name_len =
    //            _APP_SD_u16WriteCallerId(&(pCtxCtrl->common.pFrameData->s941.name),
    //                                     &(plcc->caller_id),
    //                                      plcc->caller_id_len);

    if(plcc != NULL && plcc->id_avail)
    {
        pCtxCtrl->common.pFrameData->s941.name_len =
                    _APP_SD_u16WriteCallerId( &(pCtxCtrl->common.pFrameData->s941.name),
                                              &(plcc->caller_id),
                                              plcc->caller_id_len);
    }
    else
    {
//        pCtxCtrl->common.pFrameData->s941.name_len =
//                    _APP_SD_u16WriteCallerId( &(pCtxCtrl->common.pFrameData->s941.name),
//                                              NULL, 0);
		// the enum can be used from Screen S211, till the special texts for this Screen are generated
		// fix for ticket #3045 (no name matching)
        pCtxCtrl->common.pFrameData->s941.name_len = gAppSdContext.prompts_len[APP_SD_en_S211_ta_menu_no_nbr_Auswahl_1];

        (void)memcpy(pCtxCtrl->common.pFrameData->s941.name,
                     gAppSdContext.prompts[APP_SD_en_S211_ta_menu_no_nbr_Auswahl_1],
                     pCtxCtrl->common.pFrameData->s941.name_len);
    }

//     if(plcc != NULL && plcc->id_avail)
//     {
//         /* set the callerId to show in frame*/
//         pCtxCtrl->common.pFrameData->s941.name_len = plcc->caller_id_len;
//         memcpy( pCtxCtrl->common.pFrameData->s941.name,
//                 plcc->caller_id,
//                 pCtxCtrl->common.pFrameData->s941.name_len);
//     }
//     else
//     {
//         /* set the callerId to show in frame*/
//         pCtxCtrl->common.pFrameData->s941.name_len = 0;
//     }

     pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;

     (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                         MSEC(0),
                                         0);

    return SUCCESS;

}

SuccessFailType _APP_SD_sfHandleInitFrameS942(AppSdCtxCtrlType *pCtxCtrl)
{
    const ATRspCallStatValType *plcc = APP_PHONE_AT_PNCC_pGetPlccContext(pCtxCtrl->s942.plccIndex);

    //pCtxCtrl->common.pFrameData->s942.name_len =
    //            _APP_SD_u16WriteCallerId(&(pCtxCtrl->common.pFrameData->s942.name),
    //                                     &(plcc->caller_id),
    //                                      plcc->caller_id_len);


    if(plcc != NULL && plcc->id_avail)
    {
        pCtxCtrl->common.pFrameData->s942.name_len =
                    _APP_SD_u16WriteCallerId( &(pCtxCtrl->common.pFrameData->s942.name),
                                              &(plcc->caller_id),
                                              plcc->caller_id_len);
    }
    else
    {
//        pCtxCtrl->common.pFrameData->s942.name_len =
//                    _APP_SD_u16WriteCallerId( &(pCtxCtrl->common.pFrameData->s942.name),
//                                              NULL, 0);
		// the enum can be used from Screen S211, till the special texts for this Screen are generated
		// fix for ticket #3045 (no name matching)
        pCtxCtrl->common.pFrameData->s942.name_len = gAppSdContext.prompts_len[APP_SD_en_S211_ta_menu_no_nbr_Auswahl_1];

        (void)memcpy(pCtxCtrl->common.pFrameData->s942.name,
                     gAppSdContext.prompts[APP_SD_en_S211_ta_menu_no_nbr_Auswahl_1],
                     pCtxCtrl->common.pFrameData->s942.name_len);
    }

//     if(plcc != NULL && plcc->id_avail)
//     {
//         /* set the callerId to show in frame*/
//         pCtxCtrl->common.pFrameData->s942.name_len = plcc->caller_id_len;
//         memcpy( pCtxCtrl->common.pFrameData->s942.name,
//                 plcc->caller_id,
//                 pCtxCtrl->common.pFrameData->s942.name_len);
//     }
//     else
//     {
//         /* set the callerId to show in frame*/
//         /* unknown */
//         pCtxCtrl->common.pFrameData->s942.name_len = 0;
//     }

     pCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

     (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                         MSEC(0),
                                         0);

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameS945(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->s945.subState)
    {
        case APP_SD_S945_NUMBER_REQUESTED:
        {
            APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_ERROR_BUSY;

            if( pCtxCtrl->s945.pbType == APP_PHONEBOOK_enUsersPB )
            {
                /* we have a pbIndex to call (if pnIndex is 0, we will call the default number */
                rspCode = APP_PHONE_rcDialPnIndex( _APP_SD_vInitPendingS945_Dial_Cb,
                                                   pCtxCtrl->s945.pbIndex,
                                                   pCtxCtrl->s945.pnIndex );
            }
            else
            {
                /* we have a number to dial */
                // check number, if invalid, show info to user
                if( BT_FALSE == APP_PHONE_bIsValidPhoneNumber(pCtxCtrl->s945.number, pCtxCtrl->s945.number_len))
                {
                    _APP_SD_vInitFrameS806();
                    return SUCCESS;
                }
                rspCode = APP_PHONE_rcDialNumber( _APP_SD_vInitPendingS945_Dial_Cb,
                                                  pCtxCtrl->s945.number,
                                                  pCtxCtrl->s945.number_len );
            }

            switch(rspCode)
            {
                case APP_COMMON_RSP_ERROR_BUSY:
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(10), 0);
                    return SUCCESS;
                case APP_COMMON_RSP_OK:
                    /* go on */
                    break;
                default:
                    // #4365 dial was not sent out and APP_PHONE will also never indicate an outgoing call
                    // timout. To avoid a freeze with pending init of S801, return FAIL
                    return FAIL;
            }

            pCtxCtrl->s945.subState = APP_SD_S945_NUMBER_DIALED;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        }
        case APP_SD_S945_NUMBER_DIALED:
            if( pCtxCtrl->s945.pbType == APP_PHONEBOOK_enPbUnknown )
            {
                /* get the callerId to show in frame*/
                pCtxCtrl->common.pFrameData->s945.name_len =
                        (AT_CALLER_ID_STRING_MAX_LEN < pCtxCtrl->s945.number_len) ?
                         AT_CALLER_ID_STRING_MAX_LEN : pCtxCtrl->s945.number_len;

                (void)memcpy(pCtxCtrl->common.pFrameData->s945.name,
                             pCtxCtrl->s945.number,
                             pCtxCtrl->common.pFrameData->s945.name_len);
            }

            pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
        default:

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandleInitFrameS945: invalid subState %d",
                          pCtxCtrl->s945.subState);

            pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
    }

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameSC12(AppSdCtxCtrlType *pCtxCtrl)
{
    APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_ERROR_BUSY;
    AT_DeviceId deviceId = ERM_pGetPlayerHeadsetProfile(gAppSdContext.sc12profileId)->deviceIndex;
    const ERMBTDeviceTableType *pBtDevice = ERM_GetBTDevice(deviceId);
    gAppSdContext.sc12DeviceId = deviceId;

    if(pBtDevice == NULL)
    {

        DEBUG_VALUE2( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandleInitFrameSC12: invalid player device %d (player profile %d)",
                      deviceId,
                      gAppSdContext.sc12profileId);
        return FAIL;
    }

    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "sfHandleInitFrameSC12: gAppSdContext.SubState %d",gAppSdContext.sc12SubState);

    switch(gAppSdContext.sc12SubState)
    {
        case APP_SD_SC12_DISCONNECT_NOT_SENT:
        {
            rspCode = APP_DEVICE_rcDeactivateMdiDevice( _APP_SD_vInitPendingSC12_Cb );

            switch(rspCode)
            {
                case APP_COMMON_RSP_ERROR_BUSY:

                    if (gAppSdContext.disconnectPlayerCounter >= 35)
                    {
                        gAppSdContext.disconnectPlayerCounter = 0;
                        APP_DEVICE_vEmergencyReleaseContextFromAppSd();

                        //(void) _APP_SD_vReleasePendingContext(__LINE__);
                        DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "sfHandlePendingButtonS572: response for deactivate mdi busy more than 10 times: emergency release context app_device;");

                    }
                    else
                    {
                        gAppSdContext.disconnectPlayerCounter += 1;
                    }

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(100), 0);

                    return SUCCESS;
                case APP_COMMON_RSP_OK:
                    /* go on */
                    gAppSdContext.disconnectPlayerCounter = 0;
                    gAppSdContext.sc12SubState = APP_SD_SC12_DISCONNECT_SENT;
                    break;
                default:
                    // To avoid a freeze with pending init of SC12, return FAIL

                    DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandleInitFrSC12: DeactMdiDev failed");
                    return FAIL;
            }
            break;
        }
        case APP_SD_SC12_CONNECT_NOT_SENT:
        {
            rspCode = APP_DEVICE_rcActivateMdiDevice( _APP_SD_vInitPendingSC12_Cb, deviceId);
            switch(rspCode)
            {
                case APP_COMMON_RSP_ERROR_BUSY:
                {
                    APP_DEVICE_vSetActivatePlayerPendingFlag(_APP_SD_vInitPendingSC12_Cb, deviceId);
                    break;
                }
                case APP_COMMON_RSP_OK:
                {
                    /* go on */
                    gAppSdContext.sc12SubState = APP_SD_SC12_CONNECT_SENT;
                    break;
                }
                default:
                    // To avoid a freeze with pending init of SC12, return FAIL

                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandleInitFrSC12: act failed %d",
                                  deviceId);
                    return FAIL;
            }
            break;
        }
        default:
            break;
    }

    pCtxCtrl->common.pFrameData->sc12.btName_len =
            (AT_BT_DEVICE_NAME_MAX_LEN < pBtDevice->device_name_len) ?
             AT_BT_DEVICE_NAME_MAX_LEN : pBtDevice->device_name_len;

    (void)memcpy(pCtxCtrl->common.pFrameData->sc12.btName,
                 pBtDevice->device_name,
                 pCtxCtrl->common.pFrameData->sc12.btName_len);

    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                         MSEC(0),
                                         0);

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameSC12_2(AppSdCtxCtrlType *pCtxCtrl)
{
    APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_ERROR_BUSY;
    AT_DeviceId deviceId = gAppSdContext.sc12DeviceId;
    const ERMBTDeviceTableType *pBtDevice = ERM_GetBTDevice(deviceId);
    const ERMPhysicalBTDeviceType *pPhyDevice =  ERM_pGetPhyDevice(deviceId);
    if(pBtDevice == NULL)
    {
        if (pPhyDevice == NULL)
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandleInitFrameSC12_2: invalid player device %d",
                          deviceId);
        }

    }

    switch(gAppSdContext.sc12SubState)
    {
        case APP_SD_SC12_DISCONNECT_NOT_SENT:
        {
            rspCode = APP_DEVICE_rcDeactivateMdiDevice( _APP_SD_vInitPendingSC12_Cb );

            switch(rspCode)
            {
                case APP_COMMON_RSP_ERROR_BUSY:

                    if (gAppSdContext.disconnectPlayerCounter >= 10)
                    {
                        gAppSdContext.disconnectPlayerCounter = 0;
                        APP_DEVICE_vEmergencyReleaseContextFromAppSd();

                        //(void) _APP_SD_vReleasePendingContext(__LINE__);
                        DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "sfHandleInitframeSC12: response for deactivate mdi busy more than 10 times: emergency release context app_device;");

                    }
                    else
                    {
                        gAppSdContext.disconnectPlayerCounter += 1;
                    }

                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(100), 0);

                    return SUCCESS;
                case APP_COMMON_RSP_OK:
                    /* go on */
                    gAppSdContext.disconnectPlayerCounter = 0;
                    gAppSdContext.sc12SubState = APP_SD_SC12_DISCONNECT_SENT;
                    break;
                default:
                    // To avoid a freeze with pending init of SC12, return FAIL

                    DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandleInitFrSC12_2: DeactMdiDev failed");
                    return FAIL;
            }
            break;
        }
        case APP_SD_SC12_CONNECT_NOT_SENT:
        {
            rspCode = APP_DEVICE_rcActivateMdiDevice( _APP_SD_vInitPendingSC12_Cb, deviceId);
            switch(rspCode)
            {
                case APP_COMMON_RSP_ERROR_BUSY:
                {
                    gAppSdContext.connectCounter += 1;
                    if (gAppSdContext.connectCounter >=10)
                    {
                        APP_DEVICE_vEmergencyReleaseContextFromAppSd();
                        gAppSdContext.connectCounter = 0;
                    }
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                        MSEC(100), 0);
                    return SUCCESS;
                }
                case APP_COMMON_RSP_OK:
                {
                    /* go on */
                    gAppSdContext.connectCounter = 0;
                    gAppSdContext.sc12SubState = APP_SD_SC12_CONNECT_SENT;
                    break;
                }
                default:
                    // To avoid a freeze with pending init of SC12, return FAIL

                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "sfHandleInitFrSC12_2: act failed %d",
                                  deviceId);
                    return FAIL;
            }
            break;
        }
        default:
            break;
    }

    if(pBtDevice != NULL)
    {

        pCtxCtrl->common.pFrameData->sc12.btName_len =
                (AT_BT_DEVICE_NAME_MAX_LEN < pBtDevice->device_name_len) ?
                 AT_BT_DEVICE_NAME_MAX_LEN : pBtDevice->device_name_len;

        (void)memcpy(pCtxCtrl->common.pFrameData->sc12.btName,
                     pBtDevice->device_name,
                     pCtxCtrl->common.pFrameData->sc12.btName_len);
    }
    else if (pPhyDevice != NULL)
    {
        pCtxCtrl->common.pFrameData->sc12.btName_len =
                (AT_BT_DEVICE_NAME_MAX_LEN < pPhyDevice->name_len) ?
                 AT_BT_DEVICE_NAME_MAX_LEN : pPhyDevice->name_len;

        (void)memcpy(pCtxCtrl->common.pFrameData->sc12.btName,
                     pPhyDevice->name,
                     pCtxCtrl->common.pFrameData->sc12.btName_len);
    }

    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                         MSEC(0),
                                         0);

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameSC13(AppSdCtxCtrlType *pCtxCtrl)
{
    switch(pCtxCtrl->sc13.subState)
    {
        case APP_SD_SC13_START_INQUIRY_NOT_SENT:
        {
            // start inquiry
            APP_COMMON_enResponseCode rspCode = ERM_rcStartInquiry( _APP_SD_vInitPendingSC13_Cb);

            switch(rspCode)
            {
                case APP_COMMON_RSP_ERROR_BUSY:
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                              MSEC(10), 0);
                    break;
                case APP_COMMON_RSP_OK:
                    // wait for callback being called
                    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
                    break;
                default:

                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HdlInitFrSc13: err %d, goto Idle",
                                  rspCode);
                    // SUSANNE: 21.11.2009: InitIdleScreen is called in HandleInitFrame() main function
                    // when we return FAIL here
                    //_APP_SD_vInitIdleScreen(0);
                    return FAIL;
            }
            break;
        }
        case APP_SD_SC13_START_INQUIRY_SENT:
            //RS: we received an inquiry end but were hide by a popup, so handle the
            //    inquiry end event now
            if( pCtxCtrl->sc13.inquiryEndRcvd == BT_TRUE )
            {

                DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HaInitFrameSC13: call sfHaErmNotInqEnd");

                if(_APP_SD_sfHandleErmNotificationInquiryEnd() != SUCCESS)
                {
                    //RS: that should never happen

                    DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "HaInitFrameSC13: sfHaErmNotInqEnd failed!");

                    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
                    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                              MSEC(0),
                                                              0);
                }
            }
            else
            {
                pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                          MSEC(0),
                                                          0);
            }
            break;
        case APP_SD_SC13_SHOW_ONLY:
        default:
            pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
            break;
    }

    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameSC16(AppSdCtxCtrlType *pCtxCtrl)
{
    /* get setting for active user profile */
    const ERMUserProfileType * profile = ERM_pGetActiveUserProfile();
    if( NULL == profile )
    {
        return FAIL;
    }

    gAppSdContext.pCurCtxCtrl->common.state         = APP_SD_CTX_FRAME_REQ_DATA;
    gAppSdContext.pCurCtxCtrl->sc16.bPlayCallerName = profile->ringtone_alternating;

    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(10),
                                        0);


    return SUCCESS;
}

SuccessFailType _APP_SD_sfHandleInitFrameSB34(AppSdCtxCtrlType *pCtxCtrl)
{
    Uint8Type pBootVerNumber[VWDB_EE_ADDDRESS_BootSWLogicalBlockVersion_LEN + 1];
    Uint8Type pE2promVer[VWDB_EE_ADDDRESS_UHV_EEPROM_Version_LEN_ASCII + 1];
    ERMSWVersionStringType ckVersion;
    ERMBtChipVersionType btChipVersion;
    const char *pNotAvailable = "N/A";
    const char *pHc = "HC";
    const char *pBtm = "BTM";
    const char *pBoot = "FBL";
    const char *pE2Prom = "E2P";
    const char *pBTChip = "BT-Chip";

    char *pBuffer = (char *)&(pCtxCtrl->common.pFrameData->sb34.version[0]);
    Uint16Type *pBufferLen = &(pCtxCtrl->common.pFrameData->sb34.version_len);

    *pBufferLen = 0;

    if( ERM_rcGetCKSWVersionString(&ckVersion) != APP_COMMON_RSP_OK )
    {
        ckVersion.version_len = strlen(pNotAvailable);
        memcpy(ckVersion.version, pNotAvailable, ckVersion.version_len);
        ckVersion.version[ckVersion.version_len] = '\0';


        DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "HaInitFrSB34: GetCKSW() failed");
    }
    if (ERM_rcGetBtChipVersion(&btChipVersion) != APP_COMMON_RSP_OK)
    {
        memcpy(btChipVersion.hw_version,pNotAvailable, strlen(pNotAvailable));
        btChipVersion.hw_version[strlen(pNotAvailable)] = '\0';
        memcpy(btChipVersion.sw_version,pNotAvailable, strlen(pNotAvailable));
        btChipVersion.sw_version[strlen(pNotAvailable)] = '\0';
        memcpy(btChipVersion.manufacturer,pNotAvailable, strlen(pNotAvailable));
        btChipVersion.manufacturer[strlen(pNotAvailable)] = '\0';


        DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "HaInitFrSB34: ERM_rcGetBtChipVersion() failed");
    }

    if(EEPROM_enGetByteSequenceFromRamMirror(pBootVerNumber, VWDB_EE_ADDDRESS_BootSWLogicalBlockVersion_LEN, EEPROM_LAYOUT_ENUM_BootSWLogicalBlockVersion) != COMMON_RSP_OK)
    {
        memcpy(pBootVerNumber, pNotAvailable, strlen(pNotAvailable));
        pBootVerNumber[strlen(pNotAvailable)] = '\0';


        DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "HaInitFrSB34: GetBSVN() failed");
    }
    else
    {
        pBootVerNumber[VWDB_EE_ADDDRESS_BootSWLogicalBlockVersion_LEN] = '\0';
    }


    if(EEPROM_enGetEepromLayoutVersionNumber(pE2promVer, VWDB_EE_ADDDRESS_UHV_EEPROM_Version_LEN_ASCII) != COMMON_RSP_OK)
    {
        memcpy(pE2promVer, pNotAvailable, strlen(pNotAvailable));
        pE2promVer[strlen(pNotAvailable)] = '\0';


        DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "HaInitFrSB34: GetE2LVN() failed");
    }
    else
    {
        pE2promVer[VWDB_EE_ADDDRESS_UHV_EEPROM_Version_LEN_ASCII] = '\0';
    }

    *pBufferLen = snprintf( pBuffer, APP_SD_MAX_VERSION_DATA,
                            "%s: %s\n%s: %s\n%s: %s %s %s\n%s: %s\n%s: %s",
                            pHc, SoftwareVersion,
                            pBtm, ckVersion.version,
                            pBTChip, btChipVersion.hw_version, btChipVersion.sw_version, btChipVersion.manufacturer,
                            pBoot, pBootVerNumber,
                            pE2Prom, pE2promVer);

    if(*pBufferLen > APP_SD_MAX_VERSION_DATA)
    {

        DEBUG_VALUE2( APP_SD_SWI_ERR, MOD_APP_SD, "HaInitFrSB34: buffer to small, %d/%d",
                      *pBufferLen,
                      APP_SD_MAX_VERSION_DATA);

        *pBufferLen = APP_SD_MAX_VERSION_DATA;
    }



    pCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                         MSEC(0),
                                         0);

    return SUCCESS;
}


/*----------------------------------------------------------------------------*/
/* Function :   APP_SD_u8GetContextId                                       */
/**
  \brief        This function is get the current frame Id of the SD back.

  \return       Uint8Type
                APP_SD_enContextId
                context Id of the KPB
 */
/*----------------------------------------------------------------------------*/
Uint8Type APP_SD_u8GetContextId (void)
{
    return ((Uint8Type)gAppSdContext.pCurCtxCtrl->common.ctxId);
}

/*----------------------------------------------------------------------------*/
/* Function :   APP_SD_vSetVcrIsActive                                       */
/**
  \brief        This function set that the VCR is activataed with PTT..

  \return       void
 */
/*----------------------------------------------------------------------------*/
void APP_SD_vSetVcrIsActive (void)
{
    _APP_SD_u8VcrActive = BT_TRUE;
}

/*----------------------------------------------------------------------------*/
/* Function :   APP_SD_vListDataRequest                                       */
/**
  \brief        This function is called from ListControl to request the needed
                elements for a list

  \param        firstIdx
                The first index of the requested list

  \param        number
                The number of request list elements

  \return       void

 */
/*----------------------------------------------------------------------------*/
void APP_SD_vListDataRequest(Uint16Type firstIdx, Uint16Type number)
{
    if(number == 0)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vListDataRequest: req number is 0 for ctxId %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }
    if(( gAppSdContext.pCurCtxCtrl->common.ctxId < NUM_ELEMENTS_OF_ARRAY(_APP_SD_vListDataRequestTable)) &&
       (_APP_SD_vListDataRequestTable[gAppSdContext.pCurCtxCtrl->common.ctxId] != NULL))
    {
        (void)_APP_SD_vListDataRequestTable[gAppSdContext.pCurCtxCtrl->common.ctxId](firstIdx, number);
    }
    else
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vListDataRequest: no handler for ctx %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
    }
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_vSetStaticText                                        */
/**
  \brief        Utility function to write the specified text to the provided data buffer

  \param        txtId
                Id to specify the desired text

  \param        pData
                Buffer to put the text in

  \return       void

 */
/*----------------------------------------------------------------------------*/
void _APP_SD_vSetStaticText(APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId, KpbCellNameType *pData)
{
    if( pData == NULL )
    {

        DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "SetStaticText: pData NULL");
        return;
    }
    pData->length = gAppSdContext.prompts_len[txtId];
    if( sizeof(pData->content) < pData->length )
    {
        pData->length = sizeof(pData->content);
    }

    (void)memcpy(pData->content,
                 gAppSdContext.prompts[txtId],
                 pData->length);
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_vListDataRequest_S001                                 */
/**
  \brief        Function to request the list data for context S001

  \param        firstIdx
                The first index of the requested list

  \param        number
                The number of request list elements

  \return       void

 */
/*----------------------------------------------------------------------------*/
void _APP_SD_vListDataRequest_S001(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S001_ta_menu_cancel_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_S002(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                if(0 < ERM_u16GetNumberOfUserProfiles())
                {
                    txtId = APP_SD_en_S002_ta_connect_Auswahl_1;
                }
                else
                {
                    txtId = APP_SD_en_S002_ta_menu_bt_help_Auswahl_1;
                }
                break;
            case 2:
                txtId = APP_SD_en_S002_ta_phone_search_Auswahl_1;
                break;
            case 3:
                txtId = APP_SD_en_S002_ta_media_player_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}


//void _APP_SD_vListDataRequest_S007(Uint16Type firstIdx, Uint16Type number)
//{
//    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
//    Uint16Type i = 0;
//
//    for( i=firstIdx; i<number+firstIdx; i++)
//    {
//        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
//        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;
//
//        if(pListEntry == NULL)
//        {
//            break;
//        }
//        switch(i)
//        {
//            case 1:
//                txtId = APP_SD_en_S007_ta_menu_ok_Auswahl_1;
//                break;
//            default:
//                txtId = APP_SD_enError;
//                break;
//        }
//
//        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
//        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
//        // shall be set to cell type: menue item
//        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
//    }
//
//    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;
//
//    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
//                                        MSEC(0),
//                                        0);
//}


void _APP_SD_vListDataRequest_S008(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S008_ta_list_back_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}



void _APP_SD_vListDataRequest_SC20(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_SC20_ta_call_handsfree_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}


void _APP_SD_vListDataRequest_S101(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;

//    char *tmpArr[] = { "DUMMY",
//                       "Telefonbuch",
//                       "Nummernwahl",
//                       "Anruflisten",
//                       "Sprachmailbox",
//                       "Mitteilungen",
//                       "Bluetooth",
//                       "Einstellungen",
//                       "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S101_ta_phone_book_Auswahl_1;
                break;
            case 2:
                txtId = APP_SD_en_S101_ta_main_dial_Auswahl_1;
                break;
            case 3:
                txtId = APP_SD_en_S101_ta_main_callstacks_Auswahl_1;
                break;
            case 4:
                txtId = APP_SD_en_S101_ta_main_mailbox_Auswahl_1;
                break;
            case 5:
                if(gAppSdContext.pCurCtxCtrl->s101.messagesAvail == BT_TRUE)
                {
                    txtId = APP_SD_en_S101_ta_main_messages_Auswahl_1;
                }
                else
                {
                    txtId = APP_SD_en_S101_ta_main_bluetooth_Auswahl_1;
                }
                break;
            case 6:
                if(gAppSdContext.pCurCtxCtrl->s101.messagesAvail == BT_TRUE)
                {
                    txtId = APP_SD_en_S101_ta_main_bluetooth_Auswahl_1;
                }
                else
                {
                    txtId = APP_SD_en_S101_ta_main_settings_Auswahl_1;
                }
                break;
            case 7:
                if(gAppSdContext.pCurCtxCtrl->s101.messagesAvail == BT_TRUE)
                {
                    txtId = APP_SD_en_S101_ta_main_settings_Auswahl_1;
                }
                else
                {
                    txtId = APP_SD_en_S101_ta_list_back_Auswahl_1;
                }
                break;
            case 8:
                txtId = APP_SD_en_S101_ta_list_back_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_S102(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S102_ta_list_back_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}


void _APP_SD_vListDataRequest_S104(Uint16Type firstIdx, Uint16Type number)
{

    if( firstIdx == gAppSdContext.pCurCtxCtrl->common.listData.numListElems )
    {
        /* fill up with the static element */
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer( &(gAppSdContext.pCurCtxCtrl->common.listData) );
        if(pListEntry != NULL)
        {
            _APP_SD_vSetStaticText(APP_SD_en_S104_ta_list_back_Auswahl_1, &pListEntry->data);
            pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
        }

        gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;
        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                  MSEC(10), 0);
    }
    else
    {
        APP_COMMON_enResponseCode rspCode = APP_PHONEBOOK_rcRequestCompletePbEntries(
                                                 _APP_SD_vListDataRequest_S104_Cb,
                                                 APP_PHONEBOOK_enUsersPB,
                                                 firstIdx,
                                                 number);
        switch(rspCode)
        {
            case APP_COMMON_RSP_ERROR_BUSY:
                gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;
                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                          MSEC(10), 0);
                break;
            case APP_COMMON_RSP_OK:
                // wait for callback being called
                gAppSdContext.pCurCtxCtrl->common.state  = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
                break;
            default:
                DEBUG_VALUE1(APP_SD_SWI_ERR, MOD_APP_SD, "ListDataReqS104: err %d, goto Idle", rspCode);
                _APP_SD_vInitIdleScreen(0);
                break;
        }
    }
}


void _APP_SD_vListDataRequest_S105(Uint16Type firstIdx, Uint16Type number)
{
    if( firstIdx <= gAppSdContext.pCurCtxCtrl->s105.pnSize )
    {
        APP_COMMON_enResponseCode rspCode = APP_PHONEBOOK_rcRequestCompletePbEntries(
                                                 _APP_SD_vListDataRequest_S105_Cb,
                                                 APP_PHONEBOOK_enUsersPB,
                                                 gAppSdContext.pCurCtxCtrl->s105.pbIndex,
                                                 1);

        switch(rspCode)
        {
            case APP_COMMON_RSP_ERROR_BUSY:
                gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;
                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                          MSEC(10), 0);
                return;
            case APP_COMMON_RSP_OK:
                // wait for callback being called
                gAppSdContext.pCurCtxCtrl->common.state  = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
                return;
            default:

                DEBUG_VALUE1(APP_SD_SWI_ERR, MOD_APP_SD, "ListDataReqS105: err %d, goto Idle", rspCode);
                _APP_SD_vInitIdleScreen(0);
                return;
        }
    }
    else
    {
        /* set only static text */
        AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
        Uint16Type i = 0;
        firstIdx = firstIdx - gAppSdContext.pCurCtxCtrl->s105.pnSize;

        for( i=firstIdx; i<number+firstIdx; i++)
        {
            AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
            APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

            if(pListEntry == NULL)
            {
                break;
            }

            if(ERM_SIVR_FULL_SUPPORTED == ERM_enIsVcrSupported())           /* RT 2429 */
            {
                switch(i)
                {
                    case 1:
                        //TODO: Skip this if VCR is deactivated via Diagnose
                        txtId = APP_SD_en_S105_ta_pb_nametag_Auswahl_1;
                        break;
                    case 2:
                        txtId = APP_SD_en_S105_ta_list_back_Auswahl_1;
                        break;
                    default:
                        txtId = APP_SD_enError;
                        break;
                }
            }
            else
            {
                switch(i)
                {
                    case 1:
                        txtId = APP_SD_en_S105_ta_list_back_Auswahl_1;
                        break;
                    default:
                        txtId = APP_SD_enError;
                        break;
                }
            }

            _APP_SD_vSetStaticText(txtId, &pListEntry->data);
            // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
            // shall be set to cell type: menue item
            pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
        }

        gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;
        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                            MSEC(0),
                                            0);
    }
}


//void _APP_SD_vListDataRequest_S111(Uint16Type firstIdx, Uint16Type number)
//{
//    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
//    Uint16Type i = 0;
////    char *tmpArr[] = { "DUMMY",
////                       "Anrufen",
////                       "Zurueck"};
//
//    for( i=firstIdx; i<number+firstIdx; i++)
//    {
//        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
//        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;
//
//        if(pListEntry == NULL)
//        {
//            break;
//        }
//        switch(i)
//        {
//            case 1:
//                txtId = APP_SD_en_S111_ta_menu_call_Auswahl_1;
//                break;
//            case 2:
//                txtId = APP_SD_en_S111_ta_list_back_Auswahl_1;
//                break;
//            default:
//                txtId = APP_SD_enError;
//                break;
//        }
//
//        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
//        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
//        // shall be set to cell type: menue item
//        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
//    }
//
//    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;
//
//    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
//                                        MSEC(0),
//                                        0);
//}

void _APP_SD_vListDataRequest_S115(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Ok",
//                       "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S115_ta_menu_ok_Auswahl_1;
                break;
            case 2:
                txtId = APP_SD_en_S115_ta_list_back_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}



void _APP_SD_vListDataRequest_S117(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Wiedergeben",
//                       "Aufnehmen",
//                       "Zuruecksetzen",
//                       "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }

        if(BT_TRUE == gAppSdContext.pCurCtxCtrl->s117.bVoiceTagAvailable)
        {
            switch(i)
            {
                case 1:
                    txtId = APP_SD_en_S117_ta_tag_play_Auswahl_1;
                    break;
                case 2:
                    txtId = APP_SD_en_S117_ta_tag_record_Auswahl_1;
                    break;
                case 3:
                    txtId = APP_SD_en_S117_ta_voice_tag_reset_Auswahl_1;
                    break;
                case 4:
                    txtId = APP_SD_en_S117_ta_list_back_Auswahl_1;
                    break;
                default:
                    txtId = APP_SD_enError;
                    break;
            }
        }
        else
        {
            switch(i)
            {
                case 1:
                    txtId = APP_SD_en_S117_ta_tag_play_Auswahl_1;
                    break;
                case 2:
                    txtId = APP_SD_en_S117_ta_tag_record_Auswahl_1;
                    break;
                case 3:
                    txtId = APP_SD_en_S117_ta_list_back_Auswahl_1;
                    break;
                default:
                    txtId = APP_SD_enError;
                    break;
            }
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}



void _APP_SD_vListDataRequest_S201(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Anr. in Abwes",
//                       "Angen. Anrufe",
//                       "Letzte Anrufe",
//                       "Listen löschen",
//                       "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S201_ta_stack_missed_Auswahl_1;
                break;
            case 2:
                txtId = APP_SD_en_S201_ta_stack_dialled_Auswahl_1;
                break;
            case 3:
                txtId = APP_SD_en_S201_ta_stack_received_Auswahl_1;
                break;
            case 4:
                txtId = APP_SD_en_S201_ta_list_back_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_S211(Uint16Type firstIdx, Uint16Type number)
{
    APP_COMMON_enResponseCode rspCode = APP_PHONEBOOK_rcRequestCompletePbEntries(
                                             _APP_SD_vListDataRequest_S211_Cb,
                                             gAppSdContext.pCurCtxCtrl->s211.pbType,
                                             firstIdx, number);
    switch(rspCode)
    {
        case APP_COMMON_RSP_ERROR_BUSY:
            gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;
            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                      MSEC(10), 0);
            break;
        case APP_COMMON_RSP_OK:
            // wait for callback being called
            gAppSdContext.pCurCtxCtrl->common.state  = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
            break;
        default:

            DEBUG_VALUE1(APP_SD_SWI_ERR, MOD_APP_SD, "ListDataReqS211: err %d, goto Idle", rspCode);
            _APP_SD_vInitIdleScreen(0);
            break;
    }
}


void _APP_SD_vListDataRequest_S212(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Anrufen",
//                       "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S212_ta_menu_call_Auswahl_1;
                break;
            case 2:
                txtId = APP_SD_en_S212_ta_list_back_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}
void _APP_SD_vListDataRequest_S213(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S213_ta_list_back_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}


/*********************************/
// Sms
/*********************************/
void _APP_SD_vListDataRequest_S404(Uint16Type firstIdx, Uint16Type number)
{
    if( firstIdx == gAppSdContext.pCurCtxCtrl->common.listData.numListElems )
    {
        /* fill up with the static element */
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer( &(gAppSdContext.pCurCtxCtrl->common.listData) );
        if(pListEntry != NULL)
        {
            _APP_SD_vSetStaticText(APP_SD_en_S404_ta_list_back_Auswahl_1, &pListEntry->data);
            pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
        }

        gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;
        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                  MSEC(10), 0);
    }
    else
    {
        APP_COMMON_enResponseCode rspCode = APP_SMS_rcReadSmsPreview(
                                                 _APP_SD_vListDataRequest_S404_Cb,
                                                 firstIdx, number);
        switch(rspCode)
        {
            case APP_COMMON_RSP_ERROR_BUSY:
                gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;
                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                          MSEC(10), 0);
                break;
            case APP_COMMON_RSP_OK:
                // wait for callback being called
                gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
                break;
            default:

                DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "ListDataReqS404: err %d, goto Idle", rspCode);
                _APP_SD_vInitIdleScreen(0);
                break;
        }
    }
}

void _APP_SD_vListDataRequest_S405(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Zeigen",
//                       "Vorlesen",
//                       "Sendezeit",
//                       "Rueckruf",
//                       "Loeschen",
//                       "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        if(ERM_SIVR_FULL_SUPPORTED == ERM_enIsVcrSupported())           /* RT 2429 */
        {
            switch(i)
            {
                case 1:
                    txtId = APP_SD_en_S405_ta_menu_view_Auswahl_1;
                    break;
                case 2:
                    txtId = APP_SD_en_S405_ta_read_out_sms_Auswahl_1;
                    break;
                case 3:
                    txtId = APP_SD_en_S405_ta_sms_time_Auswahl_1;
                    break;
                case 4:
                    txtId = APP_SD_en_S405_ta_sms_call_Auswahl_1;
                    break;
                case 5:
                    txtId = APP_SD_en_S405_ta_menu_delete_Auswahl_1;
                    break;
                case 6:
                    txtId = APP_SD_en_S405_ta_list_back_Auswahl_1;
                    break;
                default:
                    txtId = APP_SD_enError;
                    break;
            }
        }
        else
        {
            switch(i)
            {
                case 1:
                    txtId = APP_SD_en_S405_ta_menu_view_Auswahl_1;
                    break;
                case 2:
                    txtId = APP_SD_en_S405_ta_sms_time_Auswahl_1;
                    break;
                case 3:
                    txtId = APP_SD_en_S405_ta_sms_call_Auswahl_1;
                    break;
                case 4:
                    txtId = APP_SD_en_S405_ta_menu_delete_Auswahl_1;
                    break;
                case 5:
                    txtId = APP_SD_en_S405_ta_list_back_Auswahl_1;
                    break;
                default:
                    txtId = APP_SD_enError;
                    break;
            }
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_S406(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S406_ta_list_back_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}




void _APP_SD_vListDataRequest_S407(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Abbrechen"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S407_ta_menu_cancel_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_S409(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S409_ta_list_back_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }
        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}


void _APP_SD_vListDataRequest_S410(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Abbruch"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S410_ta_menu_cancel_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}



void _APP_SD_vListDataRequest_S413(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Ok",
//                       "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S413_ta_menu_ok_Auswahl_1;
                break;
            case 2:
                txtId = APP_SD_en_S413_ta_list_back_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}



/*********************************/
// Bluetooth
/*********************************/
void _APP_SD_vListDataRequest_S502(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Benutzer",
//                       "Neuer Benutzer",
//                       "Sichtbarkeit",
//                       "Media Player",
//                       "HeadSet",
//                       "Telefonname",
//                       "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }

        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S502_ta_menu_user_Auswahl_1;
                break;
            case 2:
                txtId = APP_SD_en_S502_ta_menu_new_user_Auswahl_1;
                break;
            case 3:
                txtId = APP_SD_en_S502_ta_bt_visibility_Auswahl_1;
                break;
#ifdef UHV_ACTIVATE_FEATURE_HEADSET
            case 4:
                if(gAppSdContext.pCurCtxCtrl->s502.playerAvail == BT_TRUE)
                {
                    txtId = APP_SD_en_S502_ta_media_player_Auswahl_1;
                }
                else
                {
                    txtId = APP_SD_en_S502_ta_bt_accessory_Auswahl_1;
                }
                break;
            case 5:
                if(gAppSdContext.pCurCtxCtrl->s502.playerAvail == BT_TRUE)
                {
                    txtId = APP_SD_en_S502_ta_bt_accessory_Auswahl_1;
                }
                else
                {
                    txtId = APP_SD_en_S502_ta_bt_own_name_Auswahl_1;
                }
                break;
            case 6:
                if(gAppSdContext.pCurCtxCtrl->s502.playerAvail == BT_TRUE)
                {
                    txtId = APP_SD_en_S502_ta_bt_own_name_Auswahl_1;
                }
                else
                {
                    txtId = APP_SD_en_S502_ta_list_back_Auswahl_1;
                }
                break;
            case 7:
                txtId = APP_SD_en_S502_ta_list_back_Auswahl_1;
                break;
#else
            case 4:
                if(gAppSdContext.pCurCtxCtrl->s502.playerAvail == BT_TRUE)
                {
                    txtId = APP_SD_en_S502_ta_media_player_Auswahl_1;
                }
                else
                {
                    txtId = APP_SD_en_S502_ta_bt_own_name_Auswahl_1;
                }
                break;
            case 5:
                if(gAppSdContext.pCurCtxCtrl->s502.playerAvail == BT_TRUE)
                {
                    txtId = APP_SD_en_S502_ta_bt_own_name_Auswahl_1;
                }
                else
                {
                    txtId = APP_SD_en_S502_ta_list_back_Auswahl_1;
                }
                break;
            case 6:
                txtId = APP_SD_en_S502_ta_list_back_Auswahl_1;
                break;
#endif
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_S512(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);

    Uint16Type listIndex = 0;
    while( (listIndex = APP_SD_LC_u16GetNextListIndex(pListCtrl)) > 0)
    {
        if( listIndex < (gAppSdContext.pCurCtxCtrl->s512.numDevs + 1) )
        {
             const ERMBTDeviceTableType *pEntry = NULL;
            AppSdListBufType        *pListEntry = NULL;

            AT_DeviceId deviceId = ERM_GetDeviceIdOfUmpteenthPhone(listIndex);
            if(deviceId == AT_INVALID_DEVICE_ID)
            {   // no more device
                break;
            }

            /* get paired device name */
            pEntry = ERM_GetBTDevice(deviceId);

            // now we know that there is another valid element, so request
            // listBuffer
            pListEntry = APP_SD_stGetListBuffer(pListCtrl);

            if(pListEntry == NULL)
            {
                break;
            }

            // copy bt user friendly name
            pListEntry->data.length = (sizeof(pListEntry->data.content) < pEntry->device_name_len) ?
                                       sizeof(pListEntry->data.content) : pEntry->device_name_len;
            (void)memcpy(pListEntry->data.content,
                         pEntry->device_name,
                         pListEntry->data.length);

             // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
             // shall be set to cell type: menue item
             pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
        }
        else
        {
            /* set only static text */
            AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
            AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
            APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;
            Uint16Type index = listIndex - gAppSdContext.pCurCtxCtrl->s512.numDevs;

            if(pListEntry == NULL)
            {
                break;
            }
            switch(index)
            {
                case 1:
                    txtId = APP_SD_en_S512_ta_menu_cancel_Auswahl_1;
                    break;
                default:
                    txtId = APP_SD_enError;
                    break;
            }

            _APP_SD_vSetStaticText(txtId, &pListEntry->data);
            // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
            // shall be set to cell type: menue item
            pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
        }
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}



void _APP_SD_vListDataRequest_S513(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S513_ta_menu_ok_Auswahl_1;
                break;
            case 2:
                txtId = APP_SD_en_S513_ta_list_back_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_S515(Uint16Type firstIdx, Uint16Type number)
{
    if( firstIdx < gAppSdContext.pCurCtxCtrl->s515.numDevs + 1 )
    {
        APP_COMMON_enResponseCode rspCode = ERM_rcGetInquiryResult(
                                             _APP_SD_vListDataRequest_S515_Cb,
                                             gAppSdContext.pCurCtxCtrl->s515.deviceType,
                                             firstIdx, number);
        switch(rspCode)
        {
            case APP_COMMON_RSP_ERROR_BUSY:
                gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;
                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                          MSEC(10), 0);
                break;
            case APP_COMMON_RSP_OK:
                // wait for callback being called
                gAppSdContext.pCurCtxCtrl->common.state  = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
                break;
            default:

                DEBUG_VALUE1(APP_SD_SWI_ERR, MOD_APP_SD, "ListDataReqS515: err %d, goto Idle", rspCode);
                _APP_SD_vInitIdleScreen(0);
                return;
        }
    }
    else
    {
        /* set only static text */
        AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
        Uint16Type i = 0;

        firstIdx = firstIdx - gAppSdContext.pCurCtxCtrl->s515.numDevs;

        for( i=firstIdx; i<number+firstIdx; i++)
        {
            AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
            APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

            if(pListEntry == NULL)
            {
                break;
            }
            switch(i)
            {
                case 1:
                    txtId = APP_SD_en_S515_ta_list_back_Auswahl_1;
                    break;
                default:
                    txtId = APP_SD_enError;
                    break;
            }

            _APP_SD_vSetStaticText(txtId, &pListEntry->data);
            // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
            // shall be set to cell type: menue item
            pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
        }

        gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;
        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                            MSEC(0),
                                            0);
    }
}



void _APP_SD_vListDataRequest_S520(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S520_ta_menu_cancel_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}
void _APP_SD_vListDataRequest_S52C(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "pListEntry == NULL");
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S52C_ta_menu_ok_Auswahl_1;
                break;
            case 2:
                txtId = APP_SD_en_S52C_ta_menu_cancel_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_S541(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);

    Uint16Type listIndex = 0;

    while( (listIndex = APP_SD_LC_u16GetNextListIndex(pListCtrl)) > 0)
    {
        if( listIndex < (gAppSdContext.pCurCtxCtrl->s541.numDevs + 1) )
        {
             const ERMBTDeviceTableType *pEntry = NULL;
            AppSdListBufType        *pListEntry = NULL;

            AT_DeviceId deviceId = ERM_GetDeviceIdOfUmpteenthPhone(listIndex);

            if(deviceId == AT_INVALID_DEVICE_ID)
            {   // no more device
                break;
            }

            /* get paired device name */
            pEntry = ERM_GetBTDevice(deviceId);

            // now we know that there is another valid element, so request
            // listBuffer
            pListEntry = APP_SD_stGetListBuffer(pListCtrl);

            if(pListEntry == NULL)
            {
                break;
            }

            // copy bt user friendly name
            pListEntry->data.length = (sizeof(pListEntry->data.content) < pEntry->device_name_len) ?
                                       sizeof(pListEntry->data.content) : pEntry->device_name_len;
            (void)memcpy(pListEntry->data.content,
                         pEntry->device_name,
                         pListEntry->data.length);

            // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
            // shall be set to cell type: menue item
            pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
        }
        else
        {
            /* set only static text */
            AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
            AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
            APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;
            Uint16Type index = listIndex - gAppSdContext.pCurCtxCtrl->s541.numDevs;

            if(pListEntry == NULL)
            {
                break;
            }
            switch(index)
            {
                case 1:
                    txtId = APP_SD_en_S541_ta_list_back_Auswahl_1;
                    break;
                default:
                    txtId = APP_SD_enError;
                    break;
            }

            _APP_SD_vSetStaticText(txtId, &pListEntry->data);
            // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
            // shall be set to cell type: menue item
            pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
        }
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_S542(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;

//    const char *activeArr[] = { "DUMMY",
//                                "Verbinden",
//                                "Trennen",
//                                "Umbenennen",
//                                "Loeschen",
//                                "Zurueck"};
//
//    const char *inactiveArr[] = {"DUMMY",
//                                 "Verbinden",
//                                 "Umbenennen",
//                                 "Loeschen",
//                                 "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S542_ta_connect_Auswahl_1;
                break;
            case 2:
                if( gAppSdContext.pCurCtxCtrl->s542.bIsActive )
                {
                    txtId = APP_SD_en_S542_ta_bt_disconnect_Auswahl_1;
                }
                else
                {
                    txtId = APP_SD_en_S542_ta_bt_rename_Auswahl_1;
                }
                break;
            case 3:
                if( gAppSdContext.pCurCtxCtrl->s542.bIsActive )
                {
                    txtId = APP_SD_en_S542_ta_bt_rename_Auswahl_1;
                }
                else
                {
                    txtId = APP_SD_en_S542_ta_menu_delete_Auswahl_1;
                }
                break;
            case 4:
                if( gAppSdContext.pCurCtxCtrl->s542.bIsActive )
                {
                    txtId = APP_SD_en_S542_ta_menu_delete_Auswahl_1;
                }
                else
                {
                    txtId = APP_SD_en_S542_ta_list_back_Auswahl_1;
                }
                break;
            case 5:
                if( gAppSdContext.pCurCtxCtrl->s542.bIsActive )
                {
                    txtId = APP_SD_en_S542_ta_list_back_Auswahl_1;
                }
                else
                {
                    txtId = APP_SD_enError;
                }
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}


void _APP_SD_vListDataRequest_S553(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Ok",
//                       "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S553_ta_menu_ok_Auswahl_1;
                break;
            case 2:
                txtId = APP_SD_en_S553_ta_list_back_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_S555(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Ok",
//                       "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S555_ta_menu_ok_Auswahl_1;
                break;
            case 2:
                txtId = APP_SD_en_S555_ta_list_back_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_S562(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Aktives Geraet",
//                       "Gekopp. Geraete",
//                       "Suche",
//                       "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S562_ta_bt_active_device_Auswahl_1;
                break;
            case 2:
                txtId = APP_SD_en_S562_ta_bt_paired_devices_Auswahl_1;
                break;
            case 3:
                txtId = APP_SD_en_S562_ta_search_Auswahl_1;
                break;
            case 4:
                txtId = APP_SD_en_S562_ta_list_back_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_S563(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;

//    const char *tmpArr[] = { "DUMMY",
//                             "Trennen",
//                             "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S563_ta_bt_disconnect_Auswahl_1;
                break;
            case 2:
                txtId = APP_SD_en_S563_ta_list_back_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}


void _APP_SD_vListDataRequest_S567(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
//    char *tmpArr[] = { "Zurueck"};

    Uint16Type listIndex = 0;
    while( (listIndex = APP_SD_LC_u16GetNextListIndex(pListCtrl)) > 0)
    {
        if( listIndex < (gAppSdContext.pCurCtxCtrl->s567.numDevs + 1) )
        {
             const ERMBTDeviceTableType *pEntry = NULL;
            AppSdListBufType        *pListEntry = NULL;

            AT_DeviceId deviceId = ERM_GetDeviceIdOfUmpteenthHeadset(listIndex);
            if(deviceId == AT_INVALID_DEVICE_ID)
            {   // no more device
                break;
            }

            /* get paired device name */
            pEntry = ERM_GetBTDevice(deviceId);

            // now we know that there is another valid element, so request
            // listBuffer
            pListEntry = APP_SD_stGetListBuffer(pListCtrl);

            if(pListEntry == NULL)
            {
                break;
            }

            // copy bt user friendly name
            pListEntry->data.length = (sizeof(pListEntry->data.content) < pEntry->device_name_len) ?
                                       sizeof(pListEntry->data.content) : pEntry->device_name_len;
            (void)memcpy(pListEntry->data.content,
                         pEntry->device_name,
                         pListEntry->data.length);

            // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
            // shall be set to cell type: menue item
            pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
        }
        else
        {
            /* set only static text */
            AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
            AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
            APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;
            Uint16Type index = listIndex - gAppSdContext.pCurCtxCtrl->s567.numDevs;

            if(pListEntry == NULL)
            {
                break;
            }
            switch(index)
            {
                case 1:
                    txtId = APP_SD_en_S567_ta_list_back_Auswahl_1;
                    break;
                default:
                    txtId = APP_SD_enError;
                    break;
            }

            _APP_SD_vSetStaticText(txtId, &pListEntry->data);
            // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
            // shall be set to cell type: menue item
            pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
        }
    }


    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}


void _APP_SD_vListDataRequest_S5B2(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
//    char *tmpArr[] = { "Zurueck"};

    Uint16Type listIndex = 0;
    while( (listIndex = APP_SD_LC_u16GetNextListIndex(pListCtrl)) > 0)
    {
        if( listIndex < (gAppSdContext.pCurCtxCtrl->s5B2.numDevs + 1) )
        {
            const ERMBTDeviceTableType      *pEntry = NULL;
            const ERMPhysicalBTDeviceType   *pPhyEntry = NULL;
            AppSdListBufType                *pListEntry = NULL;

            AT_DeviceId deviceId = ERM_GetDeviceIdOfUmpteenthPlayer(listIndex);
            if(deviceId == AT_INVALID_DEVICE_ID)
            {   // no more device
                break;
            }



            // now we know that there is another valid element, so request
            // listBuffer
            pListEntry = APP_SD_stGetListBuffer(pListCtrl);

            if(pListEntry == NULL)
            {
                break;
            }

            /* get paired device name */
            if( (pEntry = ERM_GetBTDevice(deviceId)) != NULL )
            {
                // copy bt user friendly name
                pListEntry->data.length = (sizeof(pListEntry->data.content) < pEntry->device_name_len) ?
                                           sizeof(pListEntry->data.content) : pEntry->device_name_len;
                (void)memcpy(pListEntry->data.content,
                             pEntry->device_name,
                             pListEntry->data.length);
            }
            else if( (pPhyEntry = ERM_pGetPhyDevice(deviceId)) != NULL )
            {

                DEBUG_VALUE1( APP_SD_SWI_WNG, MOD_APP_SD, "ListDataReq_S5B2: no BTDevEntry entry, PhyDevEntry fallback %d",
                              deviceId);

                pListEntry->data.length = (sizeof(pListEntry->data.content) < pPhyEntry->name_len) ?
                                           sizeof(pListEntry->data.content) : pPhyEntry->name_len;
                (void)memcpy(pListEntry->data.content,
                             pPhyEntry->name,
                             pListEntry->data.length);

                // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
                // shall be set to cell type: menue item
                pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
            }
        }
        else
        {
            /* set only static text */
            AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
            AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
            APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;
            Uint16Type index = listIndex - gAppSdContext.pCurCtxCtrl->s5B2.numDevs;

            if(pListEntry == NULL)
            {
                break;
            }
            switch(index)
            {
                case 1:
                    txtId = APP_SD_en_S5B2_ta_list_back_Auswahl_1;
                    break;
                default:
                    txtId = APP_SD_enError;
                    break;
            }

            _APP_SD_vSetStaticText(txtId, &pListEntry->data);
            // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
            // shall be set to cell type: menue item
            pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
        }
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;
    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}



void _APP_SD_vListDataRequest_S571(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;

//    const char *tmpArr[] = { "DUMMY",
//                             "Verbinden",
//                             "Umbenennen",
//                             "Loeschen",
//                             "Autorisierung",
//                             "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S571_ta_connect_Auswahl_1;
                break;
            case 2:
                txtId = APP_SD_en_S571_ta_bt_rename_Auswahl_1;
                break;
            case 3:
                txtId = APP_SD_en_S571_ta_menu_delete_Auswahl_1;
                break;
            //case 4:   // feature cancelled
            //    txtId = APP_SD_en_S571_ta_bt_authorisation_Auswahl_1;
            //    break;
            case 4:
                txtId = APP_SD_en_S571_ta_list_back_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_S572(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;

//    const char *tmpArr[] = { "DUMMY",
//                             "Ok",
//                             "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S572_ta_menu_ok_Auswahl_1;
                break;
            case 2:
                txtId = APP_SD_en_S572_ta_list_back_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_S576(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Ok",
//                       "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S576_ta_menu_ok_Auswahl_1;
                break;
            case 2:
                txtId = APP_SD_en_S576_ta_list_back_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

//void _APP_SD_vListDataRequest_S577(Uint16Type firstIdx, Uint16Type number)
//{
//    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
//    Uint16Type i = 0;
////    char *tmpArr[] = { "DUMMY",
////                       "Ein",           // Radio button
////                       "Aus",           // Radio Button
////                       "Zurueck"};      // menue item
//
//
//    for( i=firstIdx; i<number+firstIdx; i++)
//    {
//        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
//        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;
//
//        if(pListEntry == NULL)
//        {
//            break;
//        }
//        switch(i)
//        {
//            case 1:
//                txtId = APP_SD_en_S577_ta_menu_yes_Auswahl_1;
//                pListEntry->cell.type = KPB_CELL_TYPE_RADIO_BUTTON;
//                if(gAppSdContext.pCurCtxCtrl->s577.bAuthNeeded == BT_TRUE)
//                {
//                    pListEntry->cell.activated = BT_TRUE;
//                }
//                break;
//            case 2:
//                txtId = APP_SD_en_S577_ta_menu_no_Auswahl_1;
//                pListEntry->cell.type = KPB_CELL_TYPE_RADIO_BUTTON;
//                if(gAppSdContext.pCurCtxCtrl->s577.bAuthNeeded == BT_FALSE)
//                {
//                    pListEntry->cell.activated = BT_TRUE;
//                }
//                break;
//            case 3:
//                txtId = APP_SD_en_S577_ta_list_back_Auswahl_1;
//                break;
//            default:
//                txtId = APP_SD_enError;
//                break;
//        }
//
//        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
//    }
//
//    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;
//
//    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
//                                        MSEC(0),
//                                        0);
//}
//




void _APP_SD_vListDataRequest_S579(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Ok",
//                       "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S579_ta_menu_ok_Auswahl_1;
                break;
            case 2:
                txtId = APP_SD_en_S579_ta_list_back_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}




void _APP_SD_vListDataRequest_S581(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Abbruch"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S581_ta_menu_cancel_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}



/*********************************/
// Settings
/*********************************/
void _APP_SD_vListDataRequest_S601(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    const char *pVersionLabel = "Version";
//    char *tmpArr[] = { "DUMMY",
//                       "Telefonbuch",
//                       "Signaleinstell.",
//                       "Audio Mode",

//                       "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S601_ta_phone_book_Auswahl_1;
                break;
            case 2:
#ifdef UHV_ACTIVATE_FEATURE_S641
                txtId = APP_SD_en_S601_ta_setting_signals_Auswahl_1;
#else
                txtId = APP_SD_en_S641_ta_setting_tone_Auswahl_1;
#endif
                break;
#ifndef UHV_ACTIVATE_FEATURE_SET_AUDIO_MODE
            case 3:
                if(gAppSdContext.pCurCtxCtrl->s601.bVersion)
                {
                    //TODO: we need a text id for version
//                    txtId = APP_SD_enMAX_CONTEXT_ID;
                    txtId = APP_SD_en_S601_ta_sw_info_Auswahl_1;
                }
                else
                {
                    txtId = APP_SD_en_S601_ta_list_back_Auswahl_1;
                }
                break;
            case 4:
                if(gAppSdContext.pCurCtxCtrl->s601.bVersion)
                {
                    txtId = APP_SD_en_S601_ta_list_back_Auswahl_1;
                }
                else
                {
                    txtId = APP_SD_enError;
                }
                break;
#else
            case 3:
                txtId = APP_SD_en_S601_ta_audio_mode_Auswahl_1;
                break;
            case 4:
                if(gAppSdContext.pCurCtxCtrl->s601.bVersion)
                {
                    //TODO: we need a text id for version
                    txtId = APP_SD_en_S601_ta_sw_info_Auswahl_1;
                }
                else
                {
                    txtId = APP_SD_en_S601_ta_list_back_Auswahl_1;
                }
                break;
            case 5:
                if(gAppSdContext.pCurCtxCtrl->s601.bVersion)
                {
                    txtId = APP_SD_en_S601_ta_list_back_Auswahl_1;
                }
                else
                {
                    txtId = APP_SD_enError;
                }
                break;
#endif
            default:
                txtId = APP_SD_enError;
                break;
        }

//        if(txtId != APP_SD_enMAX_CONTEXT_ID)
//        {
            _APP_SD_vSetStaticText(txtId, &pListEntry->data);
            // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
            // shall be set to cell type: menue item
//        }
//        else
//        {
//            // workaround as long as we have no textId for Version
//            pListEntry->data.length = strlen(pVersionLabel);
//
//            (void)memcpy(pListEntry->data.content, pVersionLabel, pListEntry->data.length);
//        }

        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_S602(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Nur Telefonate",    // Radio button
//                       "Immer",             // Radio Button
//                       "Zurueck"};          // menue item

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S602_ta_calls_only_Auswahl_1;
                pListEntry->cell.type = KPB_CELL_TYPE_RADIO_BUTTON;
                if(gAppSdContext.pCurCtxCtrl->s602.audioMode == ERM_AUDIO_MODE_CALLS_ONLY)
                {
                    pListEntry->cell.activated = BT_TRUE;
                }
                break;
            case 2:
                txtId = APP_SD_en_S602_ta_always_Auswahl_1;
                pListEntry->cell.type = KPB_CELL_TYPE_RADIO_BUTTON;
                if(gAppSdContext.pCurCtxCtrl->s602.audioMode == ERM_AUDIO_MODE_ALL_AUDIO)
                {
                    pListEntry->cell.activated = BT_TRUE;
                }
                break;
            case 3:
                txtId = APP_SD_en_S602_ta_list_back_Auswahl_1;
                // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
                // shall be set to cell type: menue item
                pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}





void _APP_SD_vListDataRequest_S641(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Rufton",
//                       "Anrufername",
//                       "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        if(ERM_SIVR_FULL_SUPPORTED == ERM_enIsVcrSupported())              /* RT 2429 */
        {
            switch(i)
            {
                case 1:
                    txtId = APP_SD_en_S641_ta_setting_tone_Auswahl_1;
                    break;
                case 2:
#ifdef UHV_ACTIVATE_FEATURE_PLAY_CALLER_NAME
                    txtId = APP_SD_en_S641_ta_pb_nametag_Auswahl_1;
                    break;
                case 3:
#endif
                    txtId = APP_SD_en_S641_ta_list_back_Auswahl_1;
                    break;
                default:
                    txtId = APP_SD_enError;
                    break;
            }
        }
        else
        {
            switch(i)
            {
                case 1:
                    txtId = APP_SD_en_S641_ta_setting_tone_Auswahl_1;
                    break;
                case 2:
                    txtId = APP_SD_en_S641_ta_list_back_Auswahl_1;
                    break;
                default:
                    txtId = APP_SD_enError;
                    break;
            }
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_S642(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;



    char *tmpArr[] = { "DUMMY",
                       //"CUSTOM8",
                       //"CUSTOM9",
                       "VIBORBELLZ",          // 1161
                       "BIMBAM",              // 1159
                       "EASYLISTEN",          // 1152
                       "FUTUREBEAT",          // 1154
                       "ENDLESS",             // 1153
                       "RINGRING",            // 1151
                       "NOSTALGIC",           // 1155
                       "ORCHESTRA1",          // 1156
                       "ORCHESTRA2",          // 1157
                       "SWEETSOFT",           // 1158
                       "TUTTUT",              // 1160
                       //"VW_13",
                       //"VW_14",
                       //"VW_15",
                       "Zurueck"};   // menue item

    Uint8Type activatedIndex = (Uint8Type)(ERM_GetIndexForRingtone(gAppSdContext.pCurCtxCtrl->s642.ringtone));

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1 :
            case 2 :
            case 3 :
            case 4 :
            case 5 :
            case 6 :
            case 7 :
            case 8 :
            case 9 :
            case 10:
            case 11:
            //case 12:
            //case 13: case 14: case 15:
            //case 16:
            //case 17:
                pListEntry->cell.type = KPB_CELL_TYPE_RADIO_BUTTON;
                if( i == activatedIndex )
                {
                    pListEntry->cell.activated = BT_TRUE;
                }
                pListEntry->data.length = (KPB_MAX_CELL_CONTENT_SIZE < strlen(tmpArr[i])) ?
                                           KPB_MAX_CELL_CONTENT_SIZE : strlen(tmpArr[i]);
                (void)memcpy(pListEntry->data.content, tmpArr[i], pListEntry->data.length);
                break;
            case 12:
                _APP_SD_vSetStaticText(APP_SD_en_S642_ta_list_back_Auswahl_1, &pListEntry->data);
                // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
                // shall be set to cell type: menue item
                pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
                break;
            default:
                _APP_SD_vSetStaticText(APP_SD_enError, &pListEntry->data);
                // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
                // shall be set to cell type: menue item
                pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
                break;
        }

    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}





/*********************************/
// Telefonbuch Settings
/*********************************/
void _APP_SD_vListDataRequest_S661(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Aktualisieren",
//                       "Sortierung",
//                       "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S661_ta_pb_download_Auswahl_1;
                break;
            case 2:
                txtId = APP_SD_en_S661_ta_sorting_order_Auswahl_1;
                break;
            case 3:
                txtId = APP_SD_en_S661_ta_list_back_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_S669(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Nachname",  // Radio button
//                       "Vorname",   // Radio Button
//                       "Zurueck"};   // menue item


    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S669_ta_pb_sort_lastname_Auswahl_1;
                pListEntry->cell.type = KPB_CELL_TYPE_RADIO_BUTTON;
                if(gAppSdContext.pCurCtxCtrl->s669.sortOrder == AT_PB_SORTORDER_LASTFIRST)
                {
                    pListEntry->cell.activated = BT_TRUE;
                }
                break;
            case 2:
                txtId = APP_SD_en_S669_ta_pb_sort_firstname_Auswahl_1;
                pListEntry->cell.type = KPB_CELL_TYPE_RADIO_BUTTON;
                if(gAppSdContext.pCurCtxCtrl->s669.sortOrder == AT_PB_SORTORDER_FIRSTLAST)
                {
                    pListEntry->cell.activated = BT_TRUE;
                }
                break;
            case 3:
                txtId = APP_SD_en_S669_ta_list_back_Auswahl_1;
                // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
                // shall be set to cell type: menue item
                pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
                break;
            default:
                txtId = APP_SD_enError;
                // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
                // shall be set to cell type: menue item
                pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}



/*********************************/
// Call Handling
/*********************************/

void _APP_SD_vListDataRequest_S801(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Auflegen",
//                       "Headset",
//                       "Privatgespraech"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        if( NULL != ERM_pGetActiveHeadsetProfile())
        {
            switch(i)
            {
                case 1:
                    txtId = APP_SD_en_S801_ta_call_end_Auswahl_1;
                    break;
                case 2:
                    if( BT_FALSE == APP_PHONE_bIsHeadsetOn())
                    {
                        txtId = APP_SD_en_S801_ta_bt_headset_Auswahl_1;
                    }
                    else
                    {
                        txtId = APP_SD_en_S801_ta_call_handsfree_Auswahl_1;
                    }
                    break;
                case 3:
                    txtId = APP_SD_en_S801_ta_private_call_Auswahl_1;
                    break;
                default:
                    txtId = APP_SD_enError;
                    break;
            }
        }
        else
        {
            switch(i)
            {
                case 1:
                    txtId = APP_SD_en_S801_ta_call_end_Auswahl_1;
                    break;
                case 2:
                    txtId = APP_SD_en_S801_ta_private_call_Auswahl_1;
                    break;
                default:
                    txtId = APP_SD_enError;
                    break;
            }
        }
        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_S802(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);

    AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
    APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

    if(pListEntry == NULL)
    {
        return;
    }
    txtId = APP_SD_en_S802_ta_call_end_Auswahl_1;

    _APP_SD_vSetStaticText(txtId, &pListEntry->data);
    // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
    // shall be set to cell type: menue item
    pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}



void _APP_SD_vListDataRequest_S803(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Auflegen",
//                       "Halten",
//                       "Headset",
//                       "Privatgespraech",
//                       "Mikrofon aus",
//                       "DTMF"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }

        if( BT_TRUE == gAppSdContext.pCurCtxCtrl->s803.bholdSupported )
        {
          if( NULL != ERM_pGetActiveHeadsetProfile())
          {
            switch(i)
            {
                case 1:
                    txtId = APP_SD_en_S803_ta_call_end_Auswahl_1;
                    break;
                case 2:
                    txtId = APP_SD_en_S803_ta_call_hold_Auswahl_1;
                    break;
                case 3:
                    if(APP_PHONE_bIsHeadsetOn() == BT_FALSE)			// RT 2276
                    {
                        txtId = APP_SD_en_S803_ta_bt_headset_Auswahl_1;
                    }
                    else
                    {
                        txtId = APP_SD_en_S803_ta_call_handsfree_Auswahl_1;
                    }
                    break;
                case 4:
                    txtId = APP_SD_en_S803_ta_private_call_Auswahl_1;
                    break;
                case 5:
                    if(APP_PHONE_bIsMicMuted() == BT_TRUE)
                    {
                        txtId = APP_SD_en_S803_ta_call_micro_on_Auswahl_1;
                    }
                    else
                    {
                        txtId = APP_SD_en_S803_ta_call_micro_off_Auswahl_1;
                    }
                    break;
                case 6:
                    txtId = APP_SD_en_S803_ta_call_dtmf_Auswahl_1;
                    break;
                default:
                    txtId = APP_SD_enError;
                    break;
            }
          }
          else
          {
            switch(i)
            {
                case 1:
                    txtId = APP_SD_en_S803_ta_call_end_Auswahl_1;
                    break;
                case 2:
                    txtId = APP_SD_en_S803_ta_call_hold_Auswahl_1;
                    break;
                case 3:
                    txtId = APP_SD_en_S803_ta_private_call_Auswahl_1;
                    break;
                case 4:
                    if(APP_PHONE_bIsMicMuted() == BT_TRUE)
                    {
                        txtId = APP_SD_en_S803_ta_call_micro_on_Auswahl_1;
                    }
                    else
                    {
                        txtId = APP_SD_en_S803_ta_call_micro_off_Auswahl_1;
                    }
                    break;
                case 5:
                    txtId = APP_SD_en_S803_ta_call_dtmf_Auswahl_1;
                    break;
                default:
                    txtId = APP_SD_enError;
                    break;
            }
          }
        }
        else
        {   /* no call hold supported */
          if( NULL != ERM_pGetActiveHeadsetProfile())
          {
            switch(i)
            {
                case 1:
                    txtId = APP_SD_en_S803_ta_call_end_Auswahl_1;
                    break;
                case 2:
                    if(APP_PHONE_bIsHeadsetOn() == BT_FALSE)				// RT 2276
                    {
                        txtId = APP_SD_en_S803_ta_bt_headset_Auswahl_1;
                    }
                    else
                    {
                        txtId = APP_SD_en_S803_ta_call_handsfree_Auswahl_1;
                    }
                    break;
                case 3:
                    txtId = APP_SD_en_S803_ta_private_call_Auswahl_1;
                    break;
                case 4:
                    if(APP_PHONE_bIsMicMuted() == BT_TRUE)
                    {
                        txtId = APP_SD_en_S803_ta_call_micro_on_Auswahl_1;
                    }
                    else
                    {
                        txtId = APP_SD_en_S803_ta_call_micro_off_Auswahl_1;
                    }
                    break;
                case 5:
                    txtId = APP_SD_en_S803_ta_call_dtmf_Auswahl_1;
                    break;
                default:
                    txtId = APP_SD_enError;
                    break;
            }
          }
          else
          {
            switch(i)
            {
                case 1:
                    txtId = APP_SD_en_S803_ta_call_end_Auswahl_1;
                    break;
                case 2:
                    txtId = APP_SD_en_S803_ta_private_call_Auswahl_1;
                    break;
                case 3:
                    if(APP_PHONE_bIsMicMuted() == BT_TRUE)
                    {
                        txtId = APP_SD_en_S803_ta_call_micro_on_Auswahl_1;
                    }
                    else
                    {
                        txtId = APP_SD_en_S803_ta_call_micro_off_Auswahl_1;
                    }
                    break;
                case 4:
                    txtId = APP_SD_en_S803_ta_call_dtmf_Auswahl_1;
                    break;
                default:
                    txtId = APP_SD_enError;
                    break;
            }
          }
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_S811(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Aktivieren",
//                       "Telefonbuch",
//                       "Anruflisten",
//                       "Nummernwahl",
//                       "Anruf beenden"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        if (AT_CALL_INDEX_CONFERENCE == gAppSdContext.pCurCtxCtrl->s811.plccIndex)
        {
            switch(i)
            {
                case 1:
                    txtId = APP_SD_en_S811_ta_call_resume_Auswahl_1;
                    break;
                case 2:
                    txtId = APP_SD_en_S811_ta_end_call_Auswahl_1;
                    break;
                default:
                    txtId = APP_SD_enError;
                    break;
            }

        }
        else
        {
            switch(i)
            {
                case 1:
                    txtId = APP_SD_en_S811_ta_call_resume_Auswahl_1;
                    break;
                case 2:
                    txtId = APP_SD_en_S811_ta_phone_book_Auswahl_1;
                    break;
                case 3:
                    txtId = APP_SD_en_S811_ta_main_callstacks_Auswahl_1;
                    break;
                case 4:
                    txtId = APP_SD_en_S811_ta_main_dial_Auswahl_1;
                    break;
                case 5:
                    txtId = APP_SD_en_S811_ta_end_call_Auswahl_1;
                    break;
                default:
                    txtId = APP_SD_enError;
                    break;
            }
        }
        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_S812(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Auflegen",
//                       "Anruf ???",
//                       "Konferenz",
//                       "Durchstellen",
//                       "Headset",
//                       "Mikrofon ???",
//                       "DTMF",
//                       "Alle beenden"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        if( (APP_PHONE_enGetHfpVersion() == AT_CODPROF_HANDSFREE_1_00) ||
            (APP_PHONE_enGetHfpVersion() == AT_CODPROF_HANDSFREE_0_96)  ||
            (BT_TRUE == ERM_bIsCDMAPhone()) )
        {
        if( NULL != ERM_pGetActiveHeadsetProfile())
        {
          switch(i)
          {
              case 1:
                  txtId = APP_SD_en_S812_ta_call_end_Auswahl_1;
                  break;
              case 2:
                        if(APP_PHONE_bIsHeadsetOn() == BT_FALSE)				// RT 2276
                        {
                            txtId = APP_SD_en_S812_ta_bt_headset_Auswahl_1;
                        }
                        else
                        {
                            txtId = APP_SD_en_S812_ta_call_handsfree_Auswahl_1;
                        }
                        break;
                    case 3:
                        if(APP_PHONE_bIsMicMuted() == BT_TRUE)
                        {
                            txtId = APP_SD_en_S812_ta_call_micro_on_Auswahl_1;
                        }
                        else
                        {
                            txtId = APP_SD_en_S812_ta_call_micro_off_Auswahl_1;
                        }
                        break;
                    case 4:
                        txtId = APP_SD_en_S812_ta_call_dtmf_Auswahl_1;
                        break;
                    case 5:
                        txtId = APP_SD_en_S812_ta_call_end_all_Auswahl_1;
                        break;
                    default:
                        txtId = APP_SD_enError;
                        break;
                }
            }
            else
            {
                switch(i)
                {
                    case 1:
                        txtId = APP_SD_en_S812_ta_call_end_Auswahl_1;
                        break;
                    case 2:
                        if(APP_PHONE_bIsMicMuted() == BT_TRUE)
                        {
                            txtId = APP_SD_en_S812_ta_call_micro_on_Auswahl_1;
                        }
                        else
                        {
                            txtId = APP_SD_en_S812_ta_call_micro_off_Auswahl_1;
                        }
                        break;
                    case 3:
                        txtId = APP_SD_en_S812_ta_call_dtmf_Auswahl_1;
                        break;
                    case 4:
                        txtId = APP_SD_en_S812_ta_call_end_all_Auswahl_1;
                        break;
                    default:
                        txtId = APP_SD_enError;
                        break;
               }
            }
        }
        else
        {
            if( NULL != ERM_pGetActiveHeadsetProfile())
            {
              switch(i)
              {
                  case 1:
                      txtId = APP_SD_en_S812_ta_call_end_Auswahl_1;
                      break;
                  case 2:
                  if(gAppSdContext.pCurCtxCtrl->s812.activePlccIdx == AT_CALL_INDEX_0)
                  {
                      txtId = APP_SD_en_S813_ta_call_call2_Auswahl_1;
                  }
                  else
                  {
                      txtId = APP_SD_en_S812_ta_call_call1_Auswahl_1;
                  }
                  break;
              case 3:
                  txtId = APP_SD_en_S812_ta_conference_Auswahl_1;
                  break;
              case 4:
                    if(APP_PHONE_bIsHeadsetOn() == BT_FALSE)				// RT 2276
                    {
                        txtId = APP_SD_en_S812_ta_bt_headset_Auswahl_1;
                    }
                    else
                    {
                        txtId = APP_SD_en_S812_ta_call_handsfree_Auswahl_1;
                    }
                  break;
              case 5:
                  if(APP_PHONE_bIsMicMuted() == BT_TRUE)
                  {
                      txtId = APP_SD_en_S812_ta_call_micro_on_Auswahl_1;
                  }
                  else
                  {
                      txtId = APP_SD_en_S812_ta_call_micro_off_Auswahl_1;
                  }
                  break;
              case 6:
                  txtId = APP_SD_en_S812_ta_call_dtmf_Auswahl_1;
                  break;
              case 7:
                  txtId = APP_SD_en_S812_ta_call_end_all_Auswahl_1;
                  break;
              default:
                  txtId = APP_SD_enError;
                  break;
          }
        }
        else
        {
          switch(i)
          {
              case 1:
                  txtId = APP_SD_en_S812_ta_call_end_Auswahl_1;
                  break;
              case 2:
                  if(gAppSdContext.pCurCtxCtrl->s812.activePlccIdx == AT_CALL_INDEX_0)
                  {
                      txtId = APP_SD_en_S813_ta_call_call2_Auswahl_1;
                  }
                  else
                  {
                      txtId = APP_SD_en_S812_ta_call_call1_Auswahl_1;
                  }
                  break;
              case 3:
                  txtId = APP_SD_en_S812_ta_conference_Auswahl_1;
                  break;
              case 4:
                  if(APP_PHONE_bIsMicMuted() == BT_TRUE)
                  {
                      txtId = APP_SD_en_S812_ta_call_micro_on_Auswahl_1;
                  }
                  else
                  {
                      txtId = APP_SD_en_S812_ta_call_micro_off_Auswahl_1;
                  }
                  break;
              case 5:
                  txtId = APP_SD_en_S812_ta_call_dtmf_Auswahl_1;
                  break;
              case 6:
                  txtId = APP_SD_en_S812_ta_call_end_all_Auswahl_1;
                  break;
              default:
                  txtId = APP_SD_enError;
                  break;
          }
        }
        }
        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_S815(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Auflegen",
//                       "Halten",
//                       "Durchstellen",
//                       "Headset",
//                       "Mikrofon ???" };

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }

        if( (APP_PHONE_enGetHfpVersion() == AT_CODPROF_HANDSFREE_1_00) ||
            (APP_PHONE_enGetHfpVersion() == AT_CODPROF_HANDSFREE_0_96)  ||
            (BT_TRUE == ERM_bIsCDMAPhone()) )
        {
        if( NULL != ERM_pGetActiveHeadsetProfile())
        {
          switch(i)
          {
              case 1:
                  txtId = APP_SD_en_S815_ta_call_end_Auswahl_1;
                  break;
              case 2:
                        if(APP_PHONE_bIsHeadsetOn() == BT_FALSE)					// RT 2276
                        {
                            txtId = APP_SD_en_S815_ta_bt_headset_Auswahl_1;
                        }
                        else
                        {
                            txtId = APP_SD_en_S815_ta_call_handsfree_Auswahl_1;
                        }
                        break;
                    case 3:
                        if(APP_PHONE_bIsMicMuted() == BT_TRUE)
                        {
                            txtId = APP_SD_en_S815_ta_call_micro_on_Auswahl_1;
                        }
                        else
                        {
                            txtId = APP_SD_en_S815_ta_call_micro_off_Auswahl_1;
                        }
                        break;
                    default:
                        txtId = APP_SD_enError;
                        break;
                }
            }
            else
            {
                switch(i)
                {
                    case 1:
                        txtId = APP_SD_en_S815_ta_call_end_Auswahl_1;
                        break;
                    case 2:
                        if(APP_PHONE_bIsMicMuted() == BT_TRUE)
                        {
                            txtId = APP_SD_en_S815_ta_call_micro_on_Auswahl_1;
                        }
                        else
                        {
                            txtId = APP_SD_en_S815_ta_call_micro_off_Auswahl_1;
                        }
                        break;
                    default:
                        txtId = APP_SD_enError;
                        break;
                }
            }
        }
        else
        {
            if( NULL != ERM_pGetActiveHeadsetProfile())
            {
              switch(i)
              {
                  case 1:
                      txtId = APP_SD_en_S815_ta_call_end_Auswahl_1;
                      break;
                  case 2:
                  txtId = APP_SD_en_S815_ta_call_hold_Auswahl_1;
                  break;
              case 3:
                  if(APP_PHONE_bIsHeadsetOn() == BT_FALSE)					// RT 2276
                  {
                      txtId = APP_SD_en_S815_ta_bt_headset_Auswahl_1;
                  }
                  else
                  {
                      txtId = APP_SD_en_S815_ta_call_handsfree_Auswahl_1;
                  }
                  break;
              case 4:
                  if(APP_PHONE_bIsMicMuted() == BT_TRUE)
                  {
                      txtId = APP_SD_en_S815_ta_call_micro_on_Auswahl_1;
                  }
                  else
                  {
                      txtId = APP_SD_en_S815_ta_call_micro_off_Auswahl_1;
                  }
                  break;
              default:
                  txtId = APP_SD_enError;
                  break;
          }
        }
        else
        {
          switch(i)
          {
              case 1:
                  txtId = APP_SD_en_S815_ta_call_end_Auswahl_1;
                  break;
              case 2:
                  txtId = APP_SD_en_S815_ta_call_hold_Auswahl_1;
                  break;
              case 3:
                  if(APP_PHONE_bIsMicMuted() == BT_TRUE)
                  {
                      txtId = APP_SD_en_S815_ta_call_micro_on_Auswahl_1;
                  }
                  else
                  {
                      txtId = APP_SD_en_S815_ta_call_micro_off_Auswahl_1;
                  }
                  break;
              default:
                  txtId = APP_SD_enError;
                  break;
          }
        }
        }
        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;

    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}


void _APP_SD_vListDataRequest_S901(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Annehmen",
//                       "Abweisen",
//                       "Lautlos",
//                       "Headset"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }

        if(gAppSdContext.pCurCtxCtrl->s901.muteActivated == BT_FALSE)
        {
            if( NULL != ERM_pGetActiveHeadsetProfile())
            {
              switch(i)
              {
                  case 1:
                      txtId = APP_SD_en_S901_ta_call_accept_Auswahl_1;
                      break;
                  case 2:
                      txtId = APP_SD_en_S901_ta_call_reject_Auswahl_1;
                      break;
                  case 3:
                      txtId = APP_SD_en_S901_ta_call_silent_Auswahl_1;
                      break;
                  case 4:
                      txtId = APP_SD_en_S901_ta_bt_headset_Auswahl_1;
                      break;
                  default:
                      txtId = APP_SD_enError;
                      break;
              }
            }
            else
            {
              switch(i)
              {
                  case 1:
                      txtId = APP_SD_en_S901_ta_call_accept_Auswahl_1;
                      break;
                  case 2:
                      txtId = APP_SD_en_S901_ta_call_reject_Auswahl_1;
                      break;
                  case 3:
                      txtId = APP_SD_en_S901_ta_call_silent_Auswahl_1;
                      break;
                  default:
                      txtId = APP_SD_enError;
                      break;
              }
            }
        }
        else
        {
            if( NULL != ERM_pGetActiveHeadsetProfile())
            {
              switch(i)
              {
                  case 1:
                      txtId = APP_SD_en_S901_ta_call_accept_Auswahl_1;
                      break;
                  case 2:
                      txtId = APP_SD_en_S901_ta_call_reject_Auswahl_1;
                      break;
                  case 3:
                      txtId = APP_SD_en_S901_ta_bt_headset_Auswahl_1;
                      break;
                  default:
                      txtId = APP_SD_enError;
                      break;
              }
            }
            else
            {
              switch(i)
              {
                  case 1:
                      txtId = APP_SD_en_S901_ta_call_accept_Auswahl_1;
                      break;
                  case 2:
                      txtId = APP_SD_en_S901_ta_call_reject_Auswahl_1;
                      break;
                  default:
                      txtId = APP_SD_enError;
                      break;
              }
            }
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_S902(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;

//    char *tmpArr[] = { "DUMMY",
//                       "Makeln",
//                       "Abweisen",
//                       "Ersetzen");

//RT: #3133              "Gespr. beenden"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        if( (APP_PHONE_enGetHfpVersion() == AT_CODPROF_HANDSFREE_1_00) ||
            (APP_PHONE_enGetHfpVersion() == AT_CODPROF_HANDSFREE_0_96)  ||
            (BT_TRUE == ERM_bIsCDMAPhone()) )
        {
        switch(i)
        {
            case 1:
                    txtId = APP_SD_en_S902_ta_call_reject_Auswahl_1;
                    break;
            case 2:
                    txtId = APP_SD_en_S902_ta_replace_Auswahl_1;
                    break;
                default:
                    txtId = APP_SD_enError;
                    break;
            }
        }
        else
        {
            switch(i)
            {
                case 1:
                txtId = APP_SD_en_S902_ta_call_swap_Auswahl_1;
                break;
            case 2:
                txtId = APP_SD_en_S902_ta_call_reject_Auswahl_1;
                break;
            case 3:
                txtId = APP_SD_en_S902_ta_replace_Auswahl_1;
                break;
//RT: #3133
//            case 4:
//                txtId = APP_SD_en_S902_ta_call_end_active_Auswahl_1;
//                break;
            default:
                txtId = APP_SD_enError;
                break;
        }
        }
        _APP_SD_vSetStaticText(txtId, &pListEntry->data);

        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }
    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_S903(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Zeigen",
//                       "Vorlesen",
//                       "Beenden"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        if(ERM_SIVR_FULL_SUPPORTED == ERM_enIsVcrSupported())                /* RT 2429 */
        {
            switch(i)
            {
                case 1:
                    txtId = APP_SD_en_S903_ta_menu_view_Auswahl_1;
                    break;
                case 2:
                    txtId = APP_SD_en_S903_ta_read_out_sms_Auswahl_1;
                    break;
                case 3:
                    txtId = APP_SD_en_S903_ta_menu_end_Auswahl_1;
                    break;
                default:
                    txtId = APP_SD_enError;
                    break;
            }
        }
        else
        {
            switch(i)
            {
                case 1:
                    txtId = APP_SD_en_S903_ta_menu_view_Auswahl_1;
                    break;
                case 2:
                    txtId = APP_SD_en_S903_ta_menu_end_Auswahl_1;
                    break;
                default:
                    txtId = APP_SD_enError;
                    break;
            }
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}


void _APP_SD_vListDataRequest_S904(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Zeigen",
//                       "Vorlesen",
//                       "Beenden"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S904_ta_menu_show_Auswahl_1;
                break;
            case 2:
                txtId = APP_SD_en_S904_ta_menu_end_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_S933(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Ok",
//                       "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_S933_ta_menu_ok_Auswahl_1;
                break;
            case 2:
                txtId = APP_SD_en_S933_ta_list_back_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}


void _APP_SD_vListDataRequest_SC01(Uint16Type firstIdx, Uint16Type number)
{
    APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_OK;
    Uint16Type index = 0;

    /* make the firstIdx 0 based */
    firstIdx--;

    if(firstIdx < gAppSdContext.pCurCtxCtrl->sc01.contactAmb.num_ids)
    {
        index = firstIdx;
    }

    rspCode = APP_PHONEBOOK_rcRequestCompletePbEntries(
                               _APP_SD_vListDataRequest_SC01_Cb,
                               APP_PHONEBOOK_enUsersPB,
                               gAppSdContext.pCurCtxCtrl->sc01.contactAmb.item_id[index],
                               1);
    switch(rspCode)
    {
        case APP_COMMON_RSP_ERROR_BUSY:
            gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;
            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                      MSEC(10), 0);
            break;
        case APP_COMMON_RSP_OK:
            // wait for callback being called
            gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_WAIT_FOR_DATA;
            break;
        default:

            DEBUG_VALUE1(APP_SD_SWI_ERR, MOD_APP_SD, "ListDataReqSc01: err %d, goto Idle", rspCode);
            _APP_SD_vInitIdleScreen(0);
            return;
    }
}


void _APP_SD_vListDataRequest_SC03(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Aktives Geraet",
//                       "Gekopp. Geraete",
//                       "Suche",
//                       "Zurueck"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_SC03_ta_bt_active_device_Auswahl_1;
                break;
            case 2:
                txtId = APP_SD_en_SC03_ta_bt_paired_devices_Auswahl_1;
                break;
            case 3:
                txtId = APP_SD_en_SC03_ta_search_Auswahl_1;
                break;
            case 4:
                txtId = APP_SD_en_SC03_ta_list_back_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_SC12(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_SC12_ta_menu_cancel_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_SC13(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Abbruch"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_SC13_ta_menu_cancel_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}




void _APP_SD_vListDataRequest_SC16(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Ein",       // Radio button
//                       "Aus",       // Radio Button
//                       "Zurueck"};  // menue item


    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_SC16_ta_on_Auswahl_1;
                pListEntry->cell.type = KPB_CELL_TYPE_RADIO_BUTTON;
                if(gAppSdContext.pCurCtxCtrl->sc16.bPlayCallerName == BT_TRUE)
                {
                    pListEntry->cell.activated = BT_TRUE;
                }
                break;
            case 2:
                txtId = APP_SD_en_SC16_ta_off_Auswahl_1;
                pListEntry->cell.type = KPB_CELL_TYPE_RADIO_BUTTON;
                if(gAppSdContext.pCurCtxCtrl->sc16.bPlayCallerName == BT_FALSE)
                {
                    pListEntry->cell.activated = BT_TRUE;
                }
                break;
            case 3:
                txtId = APP_SD_en_SC16_ta_list_back_Auswahl_1;
                // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
                // shall be set to cell type: menue item
                pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
                break;
            default:
                txtId = APP_SD_enError;
                // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
                // shall be set to cell type: menue item
                pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_SC24(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;
//    char *tmpArr[] = { "DUMMY",
//                       "Auflegen",
//                       "Konferenz",
//                       "Mikrofon ???",
//                       "DTMF"};

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }
        switch(i)
        {
            case 1:
                txtId = APP_SD_en_SC24_ta_call_end_Auswahl_1;
                break;
            case 2:
                txtId = APP_SD_en_SC24_ta_switch_Auswahl_1;
                break;
            case 3:
                txtId = APP_SD_en_SC24_ta_head_conference_1_Zeile_1;
                break;
            case 4:
                if(APP_PHONE_bIsMicMuted() == BT_TRUE)
                {
                    txtId = APP_SD_en_SC24_ta_call_micro_on_Auswahl_1;
                }
                else
                {
                    txtId = APP_SD_en_SC24_ta_call_micro_off_Auswahl_1;
                }
                break;
            case 5:
                txtId = APP_SD_en_SC24_ta_call_dtmf_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vListDataRequest_SB34(Uint16Type firstIdx, Uint16Type number)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);
    Uint16Type i = 0;

    for( i=firstIdx; i<number+firstIdx; i++)
    {
        AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
        APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

        if(pListEntry == NULL)
        {
            break;
        }

        switch(i)
        {
            case 1:
                /* do we need a SB34 back ? */
                txtId = APP_SD_en_S008_ta_list_back_Auswahl_1;
                break;
            default:
                txtId = APP_SD_enError;
                break;
        }

        _APP_SD_vSetStaticText(txtId, &pListEntry->data);
        // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
        // shall be set to cell type: menue item
        pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
    }

    gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(0), 0);
}




void _APP_SD_vListDataRequest_S104_Cb(APP_COMMON_enResponseCode result)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);

    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S104)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vListDataRequest_S104_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }


    if( result != APP_COMMON_RSP_OK)
    {
        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vListDataRequest_S104_Cb: failed - result %d",
                      result);
        _APP_SD_vCtxHistoryStepBack();
    }
    else
    {
        Uint16Type i = 0;
        Uint16Type listIndex = 0;

        while( (listIndex = APP_SD_LC_u16GetNextListIndex(pListCtrl)) > 0)
        {
            if(listIndex < gAppSdContext.pCurCtxCtrl->common.listData.numListElems)
            {
                const AppPbEntryType *pEntry = APP_PHONEBOOK_pGetPpbrContext(i);
                AppSdListBufType  *pListEntry = NULL;

                if( pEntry  == NULL || BT_FALSE == pEntry->isValid )
                {   // no more device
                    break;
                }

                i++;

                // now we know that there is another valid element, so request
                // listBuffer
                pListEntry = APP_SD_stGetListBuffer(pListCtrl);

                // copy bt user friendly name
                pListEntry->data.length = pEntry->ppbr.name_len > KPB_MAX_CELL_CONTENT_SIZE ?
                                         KPB_MAX_CELL_CONTENT_SIZE : pEntry->ppbr.name_len;

                (void)memcpy(pListEntry->data.content, pEntry->ppbr.name, pListEntry->data.length);

                // Ticket #1786: all selectable list entries shall be of type menu item
                pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;


                /* remember the search string for the focused PB entry */
                if(listIndex == APP_SD_LC_u16GetSelectedIndex(&gAppSdContext.pCurCtxCtrl->common.listData) )
                {
                    Uint16Type followBytes = 0;
                    Uint16Type i = 0;

                    for(i=0; i<APP_SD_SEARCH_STR_SIZE && i<pListEntry->data.length; i++)
                    {
                        BooleanType   finished = BT_FALSE;
                        Uint8Type      oneByte = pListEntry->data.content[i];

                        /* reset the search string, it will always set to a new search string,
                         * accept we are pointing to a static element */
                        gAppSdContext.pCurCtxCtrl->s104.searchStringSize = 0;

                        gAppSdContext.pCurCtxCtrl->s104.searchString[i] = oneByte;

                        switch(APP_COMMON_enGetUtf8Type(oneByte))
                        {
                            case UTF8_START_BYTE_SIZE_1:
                                followBytes = 0;
                                /* special handling for SPACE */
                                if( oneByte != 0x20 )
                                {
                                    finished = BT_TRUE;
                                }
                                break;
                            case UTF8_START_BYTE_SIZE_2:
                                followBytes = 1;
                                break;
                            case UTF8_START_BYTE_SIZE_3:
                                followBytes = 2;
                                break;
                            case UTF8_START_BYTE_SIZE_4:
                                followBytes = 3;
                                break;
                            case UTF8_FOLLOW_BYTE:
                                if(followBytes > 1)
                                {
                                    followBytes--;
                                }
                                else if(followBytes == 1)
                                {
                                    /* we have read the complete utf8 char */
                                    followBytes--;
                                    finished = BT_TRUE;
                                }
                                else
                                {

                                    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vLDReq_S104_Cb: followBytes is 0 (0x%02x)",
                                                  oneByte);
                                    finished = BT_TRUE;
                                }
                                break;
                            default:

                                DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vLDReq_S104_Cb: invalid uft8 char (0x%02x)",
                                              oneByte);
                                break;
                        }

                        if(finished == BT_TRUE)
                        {
                            break;
                        }
                    }

                    gAppSdContext.pCurCtxCtrl->s104.searchStringSize = i+1;
                }
            }
            else
            {
                /* we receive the end of the pb list */
                break;
            }
        }

        gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                            MSEC(0),
                                            0);
    }
}


void _APP_SD_vListDataRequest_S105_Cb(APP_COMMON_enResponseCode result)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);

    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S105)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vListDataRequest_S105_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }


    if( result != APP_COMMON_RSP_OK)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vListDataRequest_S105_Cb: failed - result %d",
                      result);
        _APP_SD_vCtxHistoryStepBack();
    }
    else
    {
        Uint16Type listIndex = 0;

        const AppPbEntryType *pEntry = APP_PHONEBOOK_pGetPpbrContext(0);

        if(pEntry == NULL)
        {

            DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "vListDataRequest_S105_Cb: pEntry is NULL");
            _APP_SD_vCtxHistoryStepBack();
            return;
        }

        while( (listIndex = APP_SD_LC_u16GetNextListIndex(pListCtrl)) > 0 )
        {
            if( listIndex <= gAppSdContext.pCurCtxCtrl->s105.pnSize)
            {
                AppSdListBufType *pListEntry = NULL;
                const Uint8Type *telType = NULL;
                Uint16Type i = listIndex-1;
                Uint16Type numberLen = 0;

                if( pEntry->number[i].isValid != BT_TRUE )
                {
                    break;
                }

                switch(pEntry->number[i].ppbp.pn_type)
                {
                    case AT_PNT_HOME:
                        telType = KPB_PHONE_CAT_HOME_SYMBOL;
                        break;
                    case AT_PNT_OFFICE:
                        telType = KPB_PHONE_CAT_OFFICE_SYMBOL;
                        break;
                    case AT_PNT_MOBILE:
                        telType = KPB_PHONE_CAT_MOBILE_SYMBOL;
                        break;
                    case AT_PNT_GENERAL:
                        telType = KPB_PHONE_CAT_GENERAL_SYMBOL;
                        break;
                    default:
                        telType = KPB_PHONE_CAT_OTHER_SYMBOL;
                        break;
                }

                pListEntry = APP_SD_stGetListBuffer(pListCtrl);

                if(pListEntry == NULL)
                {
                    break;
                }

                // check and set length
                numberLen = pEntry->number[i].ppbp.phone_number_len;
                if(KPB_MAX_CELL_CONTENT_SIZE < (numberLen + COMMON_SYMBOL_LENGTH_OFFSET))
                {   // do not copy tooo many characters of the phone number !!!
                    numberLen = KPB_MAX_CELL_CONTENT_SIZE - COMMON_SYMBOL_LENGTH_OFFSET;
                }
                pListEntry->data.length = numberLen + COMMON_SYMBOL_LENGTH_OFFSET;
                // copy symbol
                (void)memcpy( pListEntry->data.content,
                        telType,
                        COMMON_SYMBOL_LENGTH_OFFSET);
                // copy number
                (void)memcpy( &(pListEntry->data.content[COMMON_SYMBOL_LENGTH_OFFSET]),
                        pEntry->number[i].ppbp.phone_number,
                        numberLen);
                        //pEntry->number[i].ppbp.phone_number_len);

                // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
                // shall be set to cell type: menue item
                // Susanne: 04.10.2009
                // #1786 Make phonenumbers of cell type phonenumber and all the other stuff of type menu item
                if(BT_TRUE == APP_PHONE_bIsValidPhoneNumber(pEntry->number[i].ppbp.phone_number, numberLen))
                {
                    pListEntry->cell.type = KPB_CELL_TYPE_PHONE_NUMBER;
                }
                else
                {
                    pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
                }
            }
            else
            {
                /* fill up with the static elements */
                APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;
                AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
                Uint16Type index = listIndex - gAppSdContext.pCurCtxCtrl->s105.pnSize;

                if(pListEntry == NULL)
                {
                    break;
                }
//                switch(index)               /* RT 2429 */
//                {
//                    case 1:
//                        txtId = APP_SD_en_S105_ta_pb_nametag_Auswahl_1;
//                        break;
//                    case 2:
//                        txtId = APP_SD_en_S105_ta_list_back_Auswahl_1;
//                        break;
//                    default:
//                        txtId = APP_SD_enError;
//                        break;
//                }

                if(ERM_SIVR_FULL_SUPPORTED == ERM_enIsVcrSupported())
                {
                    switch(index)
                    {
                        case 1:
                            txtId = APP_SD_en_S105_ta_pb_nametag_Auswahl_1;
                            break;
                        case 2:
                            txtId = APP_SD_en_S105_ta_list_back_Auswahl_1;
                            break;
                        default:
                            txtId = APP_SD_enError;
                            break;
                    }
                }
                else
                {
                    switch(index)
                    {
                        case 1:
                            txtId = APP_SD_en_S105_ta_list_back_Auswahl_1;
                            break;
                        default:
                            txtId = APP_SD_enError;
                            break;
                    }
                }


                _APP_SD_vSetStaticText(txtId, &pListEntry->data);
                // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
                // shall be set to cell type: menue item
                pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
            }
        }

        gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                            MSEC(0),
                                            0);
    }
}


void _APP_SD_vListDataRequest_S211_Cb(APP_COMMON_enResponseCode result)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);

    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S211)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vListDataRequest_S211_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( result != APP_COMMON_RSP_OK)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vListDataRequest_S211_Cb: failed - result %d",
                      result);
        // to avoid that user thinks that SD is freezed cause we are not able to show S211 once

        _APP_SD_vCtxHistoryStepBack();
    }
    else
    {
        Uint16Type i = 0;
        Uint16Type listIndex = 0;
        while( (listIndex = APP_SD_LC_u16GetNextListIndex(pListCtrl)) > 0)
        {
            if( listIndex <= gAppSdContext.pCurCtxCtrl->s211.pbSize)
            {
                const AppPbEntryType *pEntry    = APP_PHONEBOOK_pGetPpbrContext(i);
                AppSdListBufType  *pListEntry   = NULL;
                const Uint8Type *telType        = NULL;
                Uint16Type maxNameLen           = 0;

                if( pEntry      == NULL             ||
                    BT_FALSE    == pEntry->isValid  )
                {   // no more device
                    break;
                }

                i++;

                if( AT_FALSE == pEntry->ppbr.pn_type_numer_available )
                {
                    telType = KPB_PHONE_CAT_OTHER_SYMBOL;
                }
                else
                {
                    switch(pEntry->ppbr.pn_type)
                    {
                        case AT_PNT_HOME:
                            telType = KPB_PHONE_CAT_HOME_SYMBOL;
                            break;
                        case AT_PNT_OFFICE:
                            telType = KPB_PHONE_CAT_OFFICE_SYMBOL;
                            break;
                        case AT_PNT_MOBILE:
                            telType = KPB_PHONE_CAT_MOBILE_SYMBOL;
                            break;
                        case AT_PNT_GENERAL:
                            telType = KPB_PHONE_CAT_GENERAL_SYMBOL;
                            break;
                        default:
                            telType = KPB_PHONE_CAT_OTHER_SYMBOL;
                            break;
                    }
                }
                // now we know that there is another valid element, so request
                // listBuffer
                pListEntry = APP_SD_stGetListBuffer(pListCtrl);

                pListEntry->data.length = pEntry->ppbr.name_len + COMMON_SYMBOL_LENGTH_OFFSET;
                if( pListEntry->data.length > KPB_MAX_CELL_CONTENT_SIZE)
                {
                    pListEntry->data.length = KPB_MAX_CELL_CONTENT_SIZE;
                }
                maxNameLen = pListEntry->data.length - COMMON_SYMBOL_LENGTH_OFFSET;
                if( maxNameLen > pEntry->ppbr.name_len)
                {
                    maxNameLen = pEntry->ppbr.name_len;
                }

                /* copy icon */
                (void)memcpy( pListEntry->data.content,
                        telType,
                        COMMON_SYMBOL_LENGTH_OFFSET);

                (void)memcpy( &(pListEntry->data.content[COMMON_SYMBOL_LENGTH_OFFSET]),
                        pEntry->ppbr.name,
                        maxNameLen);

                // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
                // shall be set to cell type: menue item
                // Susanne: 04.10.2009
                // #1786 Make phonenumbers of cell type phonenumber and all the other stuff of type menu item
                if(BT_TRUE == APP_PHONE_bIsValidPhoneNumber(pEntry->ppbr.name, maxNameLen))
                {
                    pListEntry->cell.type = KPB_CELL_TYPE_PHONE_NUMBER;
                }
                else
                {
                    pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
                }
            }
            else
            {
                /* fill up with the static element */
                APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;
                AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
                Uint16Type index = listIndex - gAppSdContext.pCurCtxCtrl->s211.pbSize;

                if(pListEntry == NULL)
                {
                    break;
                }
                switch(index)
                {
                    case 1:
                        //TODO: use back of S211
                        txtId = APP_SD_en_S104_ta_list_back_Auswahl_1;
                        break;
                    default:
                        txtId = APP_SD_enError;
                        break;
                }

                _APP_SD_vSetStaticText(txtId, &pListEntry->data);
                // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
                // shall be set to cell type: menue item
                pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
            }
        }
        gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                            MSEC(0),
                                            0);
    }
}

/**************************************************/
// SMS
/**************************************************/
void _APP_SD_vListDataRequest_S404_Cb(APP_COMMON_enResponseCode result)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);

    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S404)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vListDataRequest_S404_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( result != APP_COMMON_RSP_OK)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vListDataRequest_S404_Cb: failed - result %d",
                      result);
        _APP_SD_vCtxHistoryStepBack();
    }
    else
    {
        Uint16Type i = 0;
        Uint16Type listIndex = 0;
        while( (listIndex = APP_SD_LC_u16GetNextListIndex(pListCtrl)) > 0)
        {
            if(listIndex < gAppSdContext.pCurCtxCtrl->common.listData.numListElems)
            {
                // get sms
                const AppSmsReadSmsType *pEntry = APP_SMS_pGetPmrdContext(i);
                AppSdListBufType  *pListEntry = APP_SD_stGetListBuffer(pListCtrl);

                if( pEntry      == NULL             ||
                    BT_FALSE    == pEntry->isValid  ||
                    pListEntry  == NULL)
                {   // no more sms
                    break;
                }

                i++;

                // get sms icon depending on sms type
                if(pEntry->type == AT_SMS_TYPE_UNREAD)
                {
                    APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;

                    // copy icon first
                    (void)memcpy( pListEntry->data.content,
                            KPB_UNREAD_SMS_SYMBOL,
                            COMMON_SYMBOL_LENGTH_OFFSET);

                    // copy sms origin
                    txtId = APP_SD_en_S404_new_sms_Icon_Auswahl_1;
                    _APP_SD_vSetStaticText(txtId, &pListEntry->data);
                   // (void)memcpy( &(pListEntry->data.content[COMMON_SYMBOL_LENGTH_OFFSET]),
                   //         "Neue SMS",
                   //         strlen("Neue SMS"));

                   // pListEntry->data.length = strlen("Neue SMS") + COMMON_SYMBOL_LENGTH_OFFSET;
                }
                else
                {
                    Uint16Type origin_len = 0;

                    // copy icon first
                    (void)memcpy( pListEntry->data.content,
                            KPB_READ_SMS_SYMBOL,
                            COMMON_SYMBOL_LENGTH_OFFSET);

                    origin_len = pEntry->data.origin_len;
                    if(KPB_MAX_CELL_CONTENT_SIZE < (origin_len + COMMON_SYMBOL_LENGTH_OFFSET))
                    {
                        origin_len = KPB_MAX_CELL_CONTENT_SIZE - COMMON_SYMBOL_LENGTH_OFFSET;
                    }
                    pListEntry->data.length = origin_len + COMMON_SYMBOL_LENGTH_OFFSET;

                    // copy sms origin
                    (void)memcpy(&(pListEntry->data.content[COMMON_SYMBOL_LENGTH_OFFSET]),
                                 pEntry->data.origin,
                                 origin_len);
                }

                // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
                // shall be set to cell type: menue item
                pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
            }
            else
            {
                /* we reached the end of the sms list */
                break;
            }
        }

        gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                            MSEC(0),
                                            0);
    }
}

void _APP_SD_vListDataRequest_S515_Cb(APP_COMMON_enResponseCode result)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);

    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S515)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vListDataRequest_S515_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( result != APP_COMMON_RSP_OK)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vListDataRequest_S515_Cb: failed - result %d",
                      result);
        _APP_SD_vCtxHistoryStepBack();
    }
    else
    {
        Uint16Type i = 0;
        Uint16Type listIndex = 0;
        while( (listIndex = APP_SD_LC_u16GetNextListIndex(pListCtrl)) > 0)
        {
            if( listIndex <= gAppSdContext.pCurCtxCtrl->s515.numDevs )
            {
                // get inquiry result one by another
                const ERMInquiryDataType *pEntry = ERM_pGetPgirContext(i);
                AppSdListBufType  *pListEntry = NULL;

                if( pEntry      == NULL             ||
                    BT_FALSE    == pEntry->isValid  )
                {   // no more device
                    break;
                }


                i++;

                // now we know that there is another valid element, so request
                // listBuffer
                pListEntry = APP_SD_stGetListBuffer(pListCtrl);

                // copy bt user friendly name
                pListEntry->data.length = (KPB_MAX_CELL_CONTENT_SIZE < pEntry->data.name_len) ?
                                           KPB_MAX_CELL_CONTENT_SIZE : pEntry->data.name_len;
                (void)memcpy( pListEntry->data.content, pEntry->data.name, pListEntry->data.length);

                // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
                // shall be set to cell type: menue item
                // pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
                // SUSANNE: 07.10.2009
                // Ticket: #3106 found device names shall be shortened on the left when they are too long.
                // to provide this, we use cell type phone number instead of menu item
                pListEntry->cell.type = KPB_CELL_TYPE_PHONE_NUMBER;

                if(listIndex == APP_SD_LC_u16GetSelectedIndex(pListCtrl))
                {   // src and dst are of same type
                    (void)memcpy(&gAppSdContext.pCurCtxCtrl->s515.inqData,
                                 &pEntry->data,
                                 sizeof(ATRspGetInquiryResType));
                }
            }
            else
            {
                /* fill up with the static element */
                APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;
                AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
                Uint16Type index = listIndex - gAppSdContext.pCurCtxCtrl->s515.numDevs;

                if(pListEntry == NULL)
                {
                    break;
                }
                switch(index)
                {
                    case 1:
                        txtId = APP_SD_en_S515_ta_list_back_Auswahl_1;
                        break;
                    default:
                        txtId = APP_SD_enError;
                        break;
                }

                _APP_SD_vSetStaticText(txtId, &pListEntry->data);
                // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
                // shall be set to cell type: menue item
                pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
            }
        }

        gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                            MSEC(0),
                                            0);
    }
}

void _APP_SD_vListDataRequest_SC01_Cb(APP_COMMON_enResponseCode result)
{
    AppSdFrameDataListCommon *pListCtrl = &(gAppSdContext.pCurCtxCtrl->common.listData);

    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_SC01)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vListDataRequest_SC01_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( result != APP_COMMON_RSP_OK)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vListDataRequest_SC01_Cb: failed - result %d",
                      result);
        _APP_SD_vCtxHistoryStepBack();
    }
    else
    {
        Uint16Type listIndex = 0;
        while( (listIndex = APP_SD_LC_u16GetNextListIndex(pListCtrl)) > 0)
        {
            if( listIndex <= gAppSdContext.pCurCtxCtrl->sc01.contactAmb.num_ids )
            {
                const AppPbEntryType *pEntry = APP_PHONEBOOK_pGetPpbrContext(0);
                AppSdListBufType  *pListEntry = NULL;

                if( pEntry          != NULL     &&
                    pEntry->isValid == BT_TRUE  )
                {
                    // now we know that there is a valid element, so request listBuffer
                    pListEntry = APP_SD_stGetListBuffer(pListCtrl);

                    // copy bt user name
                    pListEntry->data.length = pEntry->ppbr.name_len > KPB_MAX_CELL_CONTENT_SIZE ?
                                             KPB_MAX_CELL_CONTENT_SIZE : pEntry->ppbr.name_len;

                    (void)memcpy(pListEntry->data.content, pEntry->ppbr.name, pListEntry->data.length);
                    // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
                    // shall be set to cell type: menue item
                    pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
                }

                /* only for the last contact we loop again,
                   otherwise we need to request the next PB entry first */
                if(listIndex < gAppSdContext.pCurCtxCtrl->sc01.contactAmb.num_ids)
                {
                    break;
                }
            }
            else
            {
                /* fill up with the static element */
                APP_SD_ENUM_TEXT_PROMPTS_SEC_DISPLAY txtId = APP_SD_enError;
                AppSdListBufType *pListEntry = APP_SD_stGetListBuffer(pListCtrl);
                Uint16Type index = listIndex - gAppSdContext.pCurCtxCtrl->sc01.contactAmb.num_ids;

                if(pListEntry == NULL)
                {
                    break;
                }
                switch(index)
                {
                    case 1:
                        // TODO: add cancel of SC01
                        txtId = APP_SD_en_S001_ta_menu_cancel_Auswahl_1;
                        break;
                    default:
                        txtId = APP_SD_enError;
                        break;
                }

                _APP_SD_vSetStaticText(txtId, &pListEntry->data);
                // Ticket: #1786, all selectable list entries ( except Radio btns and Check boxes )
                // shall be set to cell type: menue item
                pListEntry->cell.type = KPB_CELL_TYPE_MENU_ITEM;
            }
        }

        gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                            MSEC(0),
                                            0);
    }
}





/* InitPending Callbacks */
void _APP_SD_vInitPendingS105_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S105)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS105_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( result != APP_COMMON_RSP_OK)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS105_Cb: failed - result %d",
                      result);

        _APP_SD_vCtxHistoryStepBack();
    }
    else
    {
        const AppPbEntryType *pEntry = APP_PHONEBOOK_pGetPpbrContext(0);

        gAppSdContext.pCurCtxCtrl->s105.pnSize = pEntry->ppbr.pn_size;
        gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

        if(ERM_SIVR_FULL_SUPPORTED == ERM_enIsVcrSupported())               /* RT 2429 */
        {
            // add pn size to the 2 static elements
            gAppSdContext.pCurCtxCtrl->common.listData.numListElems = pEntry->ppbr.pn_size + 2;
        }
        else
        {
            // add pn size to the only 1 static element, because VCR is not supported
            gAppSdContext.pCurCtxCtrl->common.listData.numListElems = pEntry->ppbr.pn_size + 1;
        }

        gAppSdContext.pCurCtxCtrl->common.pFrameData->s105.name_len =
                (AT_CALLER_ID_STRING_MAX_LEN < pEntry->ppbr.name_len) ?
                 AT_CALLER_ID_STRING_MAX_LEN : pEntry->ppbr.name_len;
        (void)memcpy(gAppSdContext.pCurCtxCtrl->common.pFrameData->s105.name,
                     pEntry->ppbr.name,
                     gAppSdContext.pCurCtxCtrl->common.pFrameData->s105.name_len);

        gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;
        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                            MSEC(0),
                                            0);
    }
}


//void _APP_SD_vInitPendingS111_Cb(APP_COMMON_enResponseCode result)
//{
//    //RS: add context sentinel, to prevent from interferenes through unexpected call
//    //    in wrong context
//    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S111)
//    {
//
//        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS111_Cb: context sentinel strikes, cur %d",
//                      gAppSdContext.pCurCtxCtrl->common.ctxId);
//        return;
//    }
//
//    if( result != APP_COMMON_RSP_OK)
//    {
//
//        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS111_Cb: failed - result %d",
//                      result);
//
//        _APP_SD_vCtxHistoryStepBack();
//    }
//    else
//    {
//        const AppPbEntryType *pEntry = APP_PHONEBOOK_pGetPpbrContext(0);
//        Uint16Type pnIdx = gAppSdContext.pCurCtxCtrl->s111.pnIndex-1;
//
//        gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;
//
//        /* get the callerId */
//        gAppSdContext.pCurCtxCtrl->common.pFrameData->s111.name_len =
//                    (AT_CALLER_ID_STRING_MAX_LEN < pEntry->ppbr.name_len) ?
//                     AT_CALLER_ID_STRING_MAX_LEN : pEntry->ppbr.name_len;
//        (void)memcpy(gAppSdContext.pCurCtxCtrl->common.pFrameData->s111.name,
//                     pEntry->ppbr.name,
//                     gAppSdContext.pCurCtxCtrl->common.pFrameData->s111.name_len);
//
//        /* get the phone number */
//        gAppSdContext.pCurCtxCtrl->common.pFrameData->s111.number_len =
//                      (AT_CALLER_ID_STRING_MAX_LEN < pEntry->number[pnIdx].ppbp.phone_number_len) ?
//                       AT_CALLER_ID_STRING_MAX_LEN : pEntry->number[pnIdx].ppbp.phone_number_len;
//        (void)memcpy(gAppSdContext.pCurCtxCtrl->common.pFrameData->s111.number,
//                     pEntry->number[pnIdx].ppbp.phone_number,
//                     gAppSdContext.pCurCtxCtrl->common.pFrameData->s111.number_len);
//
//        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
//                                            MSEC(0),
//                                            0);
//    }
//}

void _APP_SD_vInitPendingS117_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S117)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS117_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( result != APP_COMMON_RSP_OK)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendS117_Cb: failed - result %d",
                      result);

        // if only response to voice tags was error, assume voice tag number to be zero
        if(gAppSdContext.pCurCtxCtrl->s117.subState == APP_SD_S117_REQUEST_VOICE_TAG_NUMBER_SENT)
        {
            // this can happen when we recorded a voice tag or reset it and right after this request the new
            // number of voice tags for this contact
            // the error occurrs cause SIVR makes a SYNC after recording / resetting voice tags
            // so we check here, what we did last and assume that this worked
            if(APP_SD_S117_RECORD_TAG == gAppSdContext.pCurCtxCtrl->s117.lastSelMenue)
            {   // assume it worked
                gAppSdContext.pCurCtxCtrl->s117.bVoiceTagAvailable      = BT_TRUE;
                gAppSdContext.pCurCtxCtrl->common.listData.numListElems = 4;    // voice tag not available
            }
            else
            {
                gAppSdContext.pCurCtxCtrl->s117.bVoiceTagAvailable      = BT_FALSE;
                gAppSdContext.pCurCtxCtrl->common.listData.numListElems = 3;    // voice tag not available
            }
            // show frame ...
            gAppSdContext.pCurCtxCtrl->s117.subState = APP_SD_S117_REQUEST_CONTACT_INFO_NOT_SENT;
            gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;
            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING, MSEC(0), 0);

            DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendS117_Cb: ass. 0 tags");
        }
        else
        {
            _APP_SD_vCtxHistoryStepBack();
        }
    }
    else
    {
        switch(gAppSdContext.pCurCtxCtrl->s117.subState)
        {
            case APP_SD_S117_REQUEST_CONTACT_INFO_SENT:
            {
                const AppPbEntryType *pEntry = APP_PHONEBOOK_pGetPpbrContext(0);

                /* get the pb entry name */
                gAppSdContext.pCurCtxCtrl->common.pFrameData->s117.name_len =
                        (AT_CALLER_ID_STRING_MAX_LEN < pEntry->ppbr.name_len) ?
                         AT_CALLER_ID_STRING_MAX_LEN : pEntry->ppbr.name_len;
                (void)memcpy(gAppSdContext.pCurCtxCtrl->common.pFrameData->s117.name,
                             pEntry->ppbr.name,
                             gAppSdContext.pCurCtxCtrl->common.pFrameData->s117.name_len);

                // go on with init
                gAppSdContext.pCurCtxCtrl->s117.subState    = APP_SD_S117_REQUEST_VOICE_TAG_NUMBER_NOT_SENT;
                gAppSdContext.pCurCtxCtrl->common.state     = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                    MSEC(0),
                                                    0);
            }
            break;

            case APP_SD_S117_REQUEST_VOICE_TAG_NUMBER_SENT:
            {
                // check if the pbEntry has a voice tag, if yes, change number of list entries to 4
                if( 0 < APP_PHONEBOOK_GetVoiceTagNumberResponse())
                {
                    gAppSdContext.pCurCtxCtrl->s117.bVoiceTagAvailable      = BT_TRUE;
                    gAppSdContext.pCurCtxCtrl->common.listData.numListElems = 4;    // voice tag available
                }
                else
                {
                    gAppSdContext.pCurCtxCtrl->s117.bVoiceTagAvailable      = BT_FALSE;
                    gAppSdContext.pCurCtxCtrl->common.listData.numListElems = 3;    // voice tag not available
                }
                gAppSdContext.pCurCtxCtrl->s117.subState = APP_SD_S117_REQUEST_CONTACT_INFO_NOT_SENT;
                gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;
                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                    MSEC(0),
                                                    0);
            }
            break;

            default:

                DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendS117_Cb: Invalid state");
                _APP_SD_vCtxHistoryStepBack();
                break;
        }
    }
}


void _APP_SD_vInitPendingS212_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S212)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS212_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( result != APP_COMMON_RSP_OK)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendS212_Cb: failed - result %d",
                      result);

        _APP_SD_vCtxHistoryStepBack();
    }
    else
    {
        const AppPbEntryType *pEntry = APP_PHONEBOOK_pGetPpbrContext(0);

        /* first check if there is a number, if not, show S807 */
        // Check for valid number !!! cause empty name has been mapped to "unknown" in APP_PB
        // and we need to shown a frame if there is no valid phone number
        if( (NULL     == pEntry) ||
            (BT_FALSE == APP_PHONE_bIsValidPhoneNumber(pEntry->ppbr.name,        pEntry->ppbr.name_len) &&
             BT_FALSE == APP_PHONE_bIsValidPhoneNumber(pEntry->ppbr.phone_number,pEntry->ppbr.phone_number_len)) )
        {
            // neither name nor phone number field contains a valid number, so assume
            _APP_SD_vInitFrameS807();
        }
        else
        {
            gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

            /* get the callerId */
            gAppSdContext.pCurCtxCtrl->common.pFrameData->s212.name_len =
                    (AT_CALLER_ID_STRING_MAX_LEN < pEntry->ppbr.name_len) ?
                     AT_CALLER_ID_STRING_MAX_LEN : pEntry->ppbr.name_len;
            (void)memcpy(gAppSdContext.pCurCtxCtrl->common.pFrameData->s212.name,
                         pEntry->ppbr.name,
                         gAppSdContext.pCurCtxCtrl->common.pFrameData->s212.name_len);

            /* get the phone number */
            gAppSdContext.pCurCtxCtrl->common.pFrameData->s212.number_len =
                    (AT_CALLER_ID_STRING_MAX_LEN < pEntry->ppbr.phone_number_len) ?
                     AT_CALLER_ID_STRING_MAX_LEN : pEntry->ppbr.phone_number_len;
            (void)memcpy(gAppSdContext.pCurCtxCtrl->common.pFrameData->s212.number,
                         pEntry->ppbr.phone_number,
                         gAppSdContext.pCurCtxCtrl->common.pFrameData->s212.number_len);

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                MSEC(0),
                                                0);
        }
    }
}

void _APP_SD_vInitPendingS213_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S213)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS213_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( result != APP_COMMON_RSP_OK)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS213_Cb: failed - result %d",
                      result);

        _APP_SD_vCtxHistoryStepBack();
    }
    else
    {   // read date / time
        const AppSmsReadSmsType *pPmrd = APP_SMS_pGetPmrdContext(0);
        if( pPmrd != NULL && pPmrd->isValid )
        {
            AppCommonDateType dateTime;
            (void)memset(&dateTime,0,sizeof(dateTime));
            // get date / time from pmrd and split it into params
            (void)APP_COMMON_UTILS_sfConvertAtSmsDate(pPmrd->data.date, pPmrd->data.date_len, &dateTime);

            //TODO: date / time format will depend on language

            if(result == APP_COMMON_RSP_OK)
            {
                Uint8Type * pDate = gAppSdContext.pCurCtxCtrl->common.pFrameData->s213.date;
                Uint8Type * pTime = gAppSdContext.pCurCtxCtrl->common.pFrameData->s213.time;

                // first write date
                (void)sprintf((char*)pDate, "%02d.%02d.%02d", dateTime.day, dateTime.month, dateTime.year);
                gAppSdContext.pCurCtxCtrl->common.pFrameData->s213.date_len = strlen((const char*)pDate);

                // second write time
                (void)sprintf((char*)pTime, "%02d:%02d:%02d", dateTime.hour, dateTime.minute, dateTime.seconds);
                gAppSdContext.pCurCtxCtrl->common.pFrameData->s213.time_len = strlen((const char*)pTime);
            }
            else
            {
                gAppSdContext.pCurCtxCtrl->common.pFrameData->s213.date_len = 0;
                gAppSdContext.pCurCtxCtrl->common.pFrameData->s213.time_len = 0;
            }

            gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                            MSEC(0),
                                            0);
        }
    }
}




void _APP_SD_vInitPendingS405_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S405)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS405_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( result != APP_COMMON_RSP_OK)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS405_Cb: failed - result %d",
                      result);

        _APP_SD_vCtxHistoryStepBack();
    }
    else
    {   // read origin
        const AppSmsReadSmsType *pPmrd = APP_SMS_pGetPmrdContext(0);
        if( pPmrd != NULL && pPmrd->isValid )
        {
            Uint16Type maxLen = sizeof(gAppSdContext.pCurCtxCtrl->common.pFrameData->s405.origin);

            // copy origin into frame data
            gAppSdContext.pCurCtxCtrl->common.pFrameData->s405.origin_len =
                        (maxLen > pPmrd->data.origin_len) ?
                         pPmrd->data.origin_len : maxLen;
            (void)memcpy(gAppSdContext.pCurCtxCtrl->common.pFrameData->s405.origin, pPmrd->data.origin,
                         gAppSdContext.pCurCtxCtrl->common.pFrameData->s405.origin_len);

            // copy origin into current context ( needed e.g. fpr Rückruf )
            gAppSdContext.pCurCtxCtrl->s405.origin_len = (maxLen > pPmrd->data.origin_len) ?
                                                          pPmrd->data.origin_len : maxLen;
            (void)memcpy(gAppSdContext.pCurCtxCtrl->s405.origin, pPmrd->data.origin,
                         gAppSdContext.pCurCtxCtrl->s405.origin_len);


            gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_DATA;

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                            MSEC(0),
                                            0);
        }
    }
}


void _APP_SD_vInitPendingS306_Cb(APP_COMMON_enResponseCode result)
{
    BooleanType bShowFrame = BT_TRUE;

    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S306)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS306_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }



    if( APP_COMMON_RSP_OK == result )
    {
        switch(gAppSdContext.pCurCtxCtrl->s306.subState)
        {
            case APP_SD_S306_SEARCH_MAILBOX_NUMBER_SENT:
            {
                // get result of search
                Uint16Type index        = 0;
                Uint16Type numMatching  = 0;
                Uint16Type pbSize       = APP_PHONEBOOK_u16GetCurrentPBSize(APP_PHONEBOOK_enUsersPB);
                SuccessFailType sf      = APP_PHONEBOOK_pGetPbSearchResult(&index, &numMatching);
                if( SUCCESS == sf )
                {
                    bShowFrame = BT_FALSE;


                    // check if we have a result
                    if((0 < index) && (index <= pbSize) && (numMatching > 0))       // fix problem if mailbox is last entry
                    {

                        DEBUG_VALUE2( APP_SD_SWI_TRC, MOD_APP_SD, "S306_Cb: search res %d/%d", index, numMatching);
                        // request the first index cause we want to show the number
                        gAppSdContext.pCurCtxCtrl->s306.entryToBeRequested = index;
                        gAppSdContext.pCurCtxCtrl->s306.subState    = APP_SD_S306_REQUEST_FOUND_ENTRY_NOT_SENT;
                        gAppSdContext.pCurCtxCtrl->common.state     = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        return;
                    }
                    else
                    {
                        // no result, check if we have another keyword to search for
                        // increase current keyword Idx and try next keyword

                        DEBUG_VALUE2( APP_SD_SWI_TRC, MOD_APP_SD, "S306_Cb: no search res %d/%d", index, numMatching);
                        gAppSdContext.pCurCtxCtrl->s306.curKeywordIdx++;
                        gAppSdContext.pCurCtxCtrl->s306.subState    = APP_SD_S306_SEARCH_MAILBOX_NUMBER_NOT_SENT;
                        gAppSdContext.pCurCtxCtrl->common.state     = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        return;
                    }
                }
                break;
            }
            case APP_SD_S306_REQUEST_FOUND_ENTRY_SENT:
            {
                // copy number to speller
                const AppPbEntryType * pPpbr = APP_PHONEBOOK_pGetPpbrContext(0);
                if( NULL != pPpbr && pPpbr->number[0].isValid)
                {
                    // init speller with number
                    APP_SD_SC_vSetSpelledText(  &gAppSdContext.pCurCtxCtrl->s306.spellerCtrl,
                                                pPpbr->number[0].ppbp.phone_number,
                                                pPpbr->number[0].ppbp.phone_number_len);
                    APP_SD_SC_vSetDefaultCtrlSelection(&gAppSdContext.pCurCtxCtrl->s306.spellerCtrl);
                }
                else
                {

                    DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "S306_Cb: Invalid state");
                }

                // show frame in any case
                bShowFrame = BT_TRUE;
                break;
            }
            default:

                DEBUG_TEXT( APP_SD_SWI_ERR, MOD_APP_SD, "S306_Cb: Invalid state");
                break;
        }
    }

    if( BT_TRUE == bShowFrame )
    {
        // show frame with empty mailbox number

        DEBUG_TEXT(APP_SD_SWI_ERR, MOD_APP_SD, "S306_Cb: show frame");

        gAppSdContext.pCurCtxCtrl->s306.subState    = APP_SD_S306_SHOW_FRAME;
        gAppSdContext.pCurCtxCtrl->common.state     = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                            MSEC(0),
                                            0);
    }
}

void _APP_SD_vInitPendingS406_Msg_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S406)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS406_Msg_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( result != APP_COMMON_RSP_OK)
    {
        _APP_SD_vInitFrameS409(gAppSdContext.pCurCtxCtrl->s406.smsIndex);
    }
    else
    {   // read itext
        const AppSmsReadSmsType *pPmrd = APP_SMS_pGetPmrdContext(0);
        if( pPmrd != NULL && pPmrd->isValid )
        {
            Uint16Type maxLen = sizeof(gAppSdContext.pCurCtxCtrl->common.pFrameData->s406.smsText);

            // copy origin into frame data
            gAppSdContext.pCurCtxCtrl->common.pFrameData->s406.smsText_len =
                    (maxLen > pPmrd->data.message_len) ?
                     pPmrd->data.message_len : maxLen;
            (void)memcpy(gAppSdContext.pCurCtxCtrl->common.pFrameData->s406.smsText,
                   pPmrd->data.message,
                   gAppSdContext.pCurCtxCtrl->common.pFrameData->s406.smsText_len);

            // check if this is an unread sms and we need to mark it as read
            if(gAppSdContext.pCurCtxCtrl->s406.smsType == AT_SMS_TYPE_READ)
            {
                gAppSdContext.pCurCtxCtrl->s406.subState    = APP_SD_S406_SMS_REQUESTED;
                gAppSdContext.pCurCtxCtrl->common.state     = APP_SD_CTX_FRAME_REQ_DATA;
            }
            else
            {
                gAppSdContext.pCurCtxCtrl->s406.subState = APP_SD_S406_MARK_AS_READ_NOT_REQUESTED;
                gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
            }

            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                            MSEC(0),
                                            0);
        }
    }
}

void _APP_SD_vInitPendingS406_MarkAsRead_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S406)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS406_MarkAsRead_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( result != APP_COMMON_RSP_OK)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "S406_MarkAsRead_Cb: failed (%d)",
                      result);
    }

    /* in any case show the frame */
    gAppSdContext.pCurCtxCtrl->s406.subState = APP_SD_S406_SMS_REQUESTED;
    gAppSdContext.pCurCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_DATA;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);
}

void _APP_SD_vInitPendingS407_Cb(APP_COMMON_enResponseCode result)
{
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S407)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS407_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( result != APP_COMMON_RSP_OK)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vListDataRequest_S104_Cb: cancel inq. failed %d",
                      result);
    }
}

void _APP_SD_vInitPendingS517_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if((gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S517)&&\
            (gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S517_PASSIVE))
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS517_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( result != APP_COMMON_RSP_OK)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS517_Cb: failed - result %d",
                      result);

        // connection cannot be established
        _APP_SD_vInitFrameS518();
    }
}



void _APP_SD_vInitPendingS520_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S520)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS520_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( result != APP_COMMON_RSP_OK)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS520_Cb: failed - result %d",
                      result);

        // starting inquiry failed
        _APP_SD_vCtxHistoryStepBack();
    }
    else
    {
        gAppSdContext.pCurCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
        gAppSdContext.pCurCtxCtrl->s520.subState = APP_SD_S520_START_INQUIRY_SENT;

       (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FCT_PENDING,
                                          MSEC(0),
                                          0);
    }
}

void _APP_SD_vInitPendingS581_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S581)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS581_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( result != APP_COMMON_RSP_OK)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS581_Cb: failed - result %d",
                      result);

        // starting inquiry failed
        _APP_SD_vCtxHistoryStepBack();
    }
    else
    {
        gAppSdContext.pCurCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
        gAppSdContext.pCurCtxCtrl->s581.subState = APP_SD_S581_START_INQUIRY_SENT;

       (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FCT_PENDING,
                                          MSEC(0),
                                          0);
    }
}


#if 0
void _APP_SD_vInitPendingS602_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != )
    {

        return;
    }

    if( result != APP_COMMON_RSP_OK)
    {


        _APP_SD_vCtxHistoryStepBack();
    }
    else
    {
        gAppSdContext.pCurCtxCtrl->common.state     = APP_SD_CTX_FRAME_REQ_DATA;
        gAppSdContext.pCurCtxCtrl->s602.audioMode   = ERM_enGetActiveUserAudioMode();

        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                            MSEC(0),
                                            0);
    }
}
#endif


void _APP_SD_vInitPendingS669_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S669)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS669_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( result != APP_COMMON_RSP_OK)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS669_Cb: failed - result %d",
                      result);

        _APP_SD_vCtxHistoryStepBack();
    }
    else
    {
        Uint8Type mode  = APP_PHONEBOOK_u8GetSortOrder();

        gAppSdContext.pCurCtxCtrl->common.state     = APP_SD_CTX_FRAME_REQ_DATA;
        gAppSdContext.pCurCtxCtrl->s669.sortOrder   = mode;

        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                            MSEC(0),
                                            0);
    }
}



void _APP_SD_vInitPendingS801_ReqNumber_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S801)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS801_ReqNumber_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( result != APP_COMMON_RSP_OK)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS801_ReqNumber_Cb: failed - result %d",
                      result);

        _APP_SD_vCtxHistoryStepBack();
    }
    else
    {
        const AppPbEntryType *pEntry = APP_PHONEBOOK_pGetPpbrContext(0);

        gAppSdContext.pCurCtxCtrl->common.state = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
        gAppSdContext.pCurCtxCtrl->s801.subState = APP_SD_S801_NUMBER_REQUESTED;

        /* get the callerId to show in frame*/
        gAppSdContext.pCurCtxCtrl->common.pFrameData->s801.name_len =
                    (AT_CALLER_ID_STRING_MAX_LEN < pEntry->ppbr.name_len) ?
                     AT_CALLER_ID_STRING_MAX_LEN : pEntry->ppbr.name_len;
        (void)memcpy(gAppSdContext.pCurCtxCtrl->common.pFrameData->s801.name,
                     pEntry->ppbr.name,
                     gAppSdContext.pCurCtxCtrl->common.pFrameData->s801.name_len);

        if(gAppSdContext.pCurCtxCtrl->s801.pnIndex > 0)
        {
            Uint16Type pnIdx = gAppSdContext.pCurCtxCtrl->s801.pnIndex-1;
            /* get the phone number to dial */
            gAppSdContext.pCurCtxCtrl->s801.number_len =
                    (AT_CALLER_ID_STRING_MAX_LEN < pEntry->number[pnIdx].ppbp.phone_number_len) ?
                     AT_CALLER_ID_STRING_MAX_LEN : pEntry->number[pnIdx].ppbp.phone_number_len;


            (void)memcpy(gAppSdContext.pCurCtxCtrl->s801.number,
                         pEntry->number[pnIdx].ppbp.phone_number,
                         gAppSdContext.pCurCtxCtrl->s801.number_len);
        }
        else
        {
            /* get the default phone number to dial */
            gAppSdContext.pCurCtxCtrl->s801.number_len =
                    (AT_CALLER_ID_STRING_MAX_LEN < pEntry->ppbr.phone_number_len) ?
                     AT_CALLER_ID_STRING_MAX_LEN : pEntry->ppbr.phone_number_len;
            (void)memcpy(gAppSdContext.pCurCtxCtrl->s801.number,
                         pEntry->ppbr.phone_number,
                         gAppSdContext.pCurCtxCtrl->s801.number_len);
        }

        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                            MSEC(0),
                                            0);
    }
}

void _APP_SD_vInitPendingS801_Dial_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S801)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS801_Dial_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( result != APP_COMMON_RSP_OK)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS801_ReqNumber_Cb: failed - result %d",
                      result);

        // TODO: show error frame

        // we should check here, if there is any other call state ongoing, cause in most cases
        // when S801 is used to dial a number, the context history is reset. But e.g. if we have a call or
        // conference on hold an try to dial another number and we get an error, we would init the phone idle
        // screen if we get an error here, cause history back leeds to an empty history.

        // so we need to check the call states, only if all calls are idle, we can step back, else we should
        // init the correct frame
        if( BT_TRUE == APP_PHONE_AT_PNCC_bAllCallStatesIdle() )
        {
            _APP_SD_vCtxHistoryStepBack();
        }
        else
        {
            //TODO:
            _APP_SD_vHandleCallStateChanged();
        }
    }
    else
    {
        /* do nothing in the case of RSP_OK, we will wait on the CallState change event */
    }
}

void _APP_SD_vInitPendingS945_Dial_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S945)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS945_Dial_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( result != APP_COMMON_RSP_OK)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS945_ReqNumber_Cb: failed - result %d",
                      result);
        // TODO: show error frame
        _APP_SD_vCtxHistoryStepBack();
    }
    else
    {
        /* do nothing in the case of RSP_OK, we will wait on the CallState change event */
    }
}

void _APP_SD_vInitPendingSC12_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_SC12 && gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_SC12_2)
    {
        if ( result == APP_COMMON_RSP_OK && gAppSdContext.sc12SubState == APP_SD_SC12_DISCONNECT_SENT  && BT_FALSE == gAppSdContext.disconnectPlayerWillFollow)
        {
            APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_ERROR_BUSY;
            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "vInitPendingSC12_Cb: connect media player now");

            rspCode = APP_DEVICE_rcActivateMdiDevice(NULL, gAppSdContext.sc12DeviceId);
            switch(rspCode)
            {
                case APP_COMMON_RSP_ERROR_BUSY:
                    APP_DEVICE_vSetActivatePlayerPendingFlag(NULL, gAppSdContext.sc12DeviceId);
                    break;
                case APP_COMMON_RSP_OK:
                    break;
                default:
                    break;
            }
            return;
        }

        if ((gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S517)||(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S517_PASSIVE))
        {
            /* if there was a pairing request during the startup connection
             * process will cause that the MdActivate was executed in SC12 and
             * the final response from actvation is received during S517 context.*/
            DEBUG_STATE2( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingSC12_Cb: context $APP_SD_enContextId$ = %d, response $APP_COMMON_enResponseCode$ = %d",
                                  gAppSdContext.pCurCtxCtrl->common.ctxId, result);
            if( result != APP_COMMON_RSP_OK)
            {

                DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingS517_Cb: failed - result %d",
                              result);

                // connection cannot be established
                _APP_SD_vInitFrameS518();
            }
            return;

        }

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingSC12_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( result != APP_COMMON_RSP_OK)
    {
        DEBUG_VALUE2( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendSC12_Cb: failed - res %d, subState %d",
                      result, gAppSdContext.sc12SubState);


        if(gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_SC12_2)
        {
            Uint8Type counter = gAppSdContext.sc12Counter;
            BooleanType bconnectPlayer = BT_FALSE;
            Uint8Type playerProfileId = ERM_GetLastActiveProfileId( counter, APP_DEVICE_enTYPE_PLAYER);
            const ERMPlayerHeadsetProfileType *pPlayerProfile = ERM_pGetPlayerHeadsetProfile(playerProfileId);

            DEBUG_VALUE2( APP_SD_SWI_TRC, MOD_APP_SD, "vInitPendSC12_Cb: getlastactiveprofile: %d. value of counter: %d",
                      playerProfileId, counter);

            if (pPlayerProfile == NULL)
            {
                DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "vInitPendingSC12_Cb: No further Playerprofile available stop");
                _APP_SD_vInitIdleScreen(0);
                return;
            }
            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "vInitPendingSC12_Cb: TRY TO CONNECT NEXT STANDALONE MP if neccessary");

            for (counter=gAppSdContext.sc12Counter+1; counter <= ERM_MAX_NUM_HEADSET_PROFILE+1; counter++)
            {
                if (ERM_bPlayerIdIsInphoneList(pPlayerProfile->deviceIndex))
                {
                    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "vInitPendingSC12_Cb: playerprofile->Id  %d is in telefonlist",
                              pPlayerProfile->deviceIndex);

                    pPlayerProfile =  ERM_pGetPlayerHeadsetProfile(ERM_GetLastActiveProfileId( counter, APP_DEVICE_enTYPE_PLAYER));
                    if (pPlayerProfile == 0)
                    {
                        bconnectPlayer = BT_FALSE;
                        break;
                    }
                }
                else
                {
                   DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "vInitPendingSC12_Cb: playerprofile->Id %d is not in telefonlist",
                              pPlayerProfile->deviceIndex);
                   bconnectPlayer = BT_TRUE;
                   break;
                }
            }
            if (BT_TRUE == bconnectPlayer)
            {
                _APP_SD_vInitFrameSC12_2(pPlayerProfile->deviceIndex,counter);
            }
            else
            {
                DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HaInitFrS001: no further Playerprof avail");
                //_APP_SD_vCtxHistoryStepBack();
                //_APP_SD_vInitIdleScreen(0);
                _APP_SD_vInitFrameS518();
            }
        }
        else
        {
            /* failed to connect player */
            _APP_SD_vInitFrameS518();
        }
    }
    else
    {
        switch(gAppSdContext.sc12SubState)
        {
            case APP_SD_SC12_DISCONNECT_SENT:
                gAppSdContext.sc12SubState = APP_SD_SC12_CONNECT_NOT_SENT;
                _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                break;
            case APP_SD_SC12_CONNECT_SENT:
                gAppSdContext.sc12SubState = APP_SD_SC12_CONNECT_NOT_SENT;
                if(gAppSdContext.sc12DeviceId != ERM_u8GetActivePlayer())
                {
                    _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                }
                else
                {
                    _APP_SD_vInitFrameS574(gAppSdContext.sc12DeviceId);
                }
                break;
            default:
            {
                if(gAppSdContext.sc12DeviceId == ERM_u8GetActivePlayer())
                {   /* connected the wanted device */
                    _APP_SD_vInitFrameS574(gAppSdContext.sc12DeviceId);
                }
                else
                {
                    /* wrong device or other device connected as active player */
                    _APP_SD_vInitFrameS518();
                }
            }
            break;
        }
    }
}

void _APP_SD_vInitPendingSC13_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_SC13)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingSC13_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( result != APP_COMMON_RSP_OK)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vInitPendingSC13_Cb: failed - result %d",
                      result);

        // starting inquiry failed
        _APP_SD_vCtxHistoryStepBack();
    }
    else
    {
        gAppSdContext.pCurCtxCtrl->common.state  = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
        gAppSdContext.pCurCtxCtrl->sc13.subState = APP_SD_SC13_START_INQUIRY_SENT;

       (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FCT_PENDING,
                                          MSEC(0),
                                          0);
    }
}



/* ButtonPending Callbacks */
void _APP_SD_vButtonPendingS104_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context

    DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS104_Cb: called with reslut %d",
                result);

    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S104)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS104_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }


    if( APP_COMMON_RSP_OK == result)
    {
        Uint16Type index = 0;
        Uint16Type number = 0;
        Uint16Type scrollNumber = 0;
        Uint16Type selectedElem = APP_SD_LC_u16GetSelectedIndex(&gAppSdContext.pCurCtxCtrl->common.listData);

        if( gAppSdContext.pCurCtxCtrl->s104.subStateBtn != APP_SD_S104_PB_SEARCH_SENT )
        {   /* invalid state */

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "ButtonPendingS104_Cb: invalid state %d",
                          result);
            _APP_SD_vInitIdleScreen(0);
            return;
        }

        if( APP_PHONEBOOK_pGetPbSearchResult(&index, &number) != SUCCESS )
        {

            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "ButtonPendingS104_Cb: GetPbSearchResult failed",
                          result);
            _APP_SD_vInitIdleScreen(0);
            return;
        }

        if(selectedElem < index)
        {

            DEBUG_VALUE2( APP_SD_SWI_TRC, MOD_APP_SD, "ButtonPendingS104_Cb: idx invalid (%d %d)",
                          selectedElem,
                          index);
//            _APP_SD_vInitIdleScreen(0);            //RT #4232
//            return;
        }

        DEBUG_VALUE2( APP_SD_SWI_TRC, MOD_APP_SD, "ButtonPendingS104_Cb: SelEl=%d, index= %d",
                selectedElem, index);

        switch(gAppSdContext.pCurCtxCtrl->s104.searchDirection)
        {
            case enLogiButManMflDown:
                if(selectedElem <= gAppSdContext.pCurCtxCtrl->s104.pbSize)
                {
                    if(selectedElem >= number + index)
                    {

                        DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "ButtonPendingS104_Cb: operation not allowed, scroll up");

                        if(selectedElem > 1)
                        {
                            scrollNumber = selectedElem - index + 1;

                            DEBUG_VALUE2( APP_SD_SWI_DBG, MOD_APP_SD, "S104_Cb up: maxElements %d idx %d",
                                          gAppSdContext.pCurCtxCtrl->s104.pbSize,
                                          index);
                            DEBUG_VALUE2( APP_SD_SWI_DBG, MOD_APP_SD, "S104_Cb up: selectedElem %d scrollNumber %d",
                                          selectedElem,
                                          scrollNumber);
                        }
                        else
                        {
                            /* do only one scroll if we are pointing to the first list element (rollover) */
                            scrollNumber = 1;

                            DEBUG_TEXT( APP_SD_SWI_DBG, MOD_APP_SD, "S104_Cb: rollover");
                        }
                        /* check first line in the list */
                        if(0 == index) //RT:5718
                        {
                            _APP_SD_ListRollover = TRUE;

                            DEBUG_TEXT( APP_SD_SWI_DBG, MOD_APP_SD, "S104_Cb: TOP of list");
                            scrollNumber = scrollNumber - 1;
                        }
                        // don't change the searchdirection risk to high for c muster
                        //gAppSdContext.pCurCtxCtrl->s104.searchDirection = enLogiButManMflUp;
                    }
                    else
                    {
                        scrollNumber = selectedElem - index;
                        scrollNumber = number - scrollNumber;

                        DEBUG_VALUE2( APP_SD_SWI_DBG, MOD_APP_SD, "S104_Cb down: maxElements %d idx %d",
                                      gAppSdContext.pCurCtxCtrl->s104.pbSize,
                                      index);
                        DEBUG_VALUE2( APP_SD_SWI_DBG, MOD_APP_SD, "S104_Cb down: selectedElem %d scrollNumber %d",
                                      selectedElem,
                                      scrollNumber);

                        /* check last entry in the list */
                        if((index - 1 + scrollNumber) == gAppSdContext.pCurCtxCtrl->s104.pbSize)
                        {
                            _APP_SD_ListRollover = TRUE;

                            DEBUG_TEXT( APP_SD_SWI_DBG, MOD_APP_SD, "S104_Cb: ENDE of list");
                        }
                    }
                }
                else
                {
                    /* do only one scroll if we are pointing to 'back' (rollover) */
                    scrollNumber = 1;

                    DEBUG_TEXT( APP_SD_SWI_DBG, MOD_APP_SD, "S104_Cb: rollover");
                }

                APP_SD_LC_vScrollUpDown( &(gAppSdContext.pCurCtxCtrl->common.listData),
                                         gAppSdContext.pCurCtxCtrl->s104.searchDirection,
                                         scrollNumber);

                break;
            case enLogiButManMflUp:
                if(selectedElem > 1)
                {
                    if(selectedElem >= index)
                    {
                        scrollNumber = selectedElem - index + 1;

                        DEBUG_VALUE2( APP_SD_SWI_DBG, MOD_APP_SD, "S104_Cb up: maxElements %d idx %d",
                                      gAppSdContext.pCurCtxCtrl->s104.pbSize,
                                      index);
                        DEBUG_VALUE2( APP_SD_SWI_DBG, MOD_APP_SD, "S104_Cb up: selectedElem %d scrollNumber %d",
                                      selectedElem,
                                      scrollNumber);

                        /* check first line in the list */
                        if(0 == index) //RT:5718
                        {
                            _APP_SD_ListRollover = TRUE;

                            DEBUG_TEXT( APP_SD_SWI_DBG, MOD_APP_SD, "S104_Cb: TOP of list");
                            scrollNumber = scrollNumber - 1;
                        }

                    }
                    else
                    {

                        DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "ButtonPendingS104_Cb: operation not allowed, scroll down");

                        scrollNumber = selectedElem - index;
                        scrollNumber = number - scrollNumber;

                        DEBUG_VALUE2( APP_SD_SWI_DBG, MOD_APP_SD, "S104_Cb down: maxElements %d idx %d",
                                      gAppSdContext.pCurCtxCtrl->s104.pbSize,
                                      index);
                        DEBUG_VALUE2( APP_SD_SWI_DBG, MOD_APP_SD, "S104_Cb down: selectedElem %d scrollNumber %d",
                                      selectedElem,
                                      scrollNumber);

                        /* check last entry in the list */
                        if((index - 1 + scrollNumber) == gAppSdContext.pCurCtxCtrl->s104.pbSize)
                        {
                            _APP_SD_ListRollover = TRUE;

                            DEBUG_TEXT( APP_SD_SWI_DBG, MOD_APP_SD, "S104_Cb: ENDE of list");
                        }
                        // don't change the searchdirection risk to high for c muster
                        //gAppSdContext.pCurCtxCtrl->s104.searchDirection = enLogiButManMflDown;
                    }
                }
                else
                {
                    /* do only one scroll if we are pointing to the first list element (rollover) */
                    scrollNumber = 1;

                    DEBUG_TEXT( APP_SD_SWI_DBG, MOD_APP_SD, "S104_Cb: rollover");
                }

                APP_SD_LC_vScrollUpDown( &(gAppSdContext.pCurCtxCtrl->common.listData),
                                         gAppSdContext.pCurCtxCtrl->s104.searchDirection,
                                         scrollNumber);
                break;
            default:

                DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "ButtonPendingS104_Cb: inv search direc (%d)",
                              gAppSdContext.pCurCtxCtrl->s104.searchDirection);
                _APP_SD_vInitIdleScreen(0);
                return;
        }

        _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
    }
    else
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "ButtonPendingS104_Cb: PB search failed %d",
                      result);
        _APP_SD_vInitIdleScreen(0);
    }
}

void _APP_SD_vButtonPendingS104_Cb2(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context

    const AppPbEntryType *pEntry = APP_PHONEBOOK_pGetPpbrContext(0);

    DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "buttonpendings104_2 callback called");

    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S104)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS104_Cb2: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if (pEntry->ppbr.pn_size >1)
    {
        _APP_SD_vInitFrameS105(gAppSdContext.pCurCtxCtrl->s104.selectedIndex);
    }
    else
    {
        _APP_SD_vInitFrameS801_PB(gAppSdContext.pCurCtxCtrl->s104.selectedIndex, 0);
    }

}

void _APP_SD_vButtonPendingS306_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S306)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS306_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( APP_COMMON_RSP_OK == result)
    {
        if( gAppSdContext.pCurCtxCtrl->s306.subStateBtn != APP_SD_S306_SAVE_MAILBOX_NUMBER_NOT_SENT )
        {   /* invalid state */
            _APP_SD_vCtxHistoryStepBack();
            return;
        }

        /* number successfully saved */
        /* check if user just wanted to save mailbox number or dial it after saving */
        switch (gAppSdContext.pCurCtxCtrl->s306.buttonId)
        {
            case enLogiButManMflHook:
            {
                /* set state to dial not sent and set alarm */
                gAppSdContext.pCurCtxCtrl->s306.subStateBtn = APP_SD_S306_DIAL_MAILBOX_NUMBER_NOT_SENT;
                (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                    MSEC(0),
                                                    0);
                break;
            }
            case enLogiButManMflOk:
            default:
            {
                switch( APP_SD_SC_vButtonOk(&(gAppSdContext.pCurCtxCtrl->s306.spellerCtrl)) )
                {
                    case APP_SD_SC_CONTROL_DIAL:
                        /* set state to dial not sent and set alarm */
                        gAppSdContext.pCurCtxCtrl->s306.subStateBtn = APP_SD_S306_DIAL_MAILBOX_NUMBER_NOT_SENT;
                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
                        break;
                    case APP_SD_SC_CONTROL_SAVE:
                    default:
                        /* finished */
                        _APP_SD_vCtxHistoryStepBack();
                        break;
                }
                break;
            }
        }
    }
    else
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "ButtonPendingS306_Cb: saving mailbox number failed %d",
                      result);
        _APP_SD_vCtxHistoryStepBack();
    }
}



void _APP_SD_vButtonPendingS413_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S408_USERLIST)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS413_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( APP_COMMON_RSP_OK == result)
    {
        _APP_SD_vInitFrameS425();
    }
    else
    {
        _APP_SD_vInitFrameS428();
    }
}


void _APP_SD_vButtonPendingS642_Cb(APP_COMMON_enResponseCode result)
{
    if( result != APP_COMMON_RSP_OK )
    {
        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS642_Cb: failed - result %d",
                      result);
    }
    else
    {
        APP_DEVICE_rcStopRingtoneNonBlock();
        _APP_SD_vCtxHistoryStepBack();
    }
}

void _APP_SD_vButtonPendingS512_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S512)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS512_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( APP_COMMON_RSP_OK == result)
    {
        _APP_SD_vInitIdleScreen(0);
    }
    else
    {
        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS512_Cb: failed %d",
                      result);
       (void) _APP_SD_vReleasePendingContext(__LINE__);
    }
}
void _APP_SD_vButtonPendingS515_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if((gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S515)&&
            (gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S408))
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS515_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( APP_COMMON_RSP_OK == result)
    {
        _APP_SD_vInitFrameS408(gAppSdContext.pCurCtxCtrl->s515.inqData.device_id, gAppSdContext.pCurCtxCtrl->s515.deviceType);
        //_APP_SD_vInitFrameS52C(gAppSdContext.pCurCtxCtrl->s515.inqData.device_id, AT_INQUIRY_DEVICE, gAppSdContext.pCurCtxCtrl->s515.deviceType);
    }
    else
    {
        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS515_Cb: failed %d",
                      result);
       (void) _APP_SD_vReleasePendingContext(__LINE__);
    }
}

void _APP_SD_vButtonPendingS51D_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S51D &&
       gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S408 )     // when pairing request is sent we immeadiateley init S408
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS51D_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( APP_COMMON_RSP_OK != result)
    {
        // RT #4735 430 different to spec: BT-PIN Timeout -> Screen "Verbindung nicht möglich "
        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS51D_Cb: Pairing not possible, cur %d",
                gAppSdContext.pCurCtxCtrl->common.ctxId);
        if (BT_FALSE == _APP_SD_bPhoneContextActive())
        {
            _APP_SD_vReleasePhoneContext();
        }
        else
        {
            _APP_SD_vInitFrameS521();
        }
    }
}


void _APP_SD_vButtonPendingS520_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S520)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS520_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( APP_COMMON_RSP_OK == result)
    {
        // cancelled inquiry, now go back in history
        _APP_SD_vCtxHistoryStepBack();
    }
    else
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS520_Cb: Cancel inquiry failed %d",
                      result);
        //RS: it makes no sense to stay in the inquiry context if cancel is not possible,
        //    otherwise we would stay forever
        //(void) _APP_SD_vReleasePendingContext(__LINE__);
        _APP_SD_vCtxHistoryStepBack();
    }
}

/* RT-13181-Phone */
void _APP_SD_vButtonPendingS522_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S522)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS522_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( APP_COMMON_RSP_OK == result)
    {
        _APP_SD_vInitFrameS408(gAppSdContext.pCurCtxCtrl->s522.deviceId, gAppSdContext.pCurCtxCtrl->s522.deviceType);
    }
    else
    {
        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS522_Cb: failed %d",
                      result);
       (void) _APP_SD_vReleasePendingContext(__LINE__);
    }
}


void _APP_SD_vButtonPendingS52C_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if((gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S52C) &&
       (gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S52D))
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS52C_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( APP_COMMON_RSP_OK != result)
    {
        /* BT-PIN negative response -> Screen "Verbindung nicht möglich ".
         * but be aware that s52D could be active and this frame should stay
         * at least 2 seconds in focus. If error is return by ERM we set the
         * S52D.substate to pairing failed.
         * */
        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS52C_Cb: Pairing not possible, cur %d",
                                                  gAppSdContext.pCurCtxCtrl->common.ctxId);

        if(gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_S52D)
        {
            gAppSdContext.pCurCtxCtrl->s52D.subState = APP_SD_S52D_PPRS_FAILED;
        }else
        {
            _APP_SD_vInitFrameS521();
        }
    }
    return;
}

void _APP_SD_vButtonPendingS933_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S933 )     // when pairing request is sent we immeadiateley init S408
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS933_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( APP_COMMON_RSP_OK != result)
    {
        if ( APP_SD_S933_REJECT_NOT_SENT == gAppSdContext.pCurCtxCtrl->s933.subStateBtn)
        {
            /* error from ERM received */
            DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS933_Cb: Reject Pairing not possible, cur %d",
                    gAppSdContext.pCurCtxCtrl->common.ctxId);
            (BT_FALSE == _APP_SD_bPhoneContextActive())?_APP_SD_vCtxHistoryStepBack():_APP_SD_vReleasePhoneContextWithStepBack();
        }
    }
    else
    {
        gAppSdContext.pCurCtxCtrl->s933.subStateBtn = APP_SD_S933_REJECT_SENT;
    }
}

void _APP_SD_vButtonPendingS556_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S556)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS556_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( APP_COMMON_RSP_OK == result)
    {
        _APP_SD_vInitFrameS533();
    }
    else
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS556_Cb: unhandled error %d",
                      result);
       (void) _APP_SD_vReleasePendingContext(__LINE__);
    }
}

void _APP_SD_vButtonPendingS563_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S563)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS563_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( APP_COMMON_RSP_OK == result)
    {
        _APP_SD_vInitFrameS565(gAppSdContext.pCurCtxCtrl->s563.deviceType);
    }
    else
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS563_Cb: unhandled error %d",
                      result);
       (void) _APP_SD_vReleasePendingContext(__LINE__);
    }
}

void _APP_SD_vButtonPendingS572_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S572)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS572_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( (APP_COMMON_RSP_OK == result) && (APP_SD_S572_DISCONNECT_SENT == gAppSdContext.pCurCtxCtrl->s572.subStateBtn)) /*RT13181: 4 digit pin shown instead of SSP*/
    {
        /* Disconnect was done, now connect the new device */
        if(gAppSdContext.pCurCtxCtrl->s572.isInquiryId == BT_TRUE)
        {
            if(BT_TRUE == APP_MDI_bMutePlayer(APP_MDI_MUTE_DEVICE_CONNECT))
            {
                _APP_SD_vInitFrameS522(APP_SD_MDI_MUTE_FOR_PAIRING, gAppSdContext.pCurCtxCtrl->s572.deviceId,
                        gAppSdContext.pCurCtxCtrl->s572.deviceType, BT_FALSE);
            }
            else
            {
                _APP_SD_vInitFrameS408_SSP(gAppSdContext.pCurCtxCtrl->s572.deviceId, gAppSdContext.pCurCtxCtrl->s572.deviceType);
            }
        }
        else
        {
            if(BT_TRUE == APP_MDI_bMutePlayer(APP_MDI_MUTE_DEVICE_CONNECT))
            {
                _APP_SD_vInitFrameS522(APP_SD_MDI_MUTE_FOR_CONNECT, gAppSdContext.pCurCtxCtrl->s572.deviceId,
                        gAppSdContext.pCurCtxCtrl->s572.deviceType, BT_TRUE);
            }
            else
            {
                /* Just connect the service of the already paired device */
                _APP_SD_vInitFrameS517( gAppSdContext.pCurCtxCtrl->s572.deviceId,
                        gAppSdContext.pCurCtxCtrl->s572.deviceType, BT_TRUE);
            }
        }
    }
    else
    {
        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS572_Cb: unhandled error %d",
                      result);
       (void) _APP_SD_vReleasePendingContext(__LINE__);
    }
}

//void _APP_SD_vButtonPendingS535_Cb(APP_COMMON_enResponseCode result)
//{
//    //RS: add context sentinel, to prevent from interferenes through unexpected call
//    //    in wrong context
//    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S535)
//    {
//
//        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS535_Cb: context sentinel strikes, cur %d",
//                      gAppSdContext.pCurCtxCtrl->common.ctxId);
//        return;
//    }
//
//    if( APP_COMMON_RSP_OK == result)
//    {
//        /* successfully deleted profile */
//        _APP_SD_vInitFrameS539();
//    }
//    else
//    {
//
//        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS535_Cb: failed %d",
//                      result);
//       (void) _APP_SD_vReleasePendingContext(__LINE__);
//    }
//}

void _APP_SD_vButtonPendingS536_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S536)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS536_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( APP_COMMON_RSP_OK == result)
    {
        /* successfully saved profile */
        _APP_SD_vInitFrameS533();
    }
    else
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS536_Cb: failed %d",
                      result);
       (void) _APP_SD_vReleasePendingContext(__LINE__);
    }
}


void _APP_SD_vButtonPendingS575_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S575)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS575_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( APP_COMMON_RSP_OK == result)
    {
        /* successfully saved profile */
        _APP_SD_vInitFrameS533();
    }
    else
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS575_Cb: failed %d",
                      result);
       (void) _APP_SD_vReleasePendingContext(__LINE__);
    }
}


//void _APP_SD_vButtonPendingS580_Cb(APP_COMMON_enResponseCode result)
//{
//    //RS: add context sentinel, to prevent from interferenes through unexpected call
//    //    in wrong context
//    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S580)
//    {
//
//        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS580_Cb: context sentinel strikes, cur %d",
//                      gAppSdContext.pCurCtxCtrl->common.ctxId);
//        return;
//    }
//
//    if( APP_COMMON_RSP_OK == result)
//    {
//        /* check what we have to do next */
//        /* ticket 8480: uncomment code
//         * if( APP_SD_S580_DELETE_OLDEST_USER_PROFILE_NOT_SENT == gAppSdContext.pCurCtxCtrl->s580.subStateBtn )
//        {
//            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "vButtonPendingS580_Cb: state %d correct done",
//                      gAppSdContext.pCurCtxCtrl->s580.subStateBtn);
//            if( BT_TRUE == ERM_bMaxNumberOfPlayerProfilesReached() ||
//                BT_TRUE == ERM_bMaxNumberOfPlayerHeadsetProfilesReached())
//            {
//                gAppSdContext.pCurCtxCtrl->s580.subStateBtn = APP_SD_S580_DELETE_OLDEST_PLAYER_PROFILE_NOT_SENT;
//                DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "vButtonPendingS580_Cb: activate state %d max. player profiles reached",
//                      gAppSdContext.pCurCtxCtrl->s580.subStateBtn);
//            }
//            else
//            {
//                gAppSdContext.pCurCtxCtrl->s580.subStateBtn = APP_SD_S580_ADD_NEW_USER_PROFILE_NOT_SEND;
//                DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "vButtonPendingS580_Cb: activate state %d player profile free",
//                      gAppSdContext.pCurCtxCtrl->s580.subStateBtn);
//            }
//            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
//                                                MSEC(0),
//                                                0);
//        }
//        else ticket 8480: end of uncommented code */
//        if( APP_SD_S580_DELETE_OLDEST_PLAYER_PROFILE_NOT_SENT == gAppSdContext.pCurCtxCtrl->s580.subStateBtn )
//        {
//            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "vButtonPendingS580_Cb: state %d correct done",
//                      gAppSdContext.pCurCtxCtrl->s580.subStateBtn);
//            gAppSdContext.pCurCtxCtrl->s580.subStateBtn = APP_SD_S580_ADD_NEW_USER_PROFILE_NOT_SEND;
//            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
//                                                MSEC(0),
//                                                0);
//        }
//        else if( APP_SD_S580_ADD_NEW_USER_PROFILE_NOT_SEND == gAppSdContext.pCurCtxCtrl->s580.subStateBtn )
//        {
//            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "vButtonPendingS580_Cb: state %d correct done",
//                      gAppSdContext.pCurCtxCtrl->s580.subStateBtn);
//            gAppSdContext.pCurCtxCtrl->s580.subStateBtn = APP_SD_S580_ADD_NEW_PLAYER_PROFILE_NOT_SEND;
//            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
//                                                MSEC(0),
//                                                0);
//        }
//        else if( APP_SD_S580_DELETE_CURRENT_PROFILE_NOT_SENT == gAppSdContext.pCurCtxCtrl->s580.subStateBtn )
//        {
//            DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "vButtonPendingS580_Cb: state APP_SD_S580_DELETE_CURRENT_PROFILE_NOT_SENT correct done");
//            _APP_SD_vCtxHistoryStepBack();
//        }
//        else
//        {   /* successfully saved profile */
//            _APP_SD_vInitFrameS533();
//        }
//    }
//    else
//    {
//
//        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS580_Cb: failed %d",
//                      result);
//       (void) _APP_SD_vReleasePendingContext(__LINE__);
//    }
//}


void _APP_SD_vButtonPendingS581_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S581)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS581_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( APP_COMMON_RSP_OK == result)
    {
        // cancelled inquiry, now go back in history
        _APP_SD_vCtxHistoryStepBack();
    }
    else
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS581_Cb: Cancel inquiry failed %d",
                      result);
       (void) _APP_SD_vReleasePendingContext(__LINE__);
    }
}



void _APP_SD_vButtonPendingS661_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S661)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS661_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( APP_COMMON_RSP_OK == result)
    {
        _APP_SD_vInitFrameS663();
    }
    else
    {
        // SUSANNE: 30.10.2009
        // If we get an error, but there is a sync in progress, than we also show S663
        // followed by S102
        // But when we get an error although there is no sync in progress we must
        // show S664. Else we will hang in S102 and pb will not be available in SD
        // until we reconnect the phone

        if(BT_TRUE == APP_PHONEBOOK_bPbUpdateInProgress())   // automatic or manual sync
        {
            /* there is a sync already in progress, so show S663 and S102 */
            _APP_SD_vInitFrameS663();
        }
        else
        {   /* we got an error although no sync is in progress, so update failed */
            _APP_SD_vInitFrameS664();
        }
    }
}

void _APP_SD_vButtonPendingS669_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S669)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS669_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    // do not trigger sync anymore. is done already via Ck5050

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "ButtonPendingS669_Cb: change pb sort res %d",
                      result);

    if(result == APP_COMMON_RSP_OK)
    {
        // show Bitte warten frame until sorting has been finished
        _APP_SD_vInitFrameS663_PB();
    }
    else
    {
        //_APP_SD_vCtxHistoryStepBack();
        // SUSANNE 14.11.2009 #3608 show S664 when we get an error from CK5050
        _APP_SD_vInitFrameS664();
    }
}

void _APP_SD_vButtonPendingS812_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_S812)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingS812_Cb: context sentinel strikes, cur %d",
                      gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }


    if( gAppSdContext.pCurCtxCtrl->s812.subStateBtn == APP_SD_S812_CONFERENCE_SENT )
    {
        if(result != APP_COMMON_RSP_OK)
        {
            /* Conference not possible */
            // TODO: show error frame
            _APP_SD_vInitFrameS814();
        }

        /* final state reached */
       (void) _APP_SD_vReleasePendingContext(__LINE__);
    }
    else
    {
        /* APP_SD_S812_HANGUP_BOTH_SENT */
        DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "vButtonPendingS812_Cb: Both calls hangup");
        /* final state reached */
       (void) _APP_SD_vReleasePendingContext(__LINE__);
    }
}

void _APP_SD_vButtonPendingSC13_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_SC13)
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingSC13_Cb: context sentinel strikes, cur %d",
                            gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( APP_COMMON_RSP_OK == result)
    {
        // cancelled inquiry, now go back in history
        _APP_SD_vCtxHistoryStepBack();
    }
    else
    {

        DEBUG_VALUE1(APP_SD_SWI_ERR, MOD_APP_SD, "vButtonPendingSC13_Cb: Cancel inquiry failed %d",
                        result);
       (void) _APP_SD_vReleasePendingContext(__LINE__);
    }
}

void _APP_SD_vButtonPendingSC24_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(gAppSdContext.pCurCtxCtrl->common.ctxId != APP_SD_CONTEXT_SC24)
    {

        DEBUG_VALUE1(APP_SD_SWI_ERR, MOD_APP_SD, "ButtonPendingSC24_Cb: context sentinel strikes, cur %d",
                            gAppSdContext.pCurCtxCtrl->common.ctxId);
        return;
    }

    if( gAppSdContext.pCurCtxCtrl->sc24.subStateBtn == APP_SD_SC24_CONFERENCE_SENT )
    {
        if(result != APP_COMMON_RSP_OK)
        {
            /* Conference not possible */
            // TODO: show error frame
            _APP_SD_vInitFrameS814();
        }

        /* final state reached */
       (void) _APP_SD_vReleasePendingContext(__LINE__);
    }
}
void _APP_SD_vInitPendingS408_Cb(APP_COMMON_enResponseCode result)
{
    //RS: add context sentinel, to prevent from interferenes through unexpected call
    //    in wrong context
    if(APP_SD_CONTEXT_SC24 != gAppSdContext.pCurCtxCtrl->common.ctxId )
    {

        DEBUG_VALUE1(APP_SD_SWI_ERR, MOD_APP_SD, "ButtonPendingSC24_Cb: context sentinel strikes, cur %d",
                            gAppSdContext.pCurCtxCtrl->common.ctxId);
    }
    else
    {
        if(result != APP_COMMON_RSP_OK)
        {
            if (APP_SD_S408_WAIT_FOR_SSP_SUPPORT == gAppSdContext.pCurCtxCtrl->s408.subState )
            {
                DEBUG_TEXT(APP_SD_SWI_ERR, MOD_APP_SD,"_APP_SD_vHandleInitS408_Cb: failed to send PBSF!!!");
            }
            else if (APP_SD_S408_RECEIVED_SSP_SUPPORT == gAppSdContext.pCurCtxCtrl->s408.subState)
            {
                DEBUG_TEXT(APP_SD_SWI_ERR, MOD_APP_SD,"_APP_SD_vHandleInitS408_Cb: failed to initiate pairing!!!");
            }
            else
            {
                DEBUG_STATE1(APP_SD_SWI_ERR, MOD_APP_SD,"_APP_SD_vHandleInitS408_Cb: error in weird substate $APP_SD_enSubStateS408$ = %d ", gAppSdContext.pCurCtxCtrl->s408.subState);
            }
            /* release all pending context to avoid blocking SD module */
            (void) _APP_SD_vReleasePendingContext(__LINE__);
            /* show error frame */
            _APP_SD_vInitFrameS518();
        }
        else
        {
            DEBUG_STATE1(APP_SD_SWI_ERR, MOD_APP_SD,"_APP_SD_vHandleInitS408_Cb: okay in substate $APP_SD_enSubStateS408$ = %d ", gAppSdContext.pCurCtxCtrl->s408.subState);
        }
    }
}


void _APP_SD_vCtxHistoryReset(AppSdCtxCtrlType *pCtxCtrl)
{
    // we don't need to copy pCtxCtrl, but we need to check if pCtxCtrl and gAppSdContext.ctxHistory[0] are pointing to the same
    // memory. Cause memcpy has undefined behaviour when src and dst memory overlap.

    DEBUG_STATE1(APP_SD_SWI_TRC, MOD_APP_SD, "CtxHistReset: ctxId $APP_SD_enContextId$ = %d", pCtxCtrl->common.ctxId);

    /* first we let pCurCtxCtrl point again to the first entry in History */
    gAppSdContext.curCtxCtrlId = 0;
    gAppSdContext.pCurCtxCtrl = &gAppSdContext.ctxHistory[0];

    /* now we need to copy pCtxCtrl into pCurCtrl, but ONLY, if they point to different memory */
    if(pCtxCtrl != gAppSdContext.pCurCtxCtrl)
    {
        /* save the pending ctxCtrl to the current CtxCtrl */
        *(gAppSdContext.pCurCtxCtrl) = *pCtxCtrl;
    }
    /* else the gAppSdContext.pCurContext already points to the same location as pCurCtrl */


    DEBUG_STATE1(APP_SD_SWI_TRC, MOD_APP_SD, "CtxHistReset: ctxId now $APP_SD_enContextId$ = %d",
                        gAppSdContext.pCurCtxCtrl->common.ctxId);
}


SuccessFailType _APP_SD_sfCtxHistoryAppend(AppSdCtxCtrlType *pCtxCtrl)
{
    if( gAppSdContext.curCtxCtrlId + 1 >= APP_SD_MAX_CTX_DEPTH)
    {

        DEBUG_STATE1(APP_SD_SWI_ERR, MOD_APP_SD, "AppendCtxHist: out of ctxCtrl, new ctxId $APP_SD_enContextId$ = %d",
                        pCtxCtrl->common.ctxId);
        return FAIL;
    }

    if(gAppSdContext.pCurCtxCtrl->common.timeout > 0)
    {
        /* save the frame timeout value */
        Uint32Type timeout = 0;

        if( APP_COMMON_UTILS_stGetTimeoutLeft( CTA_APP_SD_FRAME_TIMEOUT, &timeout ) != E_OK)
        {
            timeout = 0;
        }

        /* to avoid freeze of a popup which had 0s timeout left here, or to avoid flickering
           set timeout to at least */
        if(timeout < APP_SD_MS_TIMEOUT_1000)
        {
            timeout = APP_SD_MS_TIMEOUT_1000;
        }

        gAppSdContext.pCurCtxCtrl->common.timeout = timeout;


        DEBUG_VALUE2(APP_SD_SWI_TRC, MOD_APP_SD, "AppendCtxHist: save timeout %d, ctxId %d",
                        gAppSdContext.pCurCtxCtrl->common.timeout,
                        gAppSdContext.pCurCtxCtrl->common.ctxId);
    }

    gAppSdContext.curCtxCtrlId++;
    gAppSdContext.pCurCtxCtrl = &gAppSdContext.ctxHistory[gAppSdContext.curCtxCtrlId];

    /* save the pending ctxCtrl to the current CtxCtrl */
    (void)memcpy(gAppSdContext.pCurCtxCtrl, pCtxCtrl, sizeof(*gAppSdContext.pCurCtxCtrl));




    DEBUG_STATE1(APP_SD_SWI_TRC, MOD_APP_SD, "AppendCtxHist: ctx $APP_SD_enContextId$ = %d",
                    pCtxCtrl->common.ctxId)

    DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "AppendCtxHist: at pos %d",
                    gAppSdContext.curCtxCtrlId);
    return SUCCESS;
}

void _APP_SD_vCtxHistoryReplaceCurrent(AppSdCtxCtrlType *pCtxCtrl)
{
    // check if pCtxCtrl has a valid ctx Id
    if( APP_SD_CONTEXT_INVALID >= pCtxCtrl->common.ctxId ||
        APP_SD_CONTEXT_LAST <= pCtxCtrl->common.ctxId )
    {

        DEBUG_VALUE1( APP_SD_SWI_ERR, MOD_APP_SD, "HistReplCur: new ctxId invalid (%d)",
                            pCtxCtrl->common.ctxId);
    }



    DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "HistReplIdx: repl. pos %d ... ",
                        gAppSdContext.curCtxCtrlId);
    DEBUG_STATE2(APP_SD_SWI_TRC, MOD_APP_SD, "HistReplIdx: repl. ... with ctxId $APP_SD_enContextId$ = %d, new ctxId $APP_SD_enContextId$ = %d",
                        gAppSdContext.pCurCtxCtrl->common.ctxId,
                        pCtxCtrl->common.ctxId);



    (void)memset(gAppSdContext.pCurCtxCtrl, 0, sizeof(*(gAppSdContext.pCurCtxCtrl)));

    /* save the pending ctxCtrl to the current CtxCtrl */
    (void)memcpy(gAppSdContext.pCurCtxCtrl, pCtxCtrl, sizeof(*gAppSdContext.pCurCtxCtrl));
}

void _APP_SD_vCtxHistoryReplaceIndex(AppSdCtxCtrlType *pCtxCtrl, Uint16Type pos)
{
    // check if pCtxCtrl has a valid ctx Id
    if( APP_SD_CONTEXT_INVALID >= pCtxCtrl->common.ctxId ||
        APP_SD_CONTEXT_LAST <= pCtxCtrl->common.ctxId )
    {

        DEBUG_STATE1( APP_SD_SWI_ERR, MOD_APP_SD, "HistReplIdx: new ctxId invalid $APP_SD_enContextId$ =(%d)",
                            pCtxCtrl->common.ctxId);
        return;
    }

    if( pos >= APP_SD_MAX_CTX_DEPTH )
    {

        DEBUG_VALUE1(APP_SD_SWI_ERR, MOD_APP_SD, "HistReplIdx: new pos invalid (%d)",
                            pos);
        return;
    }



    DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "HistReplIdx: repl. pos %d ... ",
                        pos);
    DEBUG_STATE2(APP_SD_SWI_TRC, MOD_APP_SD, "HistReplIdx: repl. ... with ctxId $APP_SD_enContextId$ = %d, new ctxId $APP_SD_enContextId$ =%d",
                        gAppSdContext.ctxHistory[pos].common.ctxId,
                        pCtxCtrl->common.ctxId);

    if(pos < APP_SD_MAX_CTX_DEPTH)
    {
        gAppSdContext.curCtxCtrlId = pos;
        gAppSdContext.pCurCtxCtrl = &gAppSdContext.ctxHistory[gAppSdContext.curCtxCtrlId];

        (void)memset(gAppSdContext.pCurCtxCtrl, 0, sizeof(*(gAppSdContext.pCurCtxCtrl)));

        /* save the pending ctxCtrl to the current CtxCtrl */
        (void)memcpy(gAppSdContext.pCurCtxCtrl, pCtxCtrl, sizeof(*gAppSdContext.pCurCtxCtrl));
    }
}

void _APP_SD_vCtxHistoryStepBack()
{
    Uint16Type pbSize;

    if( NULL != gAppSdContext.pCurCtxCtrl )
    {

        DEBUG_STATE1(APP_SD_SWI_TRC, MOD_APP_SD, "CtxStepBack: ctx $APP_SD_enContextId$ = %d",
                            gAppSdContext.pCurCtxCtrl->common.ctxId)

        DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "CtxStepBack: at pos %d",
                            gAppSdContext.curCtxCtrlId);
    }


    if( gAppSdContext.curCtxCtrlId > 0 )
    {
        APP_SD_enContextId ctxId = gAppSdContext.pCurCtxCtrl->common.ctxId;

        (void)memset(gAppSdContext.pCurCtxCtrl, 0, sizeof(*(gAppSdContext.pCurCtxCtrl)));

        gAppSdContext.curCtxCtrlId--;
        gAppSdContext.pCurCtxCtrl = &gAppSdContext.ctxHistory[gAppSdContext.curCtxCtrlId];

        (void)memset(gAppSdContext.pCurCtxCtrl->common.pFrameData, 0, sizeof(*gAppSdContext.pCurCtxCtrl->common.pFrameData));

        gAppSdContext.pCurCtxCtrl->common.pFrameData->common.ctxId
                = gAppSdContext.pCurCtxCtrl->common.ctxId;

        if( gAppSdContext.pCurCtxCtrl->common.timeout > 0 )
        {
            (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_APP_SD_FRAME_TIMEOUT,
                                               MSEC(gAppSdContext.pCurCtxCtrl->common.timeout),
                                               0);
        }


        DEBUG_STATE2(APP_SD_SWI_TRC, MOD_APP_SD, "CtxStepBack: ctx $APP_SD_enContextId$ = %d to $APP_SD_enContextId$ = %d",
                            ctxId, gAppSdContext.pCurCtxCtrl->common.ctxId );

        switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
        {
            case APP_SD_CONTEXT_INVALID:

                DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "CtxStepBack: invalid -> def screen");
                _APP_SD_vInitIdleScreen(0);
                break;
            case APP_SD_CONTEXT_S002:
                /* special handling for step back to S002, because it can happen that
                   we step back but an active user is available */
                if( NULL != ERM_pGetActiveUserProfile())
                {

                    DEBUG_TEXT(APP_SD_SWI_WNG, MOD_APP_SD, "CtxStepBack: S002 but user active");
                    _APP_SD_vInitIdleScreen(0);
                }
                else
                {
                    _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                }
                break;
            /* check if we have a frame that depends on the call state */
            case APP_SD_CONTEXT_S801:
            case APP_SD_CONTEXT_S803:
            case APP_SD_CONTEXT_S804:
            case APP_SD_CONTEXT_S811:
            case APP_SD_CONTEXT_S812:
            case APP_SD_CONTEXT_S813:
            case APP_SD_CONTEXT_S901:
            case APP_SD_CONTEXT_S902:
            case APP_SD_CONTEXT_SC20:
            case APP_SD_CONTEXT_S941:
            case APP_SD_CONTEXT_S942:
            case APP_SD_CONTEXT_S945:

                DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "CtxStepBack: call state update (ctx %d)",
                              gAppSdContext.pCurCtxCtrl->common.ctxId );
                /* the call state might be changed, so check the actual state */
                _APP_SD_vHandleCallStateChanged();
                break;
            case APP_SD_CONTEXT_S924:
            case APP_SD_CONTEXT_S929:         // RT #1491
            case APP_SD_CONTEXT_SC14:
                if(VCR_bCheckSIVRIsActive() == BT_FALSE)
                {
                    _APP_SD_vInitIdleScreen(0);
                }
                else        // RT #3779
                {
                    _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                }
                break;
            case APP_SD_CONTEXT_S102:       // RT #3956
                if(AT_PB_LOADING == APP_PHONEBOOK_enGetPBDwldState())
                {
                    _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                }
                else
                {
                    /* PHONEBOOK */
                    pbSize = APP_PHONEBOOK_u16GetCurrentPBSize(APP_PHONEBOOK_enUsersPB);
                    if(pbSize > 0)
                    {
                      /* show phonebook entries */
                      _APP_SD_vInitFrameS104(pbSize);
                    }
                    else
                    {
                      /* no entries available */
                      _APP_SD_vInitFrameS103();
                    }
                }
                break;
            /* start fix for ticket #4441 */
            /* if a connecting frame like S001 or S517 was overlayed by a popup or VCR frame
               we need to check if the device already connected in background when we step back
               in history to S001 or S517 */
            case APP_SD_CONTEXT_S001:
                /* need to check if user has been connected already in the background,
                   when this context was e.g. overlayed by a popup */
                if(ERM_u8GetActivePhone() != AT_INVALID_DEVICE_ID)
                {
                    /* a user is already connected */
                    /* maybe we need to connect the player or create a profile */
                    _APP_SD_vHandlePhoneStateChanged();
                }
                else
                {   /* show frame again to wait for connection or timeout */
                    _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                }
                break;
            case APP_SD_CONTEXT_SC12:
                if(AT_INVALID_DEVICE_ID != ERM_u8GetActivePlayer())
                {   /* player already connected in background */
                    _APP_SD_vHandlePlayerStateChanged();
                }
                else
                {   /* not yet connected. wait for timeout or connection */
                    _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                }
                break;
            case APP_SD_CONTEXT_S517:
                /* need to check if the requested device has been connected already in the background,
                   when this context was e.g. overlayed by a popup */
                switch(gAppSdContext.pCurCtxCtrl->s517.deviceType)
                {
                    case APP_DEVICE_enTYPE_PHONE:
                        if(ERM_u8GetActivePhone() != AT_INVALID_DEVICE_ID)
                        {
                            /* a user is already connected */
                            /* maybe we need to connect the player or create a new user profile */
                            _APP_SD_vHandlePhoneStateChanged();
                        }
                        else
                        {   /* show frame again to wait for connection or timeout */
                            _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                        }
                        break;
                    case APP_DEVICE_enTYPE_PLAYER:
                        if(AT_INVALID_DEVICE_ID != ERM_u8GetActivePlayer())
                        {   /* player already connected in background */
                            _APP_SD_vHandlePlayerStateChanged();
                        }
                        else
                        {   /* not yet connected. wait for timeout or connection */
                            _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                        }
                        break;
                    case APP_DEVICE_enTYPE_HEADSET:
                        if(AT_INVALID_DEVICE_ID != ERM_u8GetActiveHeadSet())
                        {   /* player already connected in background */
                            _APP_SD_vHandleHeadsetStateChanged();
                        }
                        else
                        {   /* not yet connected. wait for timeout or connection */
                            _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                        }
                        break;
                    default:
                        _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                        break;
                }
                break;
            /* end fix for ticket #4441 */

            /* RT12983 */
            case APP_SD_CONTEXT_S663_PB:
                if (BT_TRUE == gAppSdContext.bPbUpdateComplete)
                {
                    /* PPBC:0 is already received in the back ground, so step back to previous context */
                    DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "12983: CtxStepBack: Screen S663_PB: PPBC:0 is already received");
                    gAppSdContext.bPbUpdateComplete = BT_FALSE;
                    _APP_SD_vCtxHistoryStepBack();
                }
                else
                {
                    /* PPBC:0 is not yet received in the back ground, so wait in the same context S663_PB and if it */
                    /* is not received time out in this screen will occur */
                    DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "12983: CtxStepBack: Screen S663_PB: PPBC:0 is not yet received");
                    _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                }
                break;
            default:
                _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                break;
        }
    }
    else
    {

        DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "CtxStepBack: empty -> def screen");
        _APP_SD_vInitIdleScreen(0);
    }
}

Sint16Type _APP_SD_s16GetHistoryIndex(APP_SD_enContextId ctxId)
{
    Sint16Type i = 0;

    //for( i=0; i<APP_SD_MAX_CTX_DEPTH; i++)
    for( i=0; i<=gAppSdContext.curCtxCtrlId; i++)
    {
        if(gAppSdContext.ctxHistory[i].common.ctxId == ctxId)
        {
            return i;
        }
    }

    return -1;
}

AppSdCtxCtrlType *_APP_SD_pGetHistoryContext(APP_SD_enContextId ctxId)
{
    Sint16Type i = _APP_SD_s16GetHistoryIndex(ctxId);

    if(i > -1 && i < APP_SD_MAX_CTX_DEPTH)
    {
        return &gAppSdContext.ctxHistory[i];
    }

    return NULL;
}

void _APP_SD_vRefreshFrame(AppSdCtxCtrlType *pCtxCtrl)
{
    if(pCtxCtrl->common.ctxId != APP_SD_CONTEXT_INVALID)
    {
        pCtxCtrl->common.state        = APP_SD_CTX_FRAME_REQ_SUB_STATE_DATA;
        pCtxCtrl->common.pendingType  = APP_SD_PENDING_INIT;

        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                            MSEC(0),
                                            0);
    }
}

void _APP_SD_vInitIdleScreen(Uint8Type focusedElement)
{
    APP_MDI_bUnmutePlayer(APP_MDI_MUTE_DEVICE_CONNECT, UNMUTE_IMMEDIATELY);

//    if((gAppSdContext.lastConnectionDevice.playerState == APP_SD_MDI_PLAY)&& \
//       (APP_MDI_GetPlayStatus() != APP_MDI_ACT_STATE_PLAY))
//    {
//        APP_MDI_sfSetPlayMode(APP_MDI_RESUME);
//    }
//    gAppSdContext.lastConnectionDevice.playerState = APP_SD_MDI_STOP;

    ERM_vSetDisconnectWillFollow(BT_FALSE);
    gAppSdContext.disconnectPlayerWillFollow = BT_FALSE;
    gAppSdContext.searchStartedFromScreen = APP_SD_CONTEXT_INVALID;
    if(VCR_bCheckSIVRIsActive() == BT_FALSE)        //RT: #4001
    {
        if( NULL != ERM_pGetActiveUserProfile())
        {
            //  check that we didn't miss a call indication during connect
            if( (BT_FALSE == APP_PHONE_AT_PNCC_bAllCallStatesIdle()) && (BT_TRUE == _APP_SD_bIsKl15On()))
            {
                _APP_SD_vHandleCallStateChanged();
            }
            else
            {   // no call present, show idle screen
                _APP_SD_vInitFrameS_18();
            }
        }
        else
        {
            _APP_SD_vInitFrameS002(focusedElement);
        }
    }
    else
    { // SIVR active reactivate SIVR active screen
        _APP_SD_vInitFrameS924();
    }
}

void APP_SD_vFrameDataTransfered(BooleanType bSuccess)
{
    if(bSuccess == BT_TRUE)
    {
        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                            MSEC(0),
                                            0);
    }
    else
    {

        DEBUG_VALUE1(APP_SD_SWI_ERR, MOD_APP_SD, "vFrameDataTransfered: error (Cur ctxId: %d)",
                        gAppSdContext.pCurCtxCtrl->common.ctxId);


        /* go back to one of the main screens */
        /* but do this only when KL15 on, when kl15 off don't show idle screen */
        if (BT_TRUE == _APP_SD_bIsKl15On() )
        {
            _APP_SD_vInitIdleScreen(0);
        }
    }
}


void APP_SD_vOnAppCanLangNotification(APP_CAN_LanguageType sdLangEvent)
{
    AppSdEventCtxType event;
//    if(BT_TRUE == KPB_bIsAsgPresentation())
//    {
//      _APP_SD_vActivateFrame(BT_TRUE, __LINE__);

//    }
    event.common.type = APP_SD_EVENT_CAN_LANG;
    event.canLang.newCanLang = sdLangEvent.sd_language;
    _APP_SD_vEventManager(&event);
}

void APP_SD_vOnAppCanSpeedNotification(SPEED_enSpeed sdSpeedEvent)
{
    AppSdEventCtxType event;
    event.common.type = APP_SD_EVENT_CAN_SPEED;
    event.canSpeed.notId = sdSpeedEvent;
    _APP_SD_vEventManager(&event);
}


/*----------------------------------------------------------------------------*/
/* Function :   APP_SD_vOnAppPhoneNotification                                */
/**
  \brief        Is called to notify about a APP_PHONE event

  \param        notification
                APP_PHONE notification

  \return       void

 */
/*----------------------------------------------------------------------------*/
void APP_SD_vOnAppPhoneNotification(APP_PHONE_enNotificationId notification)
{
    DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "vOnAPHNot: $APP_PHONE_enNotificationId$ = %d",
                                        notification)
    switch( notification )
    {
        case APP_PHONE_OPERATOR_NAME_CHANGED:
        case APP_PHONE_NW_SIGSTRENGHT_CHANGED:
        case APP_PHONE_ROAMING_CHANGED:
        case APP_PHONE_SERV_AVAIL_CHANGED:
        case APP_PHONE_BATT_LEVEL_CHANGED:
        case APP_PHONE_HFP_VERSION_CHANGED:
            /* reduce the event load */
            if( ( (gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_SP18) ||
                (gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_S018)) && (BT_TRUE == _APP_SD_bIsKl15On())) //don't update idle screen when kl15 off
            {
                AppSdEventCtxType event;
                event.common.type = APP_SD_EVENT_PHONE;
                event.phone.notId = notification;
                _APP_SD_vEventManager(&event);
            }
            else
            {

                DEBUG_VALUE2( APP_SD_SWI_TRC, MOD_APP_SD, "vOnAPHNot: ignored %d in ctx %d",
                                    notification,
                                    gAppSdContext.pCurCtxCtrl->common.ctxId);
            }
            break;
        case APP_PHONE_CALL_STATE_CHANGED:      /* PLCC */
        case APP_PHONE_MIC_MUTE_CHANGED:
        case APP_PHONE_HANDSFREE_MODE_CHANGED:
        case APP_PHONE_HEADSET_MODE_CHANGED:
        case APP_PHONE_OUTG_CALL_INDICATION_TIMEOUT:
        case APP_PHONE_OUTG_CALL_ERROR:
        case APP_PHONE_REDIAL_DENIED_DUE_TO_EMPTY_STACK:
        {
            AppSdEventCtxType event;
            event.common.type = APP_SD_EVENT_PHONE;
            event.phone.notId = notification;
            _APP_SD_vEventManager(&event);
            break;
        }
        default:

            DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "vOnAPHNot: ignored %d",
                         notification);
            return;
    }
}

/*----------------------------------------------------------------------------*/
/* Function :   APP_SD_vOnAppCshdlNotification                                */
/**
  \brief        Is called to notify about a APP_CSHDL event

  \param        notification
                APP_CSHDL notification

  \return       void

 */
/*----------------------------------------------------------------------------*/
void APP_SD_vOnAppCshdlNotification(APP_CSHDL_NotificationType notification)
{
//    if(BT_TRUE == KPB_bIsAsgPresentation())
//    {
//      _APP_SD_vActivateFrame(BT_TRUE, __LINE__);
//    }


    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "AppCshdlNot: rcvd noti %d",
                        notification);


    switch(notification)
    {
        case APP_CSHDL_NOTIFY_CRADLE_RESTRICTION_ON:
        case APP_CSHDL_NOTIFY_CRADLE_RESTRICTION_OFF:
        case APP_CSHDL_NOTIFY_KL_15_OFF:
        case APP_CSHDL_NOTIFY_UHV_ACTIVE_KL_15_OFF:
        case APP_CSHDL_NOTIFY_UHV_ACTIVE_KL_15_ON:
        {
            AppSdEventCtxType event;
            event.common.type       = APP_SD_EVENT_CSHDL;
            event.cshdl.notId       = notification;
            _APP_SD_vEventManager(&event);
            break;
        }
        case APP_CSHDL_NOTIFY_PREPARE_CK5050_SHUTDOWN:
            APP_CSHDL_vCk5050ShutDownHandled(APP_CSHDL_APP_SD);
            break;
        default:
            DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "vOnACSHDLNot: ignor %d ",
                         notification);
            break;
    }
}

/*----------------------------------------------------------------------------*/
/* Function :   APP_SD_vOnAppPhoneBookNotification                            */
/**
  \brief        Is called to notify about a APP_PHONEBOOK event

  \param        notification
                PHONEBOOK notification

  \return       void

 */
/*----------------------------------------------------------------------------*/
void APP_SD_vOnAppPhoneBookNotification(APP_PB_enNotificationId notification)
{
    DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "vOnAppPhoneBookNotif: rcvd notification $APP_PB_enNotificationId$ = %d",
                        notification);

    switch( notification )
    {
//        case APP_PB_MISSED_PB_CHANGED:        // bugfix for RT #1599
//        {
//            AppSdEventCtxType event;
//            activate = BT_TRUE;
//            event.common.type = APP_SD_EVENT_PHONEBOOK;
//            event.phonebook.notId = notification;
//            _APP_SD_vEventManager(&event);
//            break;
//        }
        // *******************************
        // Susanne: 07.08.09 Now handled again
        case APP_PB_MISSED_PB_CHANGED:
        case APP_PB_MISSED_PB_NOT_CHANGED:
            if (VCR_bCheckSIVRIsActive())
            {
                DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "vOnAppPhoneBookNotif: ign notification $APP_PB_enNotificationId$ = %d",
                                    notification);
                break;
            }
        case APP_PB_MISSED_CALLS_RESET_BY_HMI:
        // *******************************
        case APP_PB_RECEIVED_PB_CHANGED:          //RT #4184
        case APP_PB_DIALED_PB_CHANGED:
        case APP_PB_USER_PB_READ_FINISHED:
        case APP_PB_USERS_PB_CHANGED:
        case APP_PB_USERS_PB_CHANGED_INCOMPLETE:
        case APP_PB_USERS_PB_NOT_CHANGED:
        case APP_PB_USERS_PB_NOT_CHANGED_INCOMPLETE:
        case APP_PB_USERS_PB_NOT_AVAILABLE:
        case APP_PB_DOWNLOAD_COUNT_CHANGED:      /* PPDS */
        case APP_PB_USER_PB_UPDATE_FINISHED:     /* PPBC 0 */
        case APP_PB_SORTING_TIMED_OUT:
        {

            AppSdEventCtxType event;
            event.common.type = APP_SD_EVENT_PHONEBOOK;
            event.phonebook.notId = notification;
            _APP_SD_vEventManager(&event);
            break;
        }

        default:

            DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "vOnAPBNot: ignor %d",
                            notification);
            return;
    }
}

/*----------------------------------------------------------------------------*/
/* Function :   APP_SD_vOnAppSmsNotification                                  */
/**
  \brief        Is called to notify about a SMS event

  \param        notification
                SMS notification

  \return       void

 */
/*----------------------------------------------------------------------------*/
void APP_SD_vOnAppSmsNotification(APP_SMS_enNotificationId notification)
{
    DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "vOnAppSmsNotif: rcvd notification $APP_SMS_enNotificationId$ = %d",
                            notification);

    // check if sms is supported. If not, ignore all the events
    if( APP_SMS_INITIALIZED_AND_SUPPORTED != APP_SMS_enGetSmsSupportState())
    {

        DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "OnSmsNot: Ign. Ev. due Sms not supp.");
    }


    switch( notification )
    {
        case APP_SMS_SUPPORTED:
        case APP_SMS_UNSUPPORTED:
        case APP_SMS_NEW_SMS:
        case APP_SMS_NUMBER_OF_NEW_SMS_CHANGED:
        case APP_SMS_DELETED_SMS:
#ifdef UHV_ACTIVATE_FEATURE_SMS
        {
            AppSdEventCtxType event;
            event.common.type = APP_SD_EVENT_SMS;
            event.sms.notId = notification;
            _APP_SD_vEventManager(&event);
            break;
        }
#endif
        //case APP_SMS_ ... download progress of pb
        default:

            DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "vOnASmsNot: ignored %d",
                            notification);
            return;
    }
}


/*----------------------------------------------------------------------------*/
/* Function    : APP_SD_ERM_vHandleErmStateChange                             */
/**
    \brief      handle State change of ERM to Update e.g. FSG OperationState

    \param      newState
                The new state

    \return     void
*/
/*----------------------------------------------------------------------------*/
//void APP_SD_ERM_vHandleErmStateChange(ERMStateType newState)
//{
//    switch( newState )
//    {
//        case ERM_STATE_CK5050_BT_ACTIVE:
//        case ERM_STATE_CK5050_ACTIVE:
//        case ERM_STATE_START_UP:
//        case ERM_STATE_WAIT_ADDRESS:
//        case ERM_STATE_IDLE:
//        default:
//            /* state not handled */
//            break;
//    }
//}/* END OF APP_SD_vHandleErmStateChange() */

/*----------------------------------------------------------------------------*/
/* Function :   APP_SD_vOnErmNotification                                     */
/**
  \brief        Is called to notify about a ERM event

  \param        notification
                ERM notification

  \return       void

 */
/*----------------------------------------------------------------------------*/
void APP_SD_vOnErmNotification(const ERMNotificationType * pNotification)
{
    DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "vOnErmNotif: rcvd notification $ERMNotificationType$ = %d",
                                    pNotification->common.id);

    switch( pNotification->common.id )
    {
        //case ERM_NOTIFY_PHONE_ACTIVE_STATE_CHANGED:
        case ERM_NOTIFY_PBSN_PHONE:
            /* Phone was still activated in current session */
            _APP_SD_phoneActivatedOnce = BT_TRUE;

        case ERM_NOTIFY_BT_VISIBILITY_ON:
        case ERM_NOTIFY_BT_VISIBILITY_OFF:
        case ERM_NOTIFY_INQUIRY_END:
        case ERM_NOTIFY_DELETED_DEVICE:
        //case ERM_NOTIFY_CONNECT_FAILED:
        case ERM_NOTIFY_PSBD:

        //case ERM_NOTIFY_PAIRING_SUCCEEDED:
        //case ERM_NOTIFY_PAIRING_MAX_DEVICES_REACHED:
        //case ERM_NOTIFY_PAIRING_FAILED:
        case ERM_NOTIFY_PPRS:

        case ERM_NOTIFY_SERVICE_SUPPORT_CHANGED:
        case ERM_NOTIFY_MAILBOX_NUMBER_CHANGED:
        //case ERM_NOTIFY_PLAYER_ACTIVE_STATE_CHANGED:
        case ERM_NOTIFY_PBSN_A2DP:
        case ERM_NOTIFY_PBSN_AVRCP:
        //case ERM_NOTIFY_HEADSET_ACTIVE_STATE_CHANGED:
        case ERM_NOTIFY_STARTUP_DONE:
        case ERM_NOTIFY_WARN_DIAL_ERROR:
        case ERM_NOTIFY_WARN_HANGUP_ERROR:
        case ERM_NOTIFY_WARN_PICKUP_ERROR:
        case ERM_NOTIFY_WARN_2ND_CALL_ERROR:
        case ERM_NOTIFY_WARN_DTMF_ERROR:
        case ERM_NOTIFY_WARN_AVRCP_ERROR:
        case ERM_NOTIFY_PPRQ:
        case ERM_NOTIFY_PSPR:
        case ERM_NOTIFY_PBSF:
        {
            AppSdEventCtxType event;
//            activate = BT_TRUE;
//            _APP_SD_vActivateFrame(BT_TRUE, __LINE__);
            event.common.type = APP_SD_EVENT_ERM;
            event.erm.notId = *pNotification;
            _APP_SD_vEventManager(&event);
            break;
        }
        default:

            DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "vOnErmNot: ignored %d",
                            pNotification->common.id);
            return;
    }
}

/*----------------------------------------------------------------------------*/
/* Function :   APP_SD_vOnVcrNotification                                     */
/**
  \brief        Is called to notify about a VCR event

  \param        notification
                VCR notification

  \return       void

 */
/*----------------------------------------------------------------------------*/
void APP_SD_vOnVcrNotification(VCRNotificationIdEnum notification)
{
    AppSdEventCtxType event;

    DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "vOnVcrNotif: rcvd notification $VCRNotificationIdEnum$ = %d",
                                    notification);


    event.common.type = APP_SD_EVENT_VCR;

//    activate = BT_TRUE;
//    _APP_SD_vActivateFrame(BT_TRUE, __LINE__);

    switch( notification )
    {
        case VCR_NOTIFY_CONTACT_AMBIGUOUS:
        {
            Uint16Type i = 0;
            const VCRResultContactAmbType *pContactAmb = VCR_stGetContactAmb();
            event.vcr.notId = notification;
            event.vcr.data.contactAmb.num_ids = pContactAmb->num_ids;
            for(i=0; i<event.vcr.data.contactAmb.num_ids; i++)
            {
                event.vcr.data.contactAmb.item_id[i] = pContactAmb->item_id[i];
            }
            break;
        }
        case VCR_NOTIFY_MULTIPLE_NUMBERS:
        {
            const VCRResultContactUniType *pContactUni = VCR_stGetContactUni();
            event.vcr.notId = notification;
            event.vcr.data.contactUni.pbIdx = pContactUni->item_id;
            break;
        }
        case VCR_NOTIFY_SIVR_ACTIVATE:
        case VCR_NOTIFY_SIVR_DEACTIVATE:
        case VCR_NOTIFY_NOT_READY:
        case VCR_NOTIFY_DIAL_NUMBER_CHANGED:
        case VCR_NOTIFY_DIAL_NUMBER_DELETE:
        {
            event.vcr.notId = notification;
            break;
        }
        default:

            DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "vOnVcrNot: ignored %d",
                            notification);
            return;
    }

    _APP_SD_vEventManager(&event);

}


/*----------------------------------------------------------------------------*/
/* Function :   APP_SD_vOnAppDeviceNotification                               */
/**
  \brief        Is called to notify about a APP_DEVICE event

  \param        notification
                APP_Device notification

  \return       void

 */
/*----------------------------------------------------------------------------*/
void APP_SD_vOnAppDeviceNotification(APP_DEVICE_enNotificationId notification)
{
    DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "vOnAppDeviceNotif: rcvd notification $APP_DEVICE_enNotificationId$ = %d",
                                    notification);

    switch( notification )
    {
        case APP_DEVICE_NOTIFY_ALL_USER_PROFILE_DELETED:
        case APP_DEVICE_NOTIFY_FACTORY_SETTING_RESET:
        case APP_DEVICE_NOTIFY_MAILBOX_NUMBER_CHANGED:
        {
            AppSdEventCtxType event;
//            if(BT_TRUE == KPB_bIsAsgPresentation())
//            {
//                _APP_SD_vActivateFrame(BT_TRUE, __LINE__);
//            }
            event.common.type = APP_SD_EVENT_DEVICE;
            event.device.notId = notification;
            _APP_SD_vEventManager(&event);
            break;
        }
        case APP_DEVICE_NOTIFY_OUTGOING_CALL_VIA_VCR:
            gAppSdContext.outgoingCallViaVcrInProgress = BT_TRUE;
        default:

            DEBUG_VALUE1(   APP_SD_SWI_TRC, MOD_APP_SD, "vOnADevNot: ignored %d",
                            notification);
            return;
    }
}

/*----------------------------------------------------------------------------*/
/* Function :   APP_SD_vOnKpbNotification                                     */
/**
  \brief        Is called to notify about a KPB event

  \param        notification
                KPB notification

  \return       void

 */
/*----------------------------------------------------------------------------*/
void APP_SD_vOnKpbNotification(KPB_enNotificationId notification)
{
    DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "vOnKpbNotif: rcvd notification $KPB_enNotificationId$ = %d",
                                        notification);

    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "vOnKPBNot: %d", notification);

    switch( notification )
    {
        case KPB_NOTIFY_VISIBLE_ON:
              // removed for ticket 3201 if two statis was requested during the same cycle
//            /* reduce the event load */
//            if(gAppSdContext.activate == BT_FALSE)
//            {
//                AppSdEventCtxType event;
//                event.common.type = APP_SD_EVENT_KPB;
//                event.kpb.notId = notification;
//                _APP_SD_vEventManager(&event);
//            }
//            break;
        case KPB_NOTIFY_VISIBLE_OFF:
//            /* reduce the event load */
//            if(gAppSdContext.activate == BT_TRUE)
//            {
//                AppSdEventCtxType event;
//                event.common.type = APP_SD_EVENT_KPB;
//                event.kpb.notId = notification;
//                _APP_SD_vEventManager(&event);
//            }
//            break;
        case KPB_NOTIFY_ASG_AVAILABLE:
        case KPB_NOTIFY_ASG_INIT_DONE:
        case KPB_NOTIFY_ASG_INIT_DONE_ACTIVE:
        case KPB_NOTIFY_BUSOFF_END:
        {
            AppSdEventCtxType event;
            event.common.type = APP_SD_EVENT_KPB;
            event.kpb.notId = notification;
            _APP_SD_vEventManager(&event);
            break;
        }
        default:

            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "vOnKPBNot: ignored %d",
                                notification);
            return;
    }
}


/*----------------------------------------------------------------------------*/
/* Function :   APP_SD_vOnMflButton                                           */
/**
  \brief        Is called to notify about a button press

  \param        key
                Identifier to specify the key

  \param        pressType
                Specifies the kind of button press (short, long, ...)

  \return       void

 */
/*----------------------------------------------------------------------------*/
void APP_SD_vOnMflButton(LOGI_BUT_MAN_ENUM_BUTTON_NAMES key, LOGI_BUT_MAN_ENUM_PRESSTYPE pressType)
{
    if(KPB_enGetAsgState() != KPB_ASG_STATUS_ALIVE)
    {

        DEBUG_VALUE2( APP_SD_SWI_WNG, MOD_APP_SD,
                            "vOnMflBtn: ASG not alive: %d, drop key %d",
                            KPB_enGetAsgState(), key);
        return;
    }


    if(KPB_bIsKeyAssigned(key) == BT_FALSE)
    {
        if(((key == enLogiButManMflHook) ||
           (key == enLogiButManVirtualButtonInfo) ||
           (key == enLogiButManVirtualButtonService) ||
           (key == enLogiButManVirtualButtonSos)) &&
           (KPB_bIsAsgPresentation() != BT_TRUE))
        {
            AppSdEventCtxType event;
            /* special handling for the HOOK / SOS / Info / Service button */

            DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "vOnMflBtn: $LOGI_BUT_MAN_ENUM_BUTTON_NAMES$ = %d, special handling",
                                key);

            event.common.type   = APP_SD_EVENT_BUTTON;
            event.btn.id        = key;
            event.btn.pressType = pressType;

            _APP_SD_vEventManager(&event);

        }
        else
        {

            DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "vOnMflBtn: key %d not assigned",
                                key);
        }
    }
    else
    {
        switch(key)
        {
            case enLogiButManLssUp:
            case enLogiButManLssDown:
            case enLogiButManLssOk:
            case enLogiButManMflHook:
            case enLogiButManMflBack:
            case enLogiButManMflUp:
            case enLogiButManMflDown:
            case enLogiButManVirtualButtonInfo: /* Info-Ruf */
            case enLogiButManVirtualButtonService: /* Pannen-Ruf */
            case enLogiButManVirtualButtonSos: /*SOS-Ruf */
            {
                AppSdEventCtxType event;
                event.common.type   = APP_SD_EVENT_BUTTON;
                event.btn.id        = key;
                event.btn.pressType = pressType;

                _APP_SD_vEventManager(&event);


                DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "vOnMflBtn: keyEvent $LOGI_BUT_MAN_ENUM_BUTTON_NAMES$ = %d",
                                    key);

                break;
            }
            case enLogiButManMflOk:
            {
                if( ( (pressType == enLogiButManLongPress ) && ( APP_CAN_SK_Skoda == APP_CAN_enGetMarke()) &&
                      (APP_SD_CONTEXT_S104 == gAppSdContext.pCurCtxCtrl->common.ctxId) ) ||
                    (pressType == enLogiButManShortPress) ||
                    (pressType == enLogiButManShortPressAtSingleFunction))
                {
                    AppSdEventCtxType event;
                    event.common.type   = APP_SD_EVENT_BUTTON;
                    event.btn.id        = key;
                    event.btn.pressType = pressType;

                    _APP_SD_vEventManager(&event);


                    DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "vOnMflBtn: keyEvent $LOGI_BUT_MAN_ENUM_BUTTON_NAMES$ = %d",
                                        key);
                }
                else
                {

                    DEBUG_STATE1( APP_SD_SWI_TRC, MOD_APP_SD, "vOnMflBtn: ButManMflOk pressType $LOGI_BUT_MAN_ENUM_PRESSTYPE$ = %d ignored",
                                        pressType);
                }
                break;
            }
            default:

                DEBUG_STATE1(APP_SD_SWI_TRC, MOD_APP_SD, "vOnMflBtn: unsup keyEvent $LOGI_BUT_MAN_ENUM_BUTTON_NAMES$ = %d",
                                    key);
                break;
        }
    }
}

/*----------------------------------------------------------------------------*/
/* Function :   APP_SD_cbFrameTimeout                                         */
/**
  \brief        Callback that is invoked after the frame timeout expired

  \return       void

 */
/*----------------------------------------------------------------------------*/
ALARMCALLBACK(APP_SD_cbFrameTimeout)
{
    gAppSdContext.ctxTimedOut = gAppSdContext.pCurCtxCtrl->common.ctxId;

    (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                        MSEC(0),
                                        0);

}


void _APP_SD_AddUserProfile_Cb(APP_COMMON_enResponseCode result)
{

//#ifdef APP_SD_EEPROM_TEST
//    _APP_SD_vInitFrameS535(gAppSdContext.pCurCtxCtrl->s534.deviceId);
//    return;
//#endif

    if(APP_COMMON_RSP_OK == result)
    {
        // user Profile was successfully added / written to EEPROM
        // now add player profile or leave S534
        // is it possible that we have been interrupted with another context? I assume
        // not since we stay in HandleInitFrame until we are finished ...
        if( gAppSdContext.pCurCtxCtrl->common.ctxId  == APP_SD_CONTEXT_S534 &&
            gAppSdContext.pCurCtxCtrl->s534.subState == APP_SD_S534_ADD_NEW_PROFILE_SENT )
        {
            // check if phone also supports player service ( a2dp )
            if( BT_TRUE == ERM_bIsPlayer(gAppSdContext.pCurCtxCtrl->s534.deviceId) &&
                NULL == ERM_pGetPlayerHeadsetProfile_DevId(gAppSdContext.pCurCtxCtrl->s534.deviceId) )
            {
                /* add player profile */
                gAppSdContext.pCurCtxCtrl->s534.subState = APP_SD_S534_ADD_PLAYER_PROFILE_NOT_SENT;

                _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
            }
            else
            {
                //RS: replaced with InitIdleScreen to check for active VCR or active call
                _APP_SD_vInitIdleScreen(0);
            }
        }
        else
        {
            DEBUG_VALUE2(APP_SD_SWI_ERR, MOD_APP_SD, "AddUserProfile_Cb: CTX error (%d, %d)",
                                                     gAppSdContext.pCurCtxCtrl->common.ctxId,
                                                     gAppSdContext.pCurCtxCtrl->s534.subState);
    	    if( ERM_u8GetActivePhone() != AT_INVALID_DEVICE_ID )
    	    {
    	    	APP_DEVICE_vAddMissingUserProfileImplicitlyBySD();
    	    }
            //RS: replaced with InitIdleScreen to check for active VCR or active call
            _APP_SD_vInitIdleScreen(0);
        }
    }
    else
    {
    	//to avoid screen freeze initialize idle screen and create profile if necessary
    	if( ERM_u8GetActivePhone() != AT_INVALID_DEVICE_ID )
    	{
    		APP_DEVICE_vAddMissingUserProfileImplicitlyBySD();
    	}
    	_APP_SD_vInitIdleScreen(0);

        DEBUG_VALUE1(APP_SD_SWI_ERR, MOD_APP_SD, "AddUserProf_Cb error %d", result);
    }
}

void _APP_SD_AddHeadsetProfile_Cb(APP_COMMON_enResponseCode result)
{
    if(APP_COMMON_RSP_OK == result)
    {
        _APP_SD_vInitFrameS533();
    }
    else
    {

        DEBUG_VALUE1(APP_SD_SWI_ERR, MOD_APP_SD, "AddHeadsetProf_Cb error %d",
                        result);
    }
}


void _APP_SD_HandlePendingButtonS542_Cb(APP_COMMON_enResponseCode result)
{

    if(APP_COMMON_RSP_OK == result)
    {
        AppSdCtxCtrlType *pCtxCtrl = _APP_SD_pGetHistoryContext(APP_SD_CONTEXT_S542);

        if (AT_INVALID_DEVICE_ID != ERM_u8GetActivePlayer() &&
            pCtxCtrl &&
            pCtxCtrl->s542.subStateBtn == APP_SD_S542_DISCONNECT_PLAYER_STILL_TO_BE_SEND)
        {
            pCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;

            DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "_APP_SD_HandlePendingButtonS542_Cb disconnect player with ID: %d",
                        ERM_u8GetActivePlayer());


            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0),
                                                            0);
        }
    }
    else
    {

        DEBUG_VALUE1(APP_SD_SWI_ERR, MOD_APP_SD, "_APP_SD_HandlePendingButtonS542_bB %d",
                        result);
    }
}

void _APP_SD_AddPlayerProfile_Cb(APP_COMMON_enResponseCode result)
{
    Uint8Type profileId         = AT_INVALID_DEVICE_ID;

    AppSdCtxCtrlType *pCtxCtrl = _APP_SD_pGetHistoryContext(APP_SD_CONTEXT_S534);

    profileId = APP_DEVICE_u8GetAddedProfileId(APP_DEVICE_enTYPE_PLAYER);

    //Uint8Type playerProfile = pUser->playerIndex;

    if( pCtxCtrl && pCtxCtrl->s534.subState == APP_SD_S534_ADD_PLAYER_PROFILE_SENT )
    {
        /* set always a flag that we are finished with S534 */
        pCtxCtrl->s534.addPlayerCbRcvd = BT_TRUE;
    }
    else
    {
        DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "AddPlayerProf_cb: CTX_534 not found");
    }

    if(APP_SD_CONTEXT_S534 == gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        BooleanType playerAvail = BT_FALSE; /* proceed further check if the player is enabled by diagnostic*/
        // check if player is enabled       /* changed by nikolov, 14.02.2011; RT:9947 */
        (void)EEPROM_LAYOUT_vGetPlayerEnabled(&playerAvail);

        /* added player after user profile has been created */
        /* here we do not want to show S533 cause the creeation of player
         * profile is hidden, player is created just to avoid inconstistency */
        if((APP_COMMON_RSP_OK == result)&&(playerAvail == BT_TRUE))
        {

            DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "AddPlayerProf_cb: Add Plyer ok");

            _APP_SD_vInitFrameSC12(profileId);
        }
        else
        {

            DEBUG_TEXT(APP_SD_SWI_ERR, MOD_APP_SD, "AddPlayerProf_cb: Add Plyer fail.");
            _APP_SD_vInitIdleScreen(0);
        }
    }
    else
    {
        if(APP_COMMON_RSP_OK == result)
        {
            _APP_SD_vInitFrameS533();
        }
        else
        {

            DEBUG_VALUE1(APP_SD_SWI_ERR, MOD_APP_SD, "AddPlayerProf_Cb error %d",
                            result);
        }
    }
}

/*----------------------------------------------------------------------------*/
/* Function :                                      */
/**
  \brief        Writes the actual callerid to the provided buffer
  \brief        Description:\n
                It compares the provided caller id with some specific numbers
                (mailbox, SOS-, INFO-call) and writes the corresponding name
                to the callerid if a match is found.

  \param        pDestName
                Destination buffer to put the correct callerid in.

  \param        pSrcName
                Source name that specifies the current callerid.

  \param        srcLen
                Length of the source callerid

  \return       Uint16Type
                The length of the new callerid

 */
/*----------------------------------------------------------------------------*/
Uint16Type _APP_SD_u16WriteCallerId(AT_CallerId *pDestName, const AT_CallerId *pSrcName, const Uint16Type srcLen)
{
    const AT_CallerId *pCallerId    = NULL;
    Uint16Type callerIdLen  = 0;


    //if(plcc != NULL && plcc->id_avail)
    if(pSrcName != NULL && srcLen != 0)
    {
        // check if callerId is number saved for mailbox for active user, if so, show
        // 'Mailbox' instead of number
        const ERMUserProfileType * profile = ERM_pGetActiveUserProfile();

        // compare mailbox number saved for profile with s801 number
        if( (NULL != profile) &&
            (srcLen == profile->voicemailbox_len) &&
            (0 == memcmp( profile->voicemailbox, pSrcName, srcLen)) )
        {
            pCallerId   = (const AT_CallerId *)APP_SD_aStaticMailboxKeywords[gAppSdContext.curLang][0].pu8PromptsToDisplay;
            callerIdLen = APP_SD_aStaticMailboxKeywords[gAppSdContext.curLang][0].u16LengthOfPrompt;
        }

        /* check if callerId matches the saved SOS call number */
        if(callerIdLen == 0)
        {
            ATPhoneNumberType number;
            Uint16Type numberLen = 0;

            SuccessFailType result = CONTEXT_MAN_sfGetSOSCallNumber(&number, &numberLen);

            if( (result == SUCCESS) &&
                (srcLen == numberLen) &&
                (0 == memcmp( number, pSrcName, srcLen)) )
            {
                pCallerId   = (const AT_CallerId *)gAppSdContext.prompts[APP_SD_en_S801_ta_call_sos_1_Zeile_1];
                callerIdLen = gAppSdContext.prompts_len[APP_SD_en_S801_ta_call_sos_1_Zeile_1];
            }
        }

        /* check if callerId matches the saved service call number */
        if(callerIdLen == 0)
        {
            ATPhoneNumberType number;
            Uint16Type numberLen = 0;

            SuccessFailType result = CONTEXT_MAN_sfGetServiceCallNumber(&number, &numberLen);

            if( (result == SUCCESS) &&
                (srcLen == numberLen) &&
                (0 == memcmp( number, pSrcName, srcLen)) )
            {
                pCallerId   = (const AT_CallerId *)gAppSdContext.prompts[APP_SD_en_S801_ta_call_service_1_Zeile_1];
                callerIdLen = gAppSdContext.prompts_len[APP_SD_en_S801_ta_call_service_1_Zeile_1];
            }
        }

        /* check if callerId matches the saved info call number */
        if(callerIdLen == 0)
        {
            ATPhoneNumberType number;
            Uint16Type numberLen = 0;

            SuccessFailType result = CONTEXT_MAN_sfGetInfoCallNumber(&number, &numberLen);

            if( (result == SUCCESS) &&
                (srcLen == numberLen) &&
                (0 == memcmp( number, pSrcName, srcLen)) )
            {
                pCallerId   = (const AT_CallerId *)gAppSdContext.prompts[APP_SD_en_S801_ta_call_info_1_Zeile_1];
                callerIdLen = gAppSdContext.prompts_len[APP_SD_en_S801_ta_call_info_1_Zeile_1];
            }
        }

        /* check for default callerId */
        if(callerIdLen == 0)
        {
            callerIdLen = srcLen;
            pCallerId   = pSrcName;
        }

        if(callerIdLen > 0)
        {
            if(callerIdLen > AT_CALLER_ID_STRING_MAX_LEN)
            {
                callerIdLen = AT_CALLER_ID_STRING_MAX_LEN;
            }
            /* set the callerId to show in frame*/
            (void)memcpy( pDestName, pCallerId, callerIdLen);
        }
    }
    return callerIdLen;
}


/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_vHandleHandsFreeModeChanged                            */
/**
  \brief        Handles the current handsfree mode

  \return       void

 */
/*----------------------------------------------------------------------------*/
void _APP_SD_vHandleHandsFreeModeChanged()
{
    if(APP_PHONE_bIsHandsFreeOff() == BT_TRUE)
    {
        // handsfree mode is off ( PATR:0 ), we are in private mode now

        switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
        {
            // show Private mode frame
            case APP_SD_CONTEXT_S801:
                // first check if index is really set!!!
                if( AT_CALL_INDEX_NONE == gAppSdContext.pCurCtxCtrl->s801.plccIndex)
                {
                    // not yet set, e.g. due to a private mode trigger from outside and not via MflButton
                    ATCallIndexEnum idx = APP_PHONE_AT_PNCC_GetOutgoingCallIndex();
                    if(AT_CALL_INDEX_NONE != idx )
                    {
                        gAppSdContext.pCurCtxCtrl->s801.plccIndex = idx;
                        _APP_SD_vInitFrameSC20(AT_CC_NOT_CONFERENCE, gAppSdContext.pCurCtxCtrl->s801.plccIndex); // RT #13183
                    }
                }
                /* else case integrated for RT #13183*/
                else
                {
                    _APP_SD_vInitFrameSC20(AT_CC_NOT_CONFERENCE, gAppSdContext.pCurCtxCtrl->s801.plccIndex); // RT #13183
                }
                //_APP_SD_vInitFrameSC20(AT_CC_NOT_CONFERENCE, gAppSdContext.pCurCtxCtrl->s801.plccIndex);         // RT #3554
                break;
            case APP_SD_CONTEXT_S803:
            case APP_SD_CONTEXT_S804:         // RT #8871
            case APP_SD_CONTEXT_S812:         // RT #3554
            case APP_SD_CONTEXT_S813:
                _APP_SD_vInitFrameSC20(AT_CC_NOT_CONFERENCE, gAppSdContext.pCurCtxCtrl->s803.plccIndex);
                break;
            case APP_SD_CONTEXT_S815:
                _APP_SD_vInitFrameSC20(AT_CC_CONFERENCE, gAppSdContext.pCurCtxCtrl->s803.plccIndex);
                break;
            default:
                DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "_APP_SD_vHandleHandsFreeModeChanged private mode now screen not considered: %d",
                            gAppSdContext.pCurCtxCtrl->common.ctxId);
                break;
        }
    }
    else    // we are in handsfree mode now
    {
        switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
        {
            case APP_SD_CONTEXT_SC20:
            {
                // private mode is currently handled for outgoing call (S801) and one single active call (S803) only.
                // so just differ which state we have and then go into the correct frame
                const ATRspCallStatValType *plcc    = NULL;
                const ATRspCallStatValType *plcc1   = APP_PHONE_AT_PNCC_pGetPlccContext(AT_CALL_INDEX_0);
                const ATRspCallStatValType *plcc2   = APP_PHONE_AT_PNCC_pGetPlccContext(AT_CALL_INDEX_1);
                // TODO: might be extended for additional plccs e.g, when we support 3 calls

                // an outgoing call can occurr also, when there is another call on hold.
                if( (plcc1!=NULL) && (plcc2!=NULL) )
                {
                    // check if one of them is of state outgoing so we should show S801
                    if((AT_CS_OUTCALL_DIAL_IPR == plcc1->state) ||
                       (AT_CS_OUTCALL_RING_IPR == plcc1->state))
                    {   // first index is the outgoing one
                        plcc = plcc1;
                    }
                    else if((AT_CS_OUTCALL_DIAL_IPR == plcc2->state) ||
                            (AT_CS_OUTCALL_RING_IPR == plcc2->state))
                    {   // second index is the outgoing one
                        plcc = plcc2;
                    }         // RT #3554
                    else if((AT_CS_ACTIVE_CALL == plcc1->state) &&
                            (AT_CS_HELD_CALL == plcc2->state))
                    {   // first index is the active one
                        // second index is in held state
                        _APP_SD_vInitFrameS812((ATCallIndexEnum)plcc1->index, (ATCallIndexEnum)plcc2->index);
                        plcc = NULL;
                    }
                    else if((AT_CS_HELD_CALL == plcc1->state) &&
                            (AT_CS_ACTIVE_CALL == plcc2->state))
                    {   // first index is in held state
                        // second index is the active one
                        _APP_SD_vInitFrameS812((ATCallIndexEnum)plcc2->index, (ATCallIndexEnum)plcc1->index);
                        plcc = NULL;
                    }
                    else if(((AT_CS_ACTIVE_CALL == plcc1->state)  &&
                            (AT_CS_ACTIVE_CALL == plcc2->state)) &&
                            (plcc1->call_conf_type == AT_CC_CONFERENCE))
                    {   // first index is the active one
                        // second index is the active one
                        _APP_SD_vInitFrameS815();
                        plcc = NULL;
                    }
                }
                else if ((plcc1 != NULL) || (plcc2 != NULL) )
                {   // check which one to use
                    const ATRspCallStatValType *tmp     = (plcc1 != NULL) ? plcc1 : plcc2;
                    if((AT_CS_ACTIVE_CALL == tmp->state))
                    {   // we have an active call
                        plcc = tmp;
                    }
                    else if((AT_CS_HELD_CALL == tmp->state))
                    {   // we have a held call
                        plcc = tmp;
                    }
                    else if((AT_CS_OUTCALL_DIAL_IPR == tmp->state) ||
                            (AT_CS_OUTCALL_RING_IPR == tmp->state))
                    {
                        plcc = tmp;
                    }
                }

                // JUST FOR INFO: check if plcc is still NULL so event was not handled
                if(NULL == plcc)
                {

                    DEBUG_TEXT(APP_SD_SWI_ERR, MOD_APP_SD, "HdlHfpModeChang: plcc NULL");
                    return;
                }


                switch( plcc->state )
                {
                    case AT_CS_OUTCALL_DIAL_IPR:
                    case AT_CS_OUTCALL_RING_IPR:
                        if(_APP_SD_bIsKl15On() == BT_TRUE)
                        {
                            _APP_SD_vInitFrameS801_PN(plcc->caller_id, plcc->caller_id_len, BT_FALSE);
                        }
                        else
                        {
                            _APP_SD_vInitFrameS945_PN(plcc->caller_id, plcc->caller_id_len, BT_FALSE);
                        }
                        break;
                    case AT_CS_ACTIVE_CALL:
                        if(_APP_SD_bIsKl15On() == BT_TRUE)
                        {
                            _APP_SD_vInitFrameS803((ATCallIndexEnum)plcc->index);
                        }
                        else
                        {
                            _APP_SD_vInitFrameS942((ATCallIndexEnum)plcc->index);
                        }
                        break;
                    case AT_CS_HELD_CALL:         // RT #3554
                        _APP_SD_vInitFrameS811((ATCallIndexEnum)plcc->index);
                        break;
                    default:
                        DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "_APP_SD_vHandleHandsFreeModeChanged plcc->state not considered: %d",
                             plcc->state);
                        break;
                }
            }
            default:
                DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "_APP_SD_vHandleHandsFreeModeChanged handsfree mode now: screen not considered: %d",
                            gAppSdContext.pCurCtxCtrl->common.ctxId);
                break;
        }
    }
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_vHandleCallStateChanged                               */
/**
  \brief        Handles the current call state

  \return       void

 */
/*----------------------------------------------------------------------------*/
void _APP_SD_vHandleCallStateChanged()
{
    const ATRspCallStatValType *plcc1 = APP_PHONE_AT_PNCC_pGetPlccContext(AT_CALL_INDEX_0);
    const ATRspCallStatValType *plcc2 = APP_PHONE_AT_PNCC_pGetPlccContext(AT_CALL_INDEX_1);
    //const ATRspCallStatValType *plcc3 = APP_PHONE_AT_PNCC_pGetPlccContext(AT_CALL_INDEX_2);

    if( (plcc1!=NULL) && (plcc2!=NULL) )
    {
        /* we have callStates on both lines */
        const ATRspCallStatValType *activePlcc = NULL;
        const ATRspCallStatValType *heldPlcc = NULL;
        const ATRspCallStatValType *unknownPlcc = NULL;

        if(plcc1->state == AT_CS_ACTIVE_CALL)
        {
            activePlcc  = plcc1;
            unknownPlcc = plcc2;
        }
        else if(plcc2->state == AT_CS_ACTIVE_CALL)
        {
            activePlcc  = plcc2;
            unknownPlcc = plcc1;
        }
        else if(plcc1->state == AT_CS_HELD_CALL)
        {
            /* no active plcc available */
            heldPlcc    = plcc1;
            unknownPlcc = plcc2;
        }
        else if(plcc2->state == AT_CS_HELD_CALL)
        {
            heldPlcc    = plcc2;
            unknownPlcc = plcc1;
        }
        else
        {
            activePlcc  = NULL;
            heldPlcc    = NULL;
            unknownPlcc = NULL;
        }
        DEBUG_VALUE2(APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePhoneEvent: PLCC1!=NULL && PLCC2!=NULL  plcc1 state:%d, plcc2 state:%d ",
                                plcc1->state,plcc2->state);
        if(activePlcc != NULL)
        {
            switch(unknownPlcc->state)
            {
                case AT_CS_ACTIVE_CALL:
                    if( BT_TRUE == APP_PHONE_bIsHandsFreeOff())         // RT #3554
                    {
                        // private mode
                        _APP_SD_vInitFrameSC20(AT_CC_CONFERENCE, (ATCallIndexEnum)activePlcc->index);
                    }
                    else
                    {   /* both callstates are active -> active conference */
                        _APP_SD_vInitFrameS815();
                    }
                    break;
                case AT_CS_WAITING_CALL:
                    /* we have one waiting call */
                    _APP_SD_vInitFrameS902((ATCallIndexEnum)activePlcc->index,
                                           (ATCallIndexEnum)unknownPlcc->index);
                    break;
                case AT_CS_HELD_CALL:
                    if( BT_TRUE == APP_PHONE_bIsHandsFreeOff())         // RT #3554
                    {
                        // private mode
                        _APP_SD_vInitFrameSC20(AT_CC_NOT_CONFERENCE, (ATCallIndexEnum)activePlcc->index);
                    }
                    else
                    {
                        _APP_SD_vInitFrameS812((ATCallIndexEnum)activePlcc->index,
                                               (ATCallIndexEnum)unknownPlcc->index);
                    }
                    break;
                default:
                    /* ignore other states */
                    break;
            }
        }
        else if(heldPlcc != NULL)
        {
            DEBUG_VALUE1(APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePhoneEvent: heldPLCC!=NULL  plcc state %d ",
                                heldPlcc->state);
            switch(unknownPlcc->state)
            {
                case AT_CS_OUTCALL_DIAL_IPR:
                case AT_CS_OUTCALL_RING_IPR:
                // SUSANNE: 01.09.2009, #2580
                    // do not make an init if S801 is already shown
                   //if( APP_SD_CONTEXT_S801 != gAppSdContext.pCurCtxCtrl->common.ctxId &&
                   //     APP_SD_CONTEXT_SC20 != gAppSdContext.pCurCtxCtrl->common.ctxId )
                   // show s801 when timeout of infoscreen and handlecallstate is called
                   // show and stop bitte warten screen when abort dialing second call is pressed RT #4881
                    gAppSdContext.callStateIsActive = BT_TRUE;
                    if (BT_TRUE == gAppSdContext.preCallStateIsActive )
                    {
                        gAppSdContext.pCurCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                        gAppSdContext.pCurCtxCtrl->s408.subStateBtn   = APP_SD_S408_HANGUP_NOT_SENT;

                        //gAppSdContext.preCallStateIsActive = BT_FALSE;

                        if (gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_S408_PRECALL)
                        {
                            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                MSEC(0), 0);
                        }
                        else
                        {
                            (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                                MSEC(5500), 0);
                        }
                    }
                    else if  (APP_SD_CONTEXT_SC20 != gAppSdContext.pCurCtxCtrl->common.ctxId )
                    {
                        _APP_SD_vInitFrameS801_PN(unknownPlcc->caller_id, unknownPlcc->caller_id_len, BT_FALSE);
                    }
                    else
                    {
                        _APP_SD_vInitFrameSC20(AT_CC_NOT_CONFERENCE, (ATCallIndexEnum)unknownPlcc->index);
                    }
                    break;
                case AT_CS_WAITING_CALL:
                    /* we have one waiting call */
                    _APP_SD_vInitFrameS902((ATCallIndexEnum)activePlcc->index,
                                           (ATCallIndexEnum)unknownPlcc->index);
                    break;
                case AT_CS_HELD_CALL:
                    /* held conference */
                    /* as specified show S811 with "Konferenz gehalten without a number */
                    _APP_SD_vInitFrameS811(AT_CALL_INDEX_CONFERENCE);
                    break;
                default:
                    /* ignore other states */
                    break;
            }
        }
    }
    else if ( (plcc1 != NULL) || (plcc2 != NULL) )
    {

        /* we have callState on one line */
        static BooleanType bNameAvailableOnFirstPlccEvent = BT_FALSE;
        const ATRspCallStatValType *plcc = NULL;
        if ( (plcc1 != NULL))
        {
            DEBUG_VALUE1(APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePhoneEvent: only PLCC1!=0  plcc1 state %d ",
                                plcc1->state);
        }
        else
        {
            DEBUG_VALUE1(APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePhoneEvent: only PLCC2!=0  plcc2 state %d ",
                                plcc2->state);
        }
        //const ATRspCallStatValType *
        plcc = (plcc1 != NULL) ? plcc1 : plcc2;

        DEBUG_VALUE1(APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePhoneEvent: PLCC1!=NULL || PLCC2!=NULL  plcc state %d ",
                                plcc->state);

        switch(plcc->state)
        {
            case AT_CS_ACTIVE_CALL:
            {
                gAppSdContext.callStateIsActive = BT_FALSE;
                bNameAvailableOnFirstPlccEvent = BT_FALSE;
                if(_APP_SD_bIsKl15On() == BT_TRUE)
                {
                    // #2580 If we are already in Private Mode, show SC20 for active call!!
                    // NOTE: This does not prevent us to go into S803, e.g. cause Ck5050 sets HFp-Mode back
                    // to HFP on a call state change without request from Host
                    if( BT_TRUE == APP_PHONE_bIsHandsFreeOff())
                    {
                        // private mode
                        _APP_SD_vInitFrameSC20(AT_CC_NOT_CONFERENCE, (ATCallIndexEnum)plcc->index);         // RT #3554
                    }
                    else
                    {   // show active call
                        _APP_SD_vInitFrameS803((ATCallIndexEnum)plcc->index);
                    }
                }
                else
                {
                    _APP_SD_vInitFrameS942((ATCallIndexEnum)plcc->index);
                }
                break;
            }
            case AT_CS_CALL_TERMINATED:
            {
                bNameAvailableOnFirstPlccEvent = BT_FALSE;
                gAppSdContext.callStateIsActive = BT_FALSE;
                //_APP_SD_vCtxHistoryReset(gAppSdContext.pCurCtxCtrl);
                break;
            }
            case AT_CS_INCOMING:
            {
                if(_APP_SD_bIsKl15On() == BT_TRUE)
                {
                    _APP_SD_vInitFrameS901((ATCallIndexEnum)plcc->index);
                }
                else
                {
                    _APP_SD_vInitFrameS941((ATCallIndexEnum)plcc->index);
                }
                break;
            }
            case AT_CS_OUTCALL_DIAL_IPR:
            case AT_CS_OUTCALL_RING_IPR:
            {
                gAppSdContext.callStateIsActive = BT_TRUE;
                if (BT_TRUE == gAppSdContext.preCallStateIsActive )
                {
                    gAppSdContext.pCurCtxCtrl->common.pendingType = APP_SD_PENDING_BUTTON;
                    gAppSdContext.pCurCtxCtrl->s408.subStateBtn   = APP_SD_S408_HANGUP_NOT_SENT;

                    //gAppSdContext.preCallStateIsActive = BT_FALSE;

                    if (gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_S408_PRECALL)
                    {
                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(0), 0);
                    }
                    else
                    {
                        (void)APP_COMMON_UTILS_stSetOsekRelAlarm( CTA_APP_SD_FCT_PENDING,
                                                            MSEC(5500), 0);
                    }
                }
                else
                {
                    if(_APP_SD_bIsKl15On() == BT_TRUE)
                    {
                        // SUSANNE: 01.09.2009, #2580
                        // do not make an init if S801 is already shown

                        if( APP_SD_CONTEXT_S801 != gAppSdContext.pCurCtxCtrl->common.ctxId &&
                            APP_SD_CONTEXT_S408_PRECALL != gAppSdContext.pCurCtxCtrl->common.ctxId &&
                            APP_SD_CONTEXT_SC20 != gAppSdContext.pCurCtxCtrl->common.ctxId)
                        {
                            DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "sfHandleCallstateChanged: Name available: %d",plcc->ext_avail);
                            bNameAvailableOnFirstPlccEvent = (plcc->ext_avail == AT_TRUE) ? BT_TRUE: BT_FALSE;
                            _APP_SD_vInitFrameS801_PN(plcc->caller_id, plcc->caller_id_len, BT_FALSE);

                        }
                        else if(APP_SD_CONTEXT_S801 == gAppSdContext.pCurCtxCtrl->common.ctxId &&
                               ((plcc->ext_avail == AT_TRUE && bNameAvailableOnFirstPlccEvent == BT_FALSE) || gAppSdContext.dialing_was_initiated_by_vcrOnceFlag == BT_TRUE))
                        {
                            //RT 4084 Update Name to given number. Sometimes (e.g using BB9700 there are 2 plcc events the first still
                            //without name for the number after dialing via VCR (redial also)

                            gAppSdContext.dialing_was_initiated_by_vcrOnceFlag = BT_FALSE;

                            gAppSdContext.pCurCtxCtrl->s801.subState   = APP_SD_S801_NUMBER_DIALED;
                            gAppSdContext.pCurCtxCtrl->s801.plccIndex  = AT_CALL_INDEX_NONE;
                            gAppSdContext.pCurCtxCtrl->s801.pbType     = APP_PHONEBOOK_enPbUnknown;
                            gAppSdContext.pCurCtxCtrl->s801.pbIndex    = 0;
                            gAppSdContext.pCurCtxCtrl->s801.pnIndex    = 0;
                            gAppSdContext.pCurCtxCtrl->s801.number_len = (sizeof(plcc->caller_id) < plcc->caller_id_len) ? sizeof(plcc->caller_id) : plcc->caller_id_len;
                            (void)memcpy( gAppSdContext.pCurCtxCtrl->s801.number, &plcc->caller_id, plcc->caller_id_len);

                            DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "sfHandleCallstateCahnged: refresh frame");

                            _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                        }
                        else /*RT15308*/
                        {
                            _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                        }
                    }
                    else
                    {
                        _APP_SD_vInitFrameS945_PN(plcc->caller_id, plcc->caller_id_len, BT_FALSE);
                    }
                }
                break;
            }
            case AT_CS_HELD_CALL:
            {
                _APP_SD_vInitFrameS811((ATCallIndexEnum)plcc->index);
                break;
            }
            default:
            {
                DEBUG_VALUE1(APP_SD_SWI_ERR, MOD_APP_SD, "sfHandlePhoneEvent: plcc state %d ignored",
                                plcc->state);
                break;
            }
        }
    }
    else
    {
        DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "sfHandlePhoneEvent: no PLCC available ctx %d ",
                                gAppSdContext.pCurCtxCtrl->common.ctxId);
        gAppSdContext.callStateIsActive = BT_FALSE;
        /* no call information available */
        switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
        {
            case APP_SD_CONTEXT_SC20:
            case APP_SD_CONTEXT_S801:
            case APP_SD_CONTEXT_S811:
            case APP_SD_CONTEXT_S812:
            case APP_SD_CONTEXT_S815:
//            case APP_SD_CONTEXT_S901:         // RT #4066
            case APP_SD_CONTEXT_S902:       // RT #4634
            case APP_SD_CONTEXT_S941:       // RT #4144
            case APP_SD_CONTEXT_S942:       // RT #4144
            case APP_SD_CONTEXT_S945:       // RT #4144
            case APP_SD_CONTEXT_SC24:
            case APP_SD_CONTEXT_S305:
            case APP_SD_CONTEXT_S408_PRECALL: //CR15
                // go back to MMI screen (release context for phone)
                if((BT_FALSE == _APP_SD_bPhoneContextActive()) || (BT_FALSE == _APP_SD_bIsKl15On())) //when Kl15 off no screen is behind therefore do a releasephonecontext
                {
                    _APP_SD_vReleasePhoneContext();
                }
                else
                {
                    _APP_SD_vCtxHistoryStepBack();
                }
                break;
            case APP_SD_CONTEXT_S901:           // RT #4066
                // go back to MMI screen (release context for phone)
                if(BT_FALSE == _APP_SD_bPhoneContextActive())
                {   // S901 is incoming call? Warum geben wir den Context hier erst weg?? und holen ihn uns anschließend wieder?
                    _APP_SD_vReleasePhoneContext();
                    (void)_APP_SD_vSetCtxHistoryState(APP_SD_START_BACK_TO_ASG_MENU, __LINE__);
                }
                else
                {
                    _APP_SD_vCtxHistoryStepBack();
                }
                break;
            case APP_SD_CONTEXT_S804:
                // go back to MMI screen (release context for phone)
                if(BT_FALSE == _APP_SD_bPhoneContextActive())
                {
                    _APP_SD_vReleasePhoneContext();
                }
                else
                {
                    /* the call was terminated, step back twice */
                    _APP_SD_vCtxHistoryStepBack();
                    _APP_SD_vCtxHistoryStepBack();
                }
                break;
            /* the call was terminated, cancel the timeout alarm and step back */
            case APP_SD_CONTEXT_S301:
                /* the call was terminated, cancel timeout alarm */
                (void)APP_COMMON_UTILS_stCancelOsekRelAlarm(CTA_APP_SD_FRAME_TIMEOUT);
                // go back to MMI screen (release context for phone)
                if(BT_FALSE == _APP_SD_bPhoneContextActive())
                {
                    _APP_SD_vReleasePhoneContext();
                }
                else
                {
                    _APP_SD_vCtxHistoryStepBack();
                }
                break;
            case APP_SD_CONTEXT_S803:
                if((BT_FALSE == _APP_SD_bPhoneContextActive()) || (BT_FALSE == _APP_SD_bIsKl15On())) //when Kl15 off no screen is behind therefore do a releasephonecontext
                {
                    _APP_SD_vReleasePhoneContext();
                }
                else
                {
                    _APP_SD_vCtxHistoryStepBack();
                    if ((gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_SC12) &&
                        (AT_INVALID_DEVICE_ID != ERM_u8GetActivePlayer()))
                    {
                        DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "sfHandlePhoneEvent: call ended and SC12 before but MP arlready connected");
                        _APP_SD_vCtxHistoryStepBack();
                    }
                }
                break;
            default:
                _APP_SD_vCtxHistoryReset(gAppSdContext.pCurCtxCtrl);
                break;
        }
    }
}


/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_vActivateFrame                               */
/**
  \brief        Sets the activate frame state

  \param        activate
                activate = true means activate the frame, else not

  \param        line
                line where functionw as called, for debug output only

  \return       void

 */
/*----------------------------------------------------------------------------*/
void _APP_SD_vActivateFrame(BooleanType activate, Uint32Type line)
{

    DEBUG_STRING(APP_SD_SWI_TRC, MOD_APP_SD, "vActFrame: activate state: %s -> ... ",
                        gAppSdContext.activate ? "TRUE":"FALSE");
    DEBUG_STRING(APP_SD_SWI_TRC, MOD_APP_SD, "vActFrame: activate state: ... -> %s ",
                        activate ? "TRUE":"FALSE");
    DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "vActFrame: activate state: ... line: %d",
                        line);

    gAppSdContext.activate = activate;
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_vCtxHistoryCall                               */
/**
  \brief        Sets the new history for context

  \param        ctxHisState
                APP_SD_enContextState

  \param        line
                line where functionw as called, for debug output only

  \return       void

 */
/*----------------------------------------------------------------------------*/
void _APP_SD_vSetCtxHistoryState(APP_SD_enContextState ctxHisState, Uint32Type line)
{
    DEBUG_VALUE2( APP_SD_SWI_TRC, MOD_APP_SD, "CtxHistoryCall: context state: %d -> %d ...",
                        gAppSdContext.ctxInView,
                        ctxHisState);
    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "CtxHistoryCall: ... line: %d",
                        line);

    gAppSdContext.ctxInView = ctxHisState;
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_bPhoneContextActive                               */
/**
  \brief        returns whether phone context is active in cluster instrument or not

  \return       BooleanType

 */
/*----------------------------------------------------------------------------*/
BooleanType _APP_SD_bPhoneContextActive()
{
    if((gAppSdContext.ctxInView == APP_SD_WAIT_BACK_TO_ASG_MENU)||(gAppSdContext.ctxInView == APP_SD_UHV_NOT_IN_ASG_VIEW))
    {
        return BT_FALSE;
    }

    return BT_TRUE;
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_bPhoneContextActive                               */
/**
  \brief        release phone context

  \return       void

 */
/*----------------------------------------------------------------------------*/
void _APP_SD_vReleasePhoneContext()
{
    /* we want to release the phone context and make IC to step into another context like MFA etc. */
    _APP_SD_vActivateFrame(BT_FALSE, __LINE__);     // do not activate further frames
    _APP_SD_vInitIdleScreen(0);                      // init idle screen but do not activate it
    _APP_SD_FB_vPresReqOff(__LINE__);               // give back view to IC (presentation request off)

    // when user steps back into phone menu, we activate current screen and (s)he will see the idle screen
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_vReleasePhoneContextWithStepBack                      */
/**
  \brief        release phone context

  \return       void

 */
/*----------------------------------------------------------------------------*/
void _APP_SD_vReleasePhoneContextWithStepBack()
{
    /* we want to release the phone context and make IC to step into another context like MFA etc. */
    _APP_SD_vActivateFrame(BT_FALSE, __LINE__);     // do not activate further frames
    _APP_SD_vCtxHistoryStepBack();                  // proceed history step back
    _APP_SD_FB_vPresReqOff(__LINE__);               // give back view to IC (presentation request off)

    // when user steps back into phone menu, we activate current screen and (s)he will see the idle screen
}

/*----------------------------------------------------------------------------*/
/* Function :   _APP_SD_bIsKl15On                                             */
/**
  \brief        Returns the state of Kl15

  \param        void

  \return       BooleanType

 */
/*----------------------------------------------------------------------------*/
BooleanType _APP_SD_bIsKl15On()
{
    BooleanType bKl15On = CSHDL_bIsKl15On();


    DEBUG_STRING( APP_SD_SWI_TRC, MOD_APP_SD, "bIsKl15On: %s",
                        bKl15On ? "TRUE":"FALSE");

    return bKl15On;
}

/*----------------------------------------------------------------------------*/
/* Function :   APP_SD_bIsIdleScreenActive                                             */
/**
  \brief        Returns the state of active Idle

  \param        APP_SD_enIdleScreenState

  \return       BooleanType

 */
/*----------------------------------------------------------------------------*/
BooleanType APP_SD_bIsIdleScreenActive(APP_SD_enIdleScreenState idleState)
{
    BooleanType bIdleScreenActive = BT_FALSE;
switch(idleState)
{
    case APP_SD_IDLE_SCREEN_ALL:
        switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
        {
            /* check if we currently stay in idle screen */
            case APP_SD_CONTEXT_S018:
            case APP_SD_CONTEXT_SP18:
            case APP_SD_CONTEXT_S002:
            case APP_SD_CONTEXT_S010:
                bIdleScreenActive = BT_TRUE;
                break;
            default:
                bIdleScreenActive = BT_FALSE;
                break;
        }
        break;
    case APP_SD_IDLE_SCREEN_ACTIVE_PHONE:
        switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
        {
            /* check if we currently stay in idle screen */
            case APP_SD_CONTEXT_S018:
            case APP_SD_CONTEXT_SP18:
            case APP_SD_CONTEXT_S002:
                if (_APP_SD_phoneActivatedOnce == BT_TRUE)
                {
                    bIdleScreenActive = BT_TRUE;
                }
                else
                {
                    bIdleScreenActive = BT_FALSE;
                }
                break;
            default:
                bIdleScreenActive = BT_FALSE;
                break;
        }
        break;
    case APP_SD_IDLE_SCREEN_INACTIVE_PHONE:
        switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
        {
            /* check if we currently stay in idle screen */
            case APP_SD_CONTEXT_S018:
            case APP_SD_CONTEXT_SP18:
            case APP_SD_CONTEXT_S002:
                if (_APP_SD_phoneActivatedOnce == BT_FALSE)
                {
                    bIdleScreenActive = BT_TRUE;
                }
                else
                {
                    bIdleScreenActive = BT_FALSE;
                }
                break;
            default:
                bIdleScreenActive = BT_FALSE;
                break;
        }
        break;
    default:
        break;
}
    return bIdleScreenActive;
}
/*----------------------------------------------------------------------------*/
/* Function :   APP_SD_bIsCallScreenActive                                    */
/**
  \brief        Returns the state of active Call screen

  \param        none

  \return       BooleanType

 */
/*----------------------------------------------------------------------------*/
BooleanType APP_SD_bIsCallScreenActive(void)
{
    BooleanType bCallScreenActive = BT_FALSE;

    switch (gAppSdContext.pCurCtxCtrl->common.ctxId) {
    /* S801, S803, SC20, S811, S812, S815, S813, S901, S902*/
    case APP_SD_CONTEXT_S801:
    case APP_SD_CONTEXT_S803:
    case APP_SD_CONTEXT_S811:
    case APP_SD_CONTEXT_S812:
    case APP_SD_CONTEXT_S813:
    case APP_SD_CONTEXT_S815:
    case APP_SD_CONTEXT_SC20:
    case APP_SD_CONTEXT_S901:
    case APP_SD_CONTEXT_S902:
        bCallScreenActive = BT_TRUE;
        break;
    default:
        bCallScreenActive = BT_FALSE;
        break;

    }

    return bCallScreenActive;
}

//BooleanType _APP_SD_bPausePlayerTemporarilyNeeded()
//{
//    if( ((APP_MDI_GetPlayStatus() == APP_MDI_ACT_STATE_PLAY)) &&
//         (AT_INVALID_DEVICE_ID != ERM_u8GetActivePlayer())   )
//    {   // player connected and playing
//        return BT_TRUE;
//    }
//    return BT_FALSE;
//}


/*----------------------------------------------------------------------------*/
/* Function    : APP_SD_sfGetTextForNumberType                                */
/**
    \brief      this function search the text information in the different languages

    \param      Type of text
                APP_SD_enNumberType
                enum values
    \param      Pointer to text from language table of the SD text
                Uint8Type *
                all value allowed
    \param      pointer to length of the text
                Uint16Type *
                all value allowed
    \return     SuccessFailType sF
                SUCCESS or FAIL
   */
/*----------------------------------------------------------------------------*/
SuccessFailType APP_SD_sfGetTextForNumberType(APP_SD_enNumberType numberType, const Uint8Type ** pText, Uint16Type * pTextLen  )
{
    *pText      = NULL;
    *pTextLen   = 0;

    switch(numberType)
    {
        case APP_SD_NUMBER_TYPE_INFO:
            *pText      = gAppSdContext.prompts[APP_SD_en_S801_ta_call_info_1_Zeile_1];
            *pTextLen   = gAppSdContext.prompts_len[APP_SD_en_S801_ta_call_info_1_Zeile_1];
            break;
        case APP_SD_NUMBER_TYPE_SOS:
            *pText      = gAppSdContext.prompts[APP_SD_en_S801_ta_call_sos_1_Zeile_1];
            *pTextLen   = gAppSdContext.prompts_len[APP_SD_en_S801_ta_call_sos_1_Zeile_1];
            break;
        case APP_SD_NUMBER_TYPE_SERVICE:
            *pText      = gAppSdContext.prompts[APP_SD_en_S801_ta_call_service_1_Zeile_1];
            *pTextLen   = gAppSdContext.prompts_len[APP_SD_en_S801_ta_call_service_1_Zeile_1];
            break;
        case APP_SD_NUMBER_TYPE_MAILBOX:
            // we always use the first entry
            *pText      = APP_SD_aStaticMailboxKeywords[gAppSdContext.curLang][0].pu8PromptsToDisplay;
            *pTextLen   = APP_SD_aStaticMailboxKeywords[gAppSdContext.curLang][0].u16LengthOfPrompt;
            break;
        case APP_SD_NUMBER_TYPE_UNKNOWN_CALLER_ID:
            *pText      = gAppSdContext.prompts[APP_SD_en_S211_ta_menu_no_nbr_Auswahl_1];
            *pTextLen   = gAppSdContext.prompts_len[APP_SD_en_S211_ta_menu_no_nbr_Auswahl_1];
            break;
        default:
            return FAIL;
    }
    return SUCCESS;
}




void _APP_SD_vHandlePhoneStateChanged()
{
    /* save the last phone connected */
    static AT_DeviceId DeviceIdPhoneActive = AT_INVALID_DEVICE_ID;

    if(ERM_u8GetActivePhone() != AT_INVALID_DEVICE_ID)
    {
        AT_DeviceId deviceId = ERM_u8GetActivePhone();
        const ERMUserProfileType *pUser = ERM_pGetUserProfile_DevId(deviceId);

        /* always save the current active devID(changed on 24.03.2011 by Nikolov / RT: #9905) */
        DeviceIdPhoneActive = deviceId;

        if( pUser == NULL)
        {
            /* a new paired device is active, set up a user */
            //_APP_SD_vInitFrameSC17(deviceId);
            // go to T5.3
            if( BT_TRUE == ERM_bMaxNumberOfUserProfilesReached() )
            {
                // user needs to delete one of the existing profiles first
                /* save deviceId etc. for pending profile */
                gAppSdContext.pendingProfile.bPending       = BT_TRUE;
                gAppSdContext.pendingProfile.profileType    = APP_DEVICE_enTYPE_PHONE;
                gAppSdContext.pendingProfile.deviceId       = deviceId;
                /* now tell user to delete an existing profile */
                _APP_SD_vInitFrameS511();
            }
            else
            {
                //_APP_SD_vInitFrameS535(pCtxCtrl->s007.deviceId);
                _APP_SD_vInitFrameS534(deviceId);
            }
        }
        else
        {
            // Susanne: 07.08.2009 We sometimes have two different jingles when connecting a user
            // This might be cause we are reconnecting the player again, also it is still active.
            // Trying to fix this with not calling SC12 if associated player is already active
            BooleanType showSc12    = BT_FALSE;
            Uint8Type playerProfile = pUser->playerIndex;

            BooleanType playerAvail = BT_FALSE;
            // get device id of active player
            AT_DeviceId activePlayerDevice = ERM_u8GetActivePlayer();
            const ERMPlayerHeadsetProfileType *pAssociatedPlayerProfile = ERM_pGetPlayerHeadsetProfile(playerProfile);
            AT_DeviceId associatedPlayerDeviceId = pAssociatedPlayerProfile->deviceIndex;
            if( NULL != pAssociatedPlayerProfile )
            {
                // check if player is enabled
                (void)EEPROM_LAYOUT_vGetPlayerEnabled(&playerAvail);

                DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "handlePhoneStateChanged: playerProfile: %d", playerProfile);
                DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "handlePhoneStateChanged: activePlayerDevice: %d", activePlayerDevice);
                DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "handlePhoneStateChanged: pAssociatedPlayerProfile->deviceIndex: %d", pAssociatedPlayerProfile->deviceIndex);
                DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "handlePhoneStateChanged: playerAvail: %d", playerAvail);
                if( (playerProfile      != AT_INVALID_DEVICE_ID) &&                     // player associated
                    ((activePlayerDevice != associatedPlayerDeviceId)||
                    ((activePlayerDevice == associatedPlayerDeviceId)&&(_APP_SD_bRemoteControlAvailable() == BT_TRUE))) &&    // active not associated one //uncomment this because it may happen that profile are already updated and anyway we need other player
                    (playerAvail        == BT_TRUE) /*&&*/                                  // enabled in diagnosis			  // if a2dp is already connected and no avrcp, so connect it too ( changed: 14.02.2011 nikolov,RT:9959)
                    /*(ERM_u8GetActivePlayer() == AT_INVALID_DEVICE_ID)*/)              // player will be connected, if the player was stored to a hfp profile, TB
                {
                    showSc12 = BT_TRUE;
                }
                else
                {
                    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "handlePhoneStateChanged: associatedPlayerDeviceId: %d", associatedPlayerDeviceId);
                }
            }
            else
            {
                DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "HandlePhoneStateChanged: no associated Playerprofile");
            }

            if(BT_TRUE == showSc12)
            {
                if(gAppSdContext.pCurCtxCtrl->common.ctxId == APP_SD_CONTEXT_S924)
                {
                    /* if S924 for active VCR is shown, do not shown SC12, wait for step back */

                    DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "HandlePhoneStateChanged: ign conn ev in S924");
                    return;
                }
                DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "HandlePhoneStateChanged: Active phone in ctx %d + showSc12",
                                            gAppSdContext.pCurCtxCtrl->common.ctxId);
                _APP_SD_vInitFrameSC12(playerProfile);

            }
            else
            {
                DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "HandlePhoneStateChanged: Active phone in ctx %d",
                            gAppSdContext.pCurCtxCtrl->common.ctxId);
                //RT: #4001
                _APP_SD_vInitIdleScreen(0);
            }
        }
    }
    else
    {
        /* check if the device is disconnected unsolicited(by itself) while profile adding in progress
         * and the device has already started AVRCP and A2DP service, so disconnect it
         * (changed on 24.03.2011 by Nikolov / RT: #9905) */
        if(((ERM_u8GetActivePlayer() != AT_INVALID_DEVICE_ID)||(ERM_u8GetActiveDeviceAVRCP() != AT_INVALID_DEVICE_ID)) &&
           ((DeviceIdPhoneActive == ERM_u8GetActivePlayer()) ||(DeviceIdPhoneActive == ERM_u8GetActiveDeviceAVRCP())) &&
           (ERM_pGetUserProfile_DevId(DeviceIdPhoneActive) == NULL)
          )
        {
            APP_COMMON_enResponseCode rspCode;

            DEBUG_VALUE2(APP_SD_SWI_TRC, MOD_APP_SD, "HandlePhoneStateChanged: Active phone %d disconnected while profile adding, disconnect player too activePlayerID: %d",
                                                    DeviceIdPhoneActive, ERM_u8GetActivePlayer());

            DEBUG_VALUE2(APP_SD_SWI_TRC, MOD_APP_SD, "HandlePhoneStateChanged: Active phone %d disconnected while profile adding, stop AVRCP service too DevID: %d",
                                                                DeviceIdPhoneActive, ERM_u8GetActiveDeviceAVRCP());

            /* deactivate the MP in this case */
            rspCode = APP_DEVICE_rcDeactivateMdiDevice(NULL);

            if( rspCode == APP_COMMON_RSP_ERROR_BUSY)
            {

                DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "ERM_NOTIFY_PBSN_A2DP: deactivate player busy  --->queue event in Appdevice");
                APP_DEVICE_vSetDeactivatePlayerPendingFlag(ERM_u8GetActivePlayer());
            }
        }

        /* no phone device active */
        DeviceIdPhoneActive = AT_INVALID_DEVICE_ID;

        /* release mute and stop play ringtone */
        if( APP_SD_CONTEXT_S642 == gAppSdContext.pCurCtxCtrl->common.ctxId )
        {
            (void)APP_DEVICE_rcStopRingtoneNonBlock();
        }
        switch( gAppSdContext.pCurCtxCtrl->common.ctxId )
        {
            case APP_SD_CONTEXT_S001:
            case APP_SD_CONTEXT_S002:
                /* do nothing during auto connect */
            case APP_SD_CONTEXT_S517:
                /* do nothing during reconnect */
            case APP_SD_CONTEXT_S513:
            case APP_SD_CONTEXT_S539:
            case APP_SD_CONTEXT_S555:
            case APP_SD_CONTEXT_S597:
            case APP_SD_CONTEXT_S565:
            case APP_SD_CONTEXT_S408_DEL:
            case APP_SD_CONTEXT_S408:
                /* do nothing, wait for timeout of S514, which will then init S002 */

                if ( gAppSdContext.disconnectRequestedByUser > 0)
                {
                    gAppSdContext.disconnectRequestedByUser -= 1;

                }
                    DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "HandlePhoneStateChanged: ignore disc event in ctx %d",
                                    gAppSdContext.pCurCtxCtrl->common.ctxId);
                break;
            case APP_SD_CONTEXT_S542:
                _APP_SD_vInitFrameS597(gAppSdContext.pCurCtxCtrl->s542.deviceId);
                if (gAppSdContext.disconnectRequestedByUser > 0)
                {
                    gAppSdContext.disconnectRequestedByUser -= 1;
                }
                break;
            default:
                /* lost connection to phone */
                // after fast power cycle the connection lost screen is shown,
                // added check to ignore it in that case
                if(ERM_bIsStartupDone() && (gAppSdContext.disconnectRequestedByUser == 0))
                {
                    if(_APP_SD_bIsKl15On() == BT_TRUE)
                    {
                        _APP_SD_vInitFrameS913();
                    }
                    else
                    {
                        _APP_SD_vInitFrameS916();
                    }
                }
                else
                {
                    gAppSdContext.disconnectRequestedByUser -= 1;
                }
                break;
        }
    }
}

void _APP_SD_vHandlePlayerStateChanged()
{
    AT_DeviceId deviceId = ERM_u8GetActivePlayer();
    if(deviceId <= AT_MAX_DEVICE_ID)
    {
        switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
        {
            case APP_SD_CONTEXT_S517:
            {   /* conenct was triggered by SD */
                if( BT_TRUE == ERM_bDeviceAlreadyKnownAsPlayer(deviceId))
                {
                    _APP_SD_vInitFrameS574(deviceId);
                }
                else
                {
                    if( BT_TRUE == ERM_bSdpReceived(deviceId) )
                    {
                        DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "handlePlayerStateChanged: paired device: %d",deviceId);
                        if( (ERM_bIsPhone(deviceId) == BT_TRUE) && (ERM_pGetUserProfile_DevId(deviceId) == NULL) )
                        {
                            DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "handlePlayerStateChanged: new phone device -> create profile (%d)",deviceId);
                            /* there is no user profile available */
                            /* a new paired device is active, set up a user */
                            // go to T5.3
                            if( BT_TRUE == ERM_bMaxNumberOfUserProfilesReached() )
                            {
                                DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "handlePlayerStateChanged: max user profiles reached");
                                // user needs to delete one of the existing profiles first
                                /* save deviceId etc. for pending profile */
                                gAppSdContext.pendingProfile.bPending       = BT_TRUE;
                                gAppSdContext.pendingProfile.profileType    = APP_DEVICE_enTYPE_PHONE;
                                gAppSdContext.pendingProfile.deviceId       = deviceId;
                                /* now tell user to delete an existing profile */
                                _APP_SD_vInitFrameS511();
                            }
                            else
                            {
                                _APP_SD_vInitFrameS534(deviceId);
                            }
                        }
                        else
                        {
                            /* there is no player profile available */
                            /* create new player profile, implicitly delete the oldest player profile if necessary  */
                            APP_DEVICE_vAddMissingPlayerProfileImplicitlyBySD();
                            DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "handlePlayerStateChanged: standalone player -> create profile (%d)",ERM_u8GetActivePlayer());
                            _APP_SD_vInitFrameS574(deviceId);
                        }
                    }
                }
                break;
            }
            case APP_SD_CONTEXT_SC12:
            case APP_SD_CONTEXT_SC12_2:
                if (gAppSdContext.sc12DeviceId != ERM_u8GetActivePlayer())
                {
                    DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "HandlePlayerStateChanged: wait for callback SC12 ctx %d",
                            gAppSdContext.pCurCtxCtrl->common.ctxId);
                    /* wait for callback of SC12 init process */
                }
                else
                {
                    DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "HandlePlayerStateChanged: Player already connected %d",
                            gAppSdContext.pCurCtxCtrl->common.ctxId);
                    /* player already connected */
                    _APP_SD_vInitIdleScreen(0);
                }

                break;
            case APP_SD_CONTEXT_S018:
            case APP_SD_CONTEXT_SP18:
                /* RT: 2443 refresh to update the MP symbol */
                if( BT_FALSE == ERM_bDeviceAlreadyKnownAsPlayer(deviceId) && BT_TRUE == ERM_bSdpReceived(deviceId) && BT_FALSE == ERM_bIsPhone(deviceId))
                {
                    //DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "handlePlayerStateChanged: create profile for player with ID: %d",ERM_u8GetActivePlayer());
                    //_APP_SD_vInitFrameS580(deviceId, APP_DEVICE_enTYPE_PLAYER);
                    APP_DEVICE_vAddMissingPlayerProfileImplicitlyBySD();
                    DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "handlePlayerStateChanged(2): create profile non-blocking: %d",ERM_u8GetActivePlayer());
                }
                else
                {
                    _APP_SD_vRefreshFrame(gAppSdContext.pCurCtxCtrl);
                }
                break;
            default:
                /* standalone player connected */
                /* now check if there is an existing profile, if
                 * not, trigger user to create it */
                if( BT_FALSE == ERM_bDeviceAlreadyKnownAsPlayer(deviceId))
                {
                    // check if this is a standalone player ( no phone
                    // services supported )
                    if( BT_TRUE == ERM_bSdpReceived(deviceId) && BT_FALSE == ERM_bIsPhone(deviceId))
                    {
                        //_APP_SD_vInitFrameS580(deviceId, APP_DEVICE_enTYPE_PLAYER);
                        APP_DEVICE_vAddMissingPlayerProfileImplicitlyBySD();
                        DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "handlePlayerStateChanged(3): create profile non-blocking: %d",ERM_u8GetActivePlayer());
                    }
                    // else: do not just pop up S580 cause there might
                    // be side effects.
                }
                break;
        }
    }
    else
    {
        /* player disconnected */
        switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
        {
        	case APP_SD_CONTEXT_S408:
            case APP_SD_CONTEXT_S513:
            case APP_SD_CONTEXT_S517:
            case APP_SD_CONTEXT_S539:
            case APP_SD_CONTEXT_S555:
            case APP_SD_CONTEXT_S565:
            case APP_SD_CONTEXT_S576:
            case APP_SD_CONTEXT_S579:
            //case APP_SD_CONTEXT_S801:
            case APP_SD_CONTEXT_S901:
            case APP_SD_CONTEXT_SC12:
            case APP_SD_CONTEXT_SC12_2:

                /* do nothing */

                DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "HaPlayerStateChanged: ignore event in ctx %d",
                                gAppSdContext.pCurCtxCtrl->common.ctxId);
                break;
            default:
            {
                AT_DeviceId deviceId = ERM_u8GetLastActivePlayer();

                // after fast power cycle the connection lost screen is shown,
                // added check to ignore it in that case
                if(ERM_bIsStartupDone() && gAppSdContext.disconnectRequestedByUser == 0)
                {
                    if(deviceId != AT_INVALID_DEVICE_ID)
                    {
                        _APP_SD_vInitFrameS914(deviceId);
                    }
                }
                break;
            }
        }
    }
}

static void _APP_SD_vHandlePlayerConnected(AT_DeviceId deviceId)
{
    // in some cases we get a notification about an connected player but getactiveplayer delivers no device such that no playerprofile will be cretead (screen s580)
    // for these cases do show this screen here and don't call playerstatechanged

    DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "GetActivePlayer: %d",ERM_u8GetActivePlayer());

    if((ERM_u8GetActivePlayer() == AT_INVALID_DEVICE_ID) && (BT_TRUE == ERM_bSdpReceived(deviceId)) && (BT_FALSE == ERM_bIsPhone(deviceId)) &&  (BT_FALSE == ERM_bDeviceAlreadyKnownAsPlayer(deviceId)))
    {
        /* create new player profile */
        //_APP_SD_vInitFrameS580(deviceId, APP_DEVICE_enTYPE_PLAYER);
        APP_DEVICE_vAddMissingPlayerProfileImplicitlyBySD();
        DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "HandlePlayerConnected: create profile non-blocking: %d",ERM_u8GetActivePlayer());
    }
    else
    {   /* in some cases we don't want to show a popup */
        _APP_SD_vHandlePlayerStateChanged();
    }
}
static void _APP_SD_vHandlePlayerDisconnected(AT_DeviceId deviceId)
{
    /* in some cases we don't want to show a popup */
    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        case APP_SD_CONTEXT_SC12:
        case APP_SD_CONTEXT_SC12_2:
            /* do not show popup that player disconnected, during Activation of player */
        case APP_SD_CONTEXT_S803:
        case APP_SD_CONTEXT_SC20:
        case APP_SD_CONTEXT_S51D:
        case APP_SD_CONTEXT_S565:
        case APP_SD_CONTEXT_S597:
        case APP_SD_CONTEXT_S534:
        case APP_SD_CONTEXT_S408_DEL:
            if ( gAppSdContext.disconnectRequestedByUser > 0 )
            {
                gAppSdContext.disconnectRequestedByUser -= 1;
            }
            /* do not show popup that player disconnected, during active call */
            break;
        default:
            if (gAppSdContext.disconnectRequestedByUser > 0)
            {
                //reset flag that user has initiated disconnection and don't show bt-connection lost screen
                DEBUG_TEXT( APP_SD_SWI_TRC, MOD_APP_SD, "HandlePlayerSiconnected: disconnect initiated by user" );
                gAppSdContext.disconnectRequestedByUser -= 1;
            }
            else
            {
                _APP_SD_vHandlePlayerStateChanged();
            }
            break;
    }
}


void _APP_SD_vHandleHeadsetStateChanged()
{
    /* not implemented */
    return;

    //AT_DeviceId deviceId = ERM_u8GetActiveHeadSet();
    //if(deviceId <= AT_MAX_DEVICE_ID)
    //{
    //    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    //    {
    //        case APP_SD_CONTEXT_S517:
    //        {
    //            if( BT_TRUE == ERM_bDeviceAlreadyKnownAsHeadset(deviceId))
    //            {
    //                _APP_SD_vInitFrameS574(deviceId);
    //            }
    //            else
    //            {   /* create new headset profile */
    //                _APP_SD_vInitFrameS580(deviceId, APP_DEVICE_enTYPE_HEADSET);
    //            }
    //            break;
    //        }
    //        default:
    //            if( BT_TRUE == ERM_bDeviceAlreadyKnownAsHeadset(deviceId))
    //            {
    //                _APP_SD_vInitFrameS934(deviceId);
    //            }
    //            // else: show S580 to create profile??
    //            else
    //            {
    //                _APP_SD_vInitFrameS580(deviceId, APP_DEVICE_enTYPE_HEADSET);
    //            }
    //            break;
    //    }
    //}
    //else
    //{
    //    /* headset disconnected */
    //    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    //    {
    //        case APP_SD_CONTEXT_S517:
    //        case APP_SD_CONTEXT_S555:
    //        case APP_SD_CONTEXT_S565:
    //        case APP_SD_CONTEXT_S576:
    //        case APP_SD_CONTEXT_S579:
    //        case APP_SD_CONTEXT_S901:
    //        case APP_SD_CONTEXT_SC12:
    //        case APP_SD_CONTEXT_SC12_2:
    //            /* do nothing */

    //            DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "HandleHeadsetStateChanged: ignore event in ctx %d",
    //                            gAppSdContext.pCurCtxCtrl->common.ctxId);
    //            break;
    //        default:
    //        {
    //            AT_DeviceId deviceId = ERM_u8GetLastActiveHeadSet();
    //            if(deviceId != AT_INVALID_DEVICE_ID)
    //            {
    //                _APP_SD_vInitFrameS914(deviceId);
    //            }
    //            break;
    //        }
    //    }
    //}
}

void _APP_SD_setPlayerVisibleIfEncoded(BooleanType bVisible)
{
    BooleanType playerEnabled = BT_FALSE;
    EEPROM_LAYOUT_vGetPlayerEnabled(&playerEnabled );

    if (playerEnabled)
    {
        (void)APP_MDI_sfSetPlayerVisible(bVisible);
        DEBUG_VALUE1(APP_SD_SWI_TRC, MOD_APP_SD, "Player Visibility is set to: %d",bVisible);
    }
    else
    {
        (void)APP_MDI_sfSetPlayerVisible(BT_FALSE);
        DEBUG_TEXT(APP_SD_SWI_TRC, MOD_APP_SD, "Player Visibility is set to False by diagnostic");
    }
}

APP_SD_enContextId APP_SD_getCurrentCtx()
{
    if (gAppSdContext.pCurCtxCtrl != NULL)
    {
        return gAppSdContext.pCurCtxCtrl->common.ctxId;
    }
    else
    {
        return APP_SD_CONTEXT_INVALID;
    }
}

/*----------------------------------------------------------------------------*/
/* Function :                                                                 */
/**
  \brief        Indicates whether the connected player supports AVRCP or not and AVRCP
                service is started

  \return       BooleanType
                BT_TRUE  if the connected player supports AVRCP
                BT_FALSE if the connected player doesn't support AVRCP or no\n
                         player is connected
 */
/*----------------------------------------------------------------------------*/
BooleanType _APP_SD_bRemoteControlAvailable(void)
{
    AT_DeviceId deviceId = ERM_u8GetActivePlayer();
    const ERMBTDeviceTableType *pDevice = ERM_GetBTDevice(deviceId);

    DEBUG_VALUE2(APP_SD_SWI_TRC, MOD_APP_SD, "Player control available: %d, AVRCP is started: %d",
                pDevice->avrcp_supported, pDevice->avrcp_active);

    if((pDevice != NULL) &&
        (pDevice->avrcp_active == AT_FALSE)&&(pDevice->avrcp_supported == AT_TRUE))
    {
        return BT_TRUE;
    }
    else
    {
        return BT_FALSE;
    }
}

/*----------------------------------------------------------------------------*/
/* Function :                                                                 */
/**
  \brief        Indicates whether the the A2DP connection to associated MP is
                already started. Some devices start hfp and a2dp together without
                avrcp.

  \return       BooleanType
                BT_TRUE  if A2DP is supported and started
                BT_FALSE if A2DP is supporter and not started/ not supported
 */
/*----------------------------------------------------------------------------*/
BooleanType _APP_SD_bIsA2dpAlreadyForUserProfileStarted(void)
{
    AT_DeviceId activePlayerDevice = ERM_u8GetActivePlayer();
    const ERMBTDeviceTableType *pDevice = ERM_GetBTDevice(activePlayerDevice);

    AT_DeviceId deviceId = ERM_u8GetActivePhone();
    const ERMUserProfileType *pUser = ERM_pGetUserProfile_DevId(deviceId);
    const ERMPlayerHeadsetProfileType *pAssociatedPlayerProfile = ERM_pGetPlayerHeadsetProfile(pUser->playerIndex);
    AT_DeviceId associatedPlayerDeviceId = pAssociatedPlayerProfile->deviceIndex;


    DEBUG_VALUE2(APP_SD_SWI_TRC, MOD_APP_SD, "Player control available: %d, AVRCP is started: %d",
                pDevice->avrcp_supported, pDevice->avrcp_active);

    if((pDevice != NULL) &&
        (pDevice->a2dp_sink_active == AT_TRUE)&&(pDevice->a2dp_sink_supported == AT_TRUE)
        &&(activePlayerDevice == associatedPlayerDeviceId))
    {
        return BT_TRUE;
    }
    else
    {
        return BT_FALSE;
    }
}

/*----------------------------------------------------------------------------*/
/* Function : _APP_SD_bFrameStaysActiveWhenNotInPhoneContext                  */
/**
  \brief        Indicates that the current active screen will not switch to idle
                screen if the phone context is left via menu roll.

  \return       BooleanType
                BT_TRUE  no idle screen should be active
                BT_FALSE idle screen has to be active
 */
/*----------------------------------------------------------------------------*/
BooleanType _APP_SD_bCurrentFrameStaysActiveWhenNotInPhoneContext()
{
    BooleanType retval = BT_FALSE;

    switch(gAppSdContext.pCurCtxCtrl->common.ctxId)
    {
        /* check if we have a frame that depends on the call state, VCR, PB */
        // don't switch back to idle screen in this Screens
        case APP_SD_CONTEXT_S001:
        case APP_SD_CONTEXT_S010:       //RT13589 Related
        case APP_SD_CONTEXT_S102:       /*RT13591*/
        case APP_SD_CONTEXT_S408:
        case APP_SD_CONTEXT_S408_USERLIST:
        case APP_SD_CONTEXT_S408_ABR:
        case APP_SD_CONTEXT_S408_DEL:
        case APP_SD_CONTEXT_S408_PLAYER:
        case APP_SD_CONTEXT_S408_PRECALL:
        case APP_SD_CONTEXT_S410:
        case APP_SD_CONTEXT_S511:
        case APP_SD_CONTEXT_S512:
        case APP_SD_CONTEXT_S513:
        case APP_SD_CONTEXT_S514:
        case APP_SD_CONTEXT_S517:
        case APP_SD_CONTEXT_S517_PASSIVE:
        case APP_SD_CONTEXT_S51D:
        case APP_SD_CONTEXT_S51D_ACCEPT: //RT13589
        case APP_SD_CONTEXT_S520:
        case APP_SD_CONTEXT_S52C:
        case APP_SD_CONTEXT_S52D:
        case APP_SD_CONTEXT_S534:       // RT15272 - leave this in context, because if not, profile creation is not finished.
        case APP_SD_CONTEXT_S542:        //RT13589 Related
        case APP_SD_CONTEXT_S555:
        case APP_SD_CONTEXT_S581:
        case APP_SD_CONTEXT_S663:
        case APP_SD_CONTEXT_S663_PB:    // RT #3556
        case APP_SD_CONTEXT_S801:
        case APP_SD_CONTEXT_S803:
        case APP_SD_CONTEXT_S804:
        case APP_SD_CONTEXT_S811:
        case APP_SD_CONTEXT_S812:
        case APP_SD_CONTEXT_S813:
        case APP_SD_CONTEXT_S814:
        case APP_SD_CONTEXT_S815:
        case APP_SD_CONTEXT_S901:
        case APP_SD_CONTEXT_S902:
        case APP_SD_CONTEXT_S903:
        case APP_SD_CONTEXT_S917:
        case APP_SD_CONTEXT_S924:
        case APP_SD_CONTEXT_S929:       // RT #1491
        case APP_SD_CONTEXT_S933:
        case APP_SD_CONTEXT_S941:
        case APP_SD_CONTEXT_S942:
        case APP_SD_CONTEXT_S945:
        case APP_SD_CONTEXT_SC12:
        case APP_SD_CONTEXT_SC12_2:
        case APP_SD_CONTEXT_SC13:
        case APP_SD_CONTEXT_SC14:
        case APP_SD_CONTEXT_SC20:
        case APP_SD_CONTEXT_SC24:
        case APP_SD_CONTEXT_SA01:       // RT #3122
        case APP_SD_CONTEXT_SA02:       // RT #3122
        case APP_SD_CONTEXT_SA03:       // RT #3122
            retval = BT_TRUE;
            break;
        default:
            /* do nothing here because retval initialised with FALSE */
            break;
    }

    return retval;
}


/*----------------------------------------------------------------------------*/
/* Function : _APP_SD_bSSPSuccessFail                  */
/**
  \brief        Indicates that the current device supports SSP

  \return       BooleanType
                BT_TRUE  SSP is supported
                BT_FALSE SSP is not supported
 */
/*----------------------------------------------------------------------------*/
/*RT13181: 4 digit pin shown instead of SSP*/

static BooleanType _APP_SD_bSSPSuccessFail(Uint32Type resultBitfield, Uint32Type statusBitfield)
{
	BooleanType retval = BT_FALSE;

    if ( APP_SD_SSP_INQUIRY_RESULT_ENABLE == \
            (resultBitfield & \
             statusBitfield & \
             APP_SD_SSP_INQUIRY_RESULT_MASK))
    {
    	retval = BT_TRUE;
    }

    return retval;
}

static APP_COMMON_enResponseCode _APP_SD_bSSPInitiatePairingAfterInquiry(AT_DeviceId deviceId, void (*cb)(APP_COMMON_enResponseCode))
{
    ATPinCodeBT          pinData;
    Uint8Type           numPinDigits = 4;
    APP_COMMON_enResponseCode rspCode = APP_COMMON_RSP_ERROR;

    DEBUG_VALUE1( APP_SD_SWI_TRC, MOD_APP_SD, "_APP_SD_bSSPInitiatePairingAfterInquiry call with deviceId = %d",deviceId);

    /* for secure simple pairing it is enough to send the pairing request with
     * a standard pin like 0000 or 1234. The SSP passphrase will be send by
     * remote device.
     */
    (void)memset(pinData, 0x00, sizeof(pinData));
    memcpy(pinData,"0000",numPinDigits);

    rspCode = ERM_rcInitiatePairing( deviceId,
            AT_INQUIRY_DEVICE,
            pinData,
            numPinDigits,
            cb);

    return rspCode;
}
//RT14853
/*----------------------------------------------------------------------------*/
/* Function : _blastRingtonestate                  */
/**
  \brief        Indicates the position of S642 screen

  \return       BooleanType
                BT_TRUE  ringtone play status still valid
                BT_FALSE ringtone play status not valid
 */
/*----------------------------------------------------------------------------*/
BooleanType _APP_SD_blastRingtonestate(void)
{
    return gAppSdContext.blastRingtoneindication;
}
/*----------------------------------------------------------------------------*/
/* Function : _vnotifiedRingtonestate                  */
/**
  \brief        Resets the ringtone position status

 */
/*----------------------------------------------------------------------------*/
void _APP_SD_vnotifiedRingtonestate()
{
    gAppSdContext.blastRingtoneindication = BT_FALSE;
}

/* End Of File APP_SD_C1.c */


